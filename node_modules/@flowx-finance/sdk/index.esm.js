import BN, { BN as BN$1 } from 'bn.js';
import { normalizeSuiObjectId, parseStructTag, normalizeStructTag as normalizeStructTag$1, SUI_TYPE_ARG, SUI_CLOCK_OBJECT_ID, isValidSuiAddress, SUI_SYSTEM_STATE_OBJECT_ID, toHEX, fromHEX } from '@mysten/sui/utils';
import invariant from 'tiny-invariant';
import { normalizeStructTag, SUI_CLOCK_OBJECT_ID as SUI_CLOCK_OBJECT_ID$1 } from '@mysten/sui.js/utils';
import BigNumber from 'bignumber.js';
import { SuiClient, getFullnodeUrl } from '@mysten/sui/client';
import { Transaction, coinWithBalance } from '@mysten/sui/transactions';
import _, { isNil, chunk, uniq } from 'lodash';
import pLimit from 'p-limit';
import NodeCache from 'node-cache';
import CryptoJS from 'crypto-js';
import { GraphQLClient, gql } from 'graphql-request';
import { bcs } from '@mysten/sui/bcs';
import { Buffer } from 'buffer';
import JSONbig from 'json-bigint';
import objectHash from 'object-hash';

function sdk() {
    return 'sdk';
}

var Rounding;
(function (Rounding) {
    Rounding[Rounding["ROUND_DOWN"] = 0] = "ROUND_DOWN";
    Rounding[Rounding["ROUND_HALF_UP"] = 1] = "ROUND_HALF_UP";
    Rounding[Rounding["ROUND_UP"] = 2] = "ROUND_UP";
})(Rounding || (Rounding = {}));
const ADDRESS_ZERO = '0x0000000000000000000000000000000000000000000000000000000000000000';
const SUI_PACKAGE_ID = '0x2';
const STD_PACKAGE_ID = '0x1';
const MODULE_OPTION = 'option';
const ZERO = new BN(0);
const ONE = new BN(1);
const MaxUint64 = new BN('ffffffffffffffff', 16);
const MaxUint256 = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);
const DEFAULT_DECIMAL = 9;
const Q64 = new BN(2).pow(new BN(64));
const Q128 = new BN(2).pow(new BN(128));
const DEADLINE_TIME_SECONDS = 20 * 60; // minutes
const MAX_OBJECTS_PER_QUERY = 50;
const MAX_OBJECTS_DEV_INSPECT_PER_QUERY = 1000;
const DEFAULT_CONCURRENCY = 10;
const DEFAULT_CACHE_EXPIRATION_TIME_SECONDS = 120;

class ObjectId {
    constructor(objectId) {
        this.id = normalizeSuiObjectId(objectId);
    }
}

class BasePool extends ObjectId {
    constructor(objectId, coins, reserves) {
        invariant(coins.length > 0 && coins.length === reserves.length, 'LENGTH');
        super(objectId);
        this.coins = coins;
        this.reserves = reserves;
    }
    involvesCoin(coin) {
        return this.coins.some((it) => it.coinType === coin.coinType);
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const EQUAL = 0;
const LESS_THAN = 1;
const GREATER_THAN = 2;
function cmp(a, b) {
    if (a === b) {
        return EQUAL;
    }
    if (a < b) {
        return LESS_THAN;
    }
    return GREATER_THAN;
}
function compare(symbolX, symbolY) {
    let i = 0;
    (symbolX = normalizeStructTag(symbolX)),
        (symbolY = normalizeStructTag(symbolY));
    const len = symbolX.length <= symbolY.length ? symbolX.length : symbolY.length;
    const lenCmp = cmp(symbolX.length, symbolY.length);
    while (i < len) {
        const elemCmp = cmp(symbolX.charCodeAt(i), symbolY.charCodeAt(i));
        i += 1;
        if (elemCmp !== 0) {
            return elemCmp;
        }
    }
    return lenCmp;
}
function isSortedSymbols(symbolX, symbolY) {
    return compare(symbolX, symbolY) === LESS_THAN;
}

class Coin {
    constructor(coinType, decimals, symbol, name, description, iconUrl, derivedPriceInUSD, derivedSUI, isVerified) {
        parseStructTag(coinType);
        invariant(!decimals ||
            (decimals >= 0 && decimals < 255 && Number.isInteger(decimals)), 'DECIMALS');
        this.coinType = normalizeStructTag$1(coinType);
        this.decimals = decimals || 0;
        this.symbol = symbol;
        this.name = name;
        this.description = description;
        this.iconUrl = iconUrl;
        this.derivedPriceInUSD = derivedPriceInUSD;
        this.derivedSUI = derivedSUI;
        this.isVerified = isVerified;
    }
    sortsBefore(other) {
        invariant(this.coinType.toLowerCase() !== other.coinType.toLowerCase(), 'COIN_TYPES');
        return isSortedSymbols(this.coinType.toLowerCase(), other.coinType.toLowerCase());
    }
    wrapped() {
        return this;
    }
    equals(other) {
        return this.coinType === other.coinType;
    }
    fetchAllOwnedCoins(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const coins = [];
            let cursor, hasNextPage = false;
            do {
                const resp = yield params.client.getCoins({
                    owner: params.owner,
                    coinType: this.coinType,
                    cursor,
                });
                coins.push(...resp.data);
                cursor = resp.nextCursor;
                hasNextPage = resp.hasNextPage;
            } while (hasNextPage);
            return coins;
        });
    }
    /**
     * @deprecated use CoinWithBalance instead
     */
    take(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { owner, amount, tx, client, isDevInspect } = params;
            const ownedCoins = yield this.fetchAllOwnedCoins({
                owner,
                client,
            });
            const totalBalance = ownedCoins.reduce((memo, coin) => memo.add(new BN$1(coin.balance)), ZERO);
            invariant(totalBalance.gte(new BN$1(amount.toString())), 'IF');
            if (this.coinType === normalizeStructTag$1(SUI_TYPE_ARG) && !isDevInspect) {
                tx.setGasPayment(ownedCoins.map((coin) => ({
                    digest: coin.digest,
                    objectId: coin.coinObjectId,
                    version: coin.version,
                })));
                const [splitted] = tx.splitCoins(tx.gas, [amount.toString()]);
                return splitted;
            }
            else {
                if (ownedCoins.length > 1) {
                    tx.mergeCoins(ownedCoins[0].coinObjectId, ownedCoins.slice(1).map((coin) => coin.coinObjectId));
                }
                const [splitted] = tx.splitCoins(ownedCoins[0].coinObjectId, [
                    amount.toString(),
                ]);
                return splitted;
            }
        });
    }
}

const toFixedRounding = {
    [Rounding.ROUND_DOWN]: BigNumber.ROUND_DOWN,
    [Rounding.ROUND_HALF_UP]: BigNumber.ROUND_HALF_UP,
    [Rounding.ROUND_UP]: BigNumber.ROUND_UP,
};
class Fraction {
    constructor(numerator, denominator = new BN(1)) {
        this.numerator = new BN(numerator);
        this.denominator = new BN(denominator);
    }
    static tryParseFraction(fractionish) {
        if (fractionish instanceof BN ||
            typeof fractionish === 'number' ||
            typeof fractionish === 'string')
            return new Fraction(fractionish);
        if ('numerator' in fractionish && 'denominator' in fractionish)
            return fractionish;
        throw new Error('Could not parse fraction');
    }
    // performs floor division
    get quotient() {
        return this.numerator.div(this.denominator);
    }
    // remainder after floor division
    get remainder() {
        return new Fraction(this.denominator.mod(this.denominator), this.denominator);
    }
    invert() {
        return new Fraction(this.denominator, this.numerator);
    }
    add(other) {
        const otherParsed = Fraction.tryParseFraction(other);
        if (this.denominator.eq(otherParsed.denominator)) {
            return new Fraction(this.numerator.add(otherParsed.numerator), this.denominator);
        }
        return new Fraction(this.numerator
            .mul(otherParsed.denominator)
            .add(otherParsed.numerator.mul(this.denominator)), this.denominator.mul(otherParsed.denominator));
    }
    subtract(other) {
        const otherParsed = Fraction.tryParseFraction(other);
        if (this.denominator.eq(otherParsed.denominator)) {
            return new Fraction(this.numerator.sub(otherParsed.numerator), this.denominator);
        }
        return new Fraction(this.numerator
            .mul(otherParsed.denominator)
            .sub(otherParsed.numerator.mul(this.denominator)), this.denominator.mul(otherParsed.denominator));
    }
    multiply(other) {
        const otherParsed = Fraction.tryParseFraction(other);
        return new Fraction(this.numerator.mul(otherParsed.numerator), this.denominator.mul(otherParsed.denominator));
    }
    divide(other) {
        const otherParsed = Fraction.tryParseFraction(other);
        return new Fraction(this.numerator.mul(otherParsed.denominator), this.denominator.mul(otherParsed.numerator));
    }
    lt(other) {
        const otherParsed = Fraction.tryParseFraction(other);
        return this.numerator
            .mul(otherParsed.denominator)
            .lt(otherParsed.numerator.mul(this.denominator));
    }
    eq(other) {
        const otherParsed = Fraction.tryParseFraction(other);
        return this.numerator
            .mul(otherParsed.denominator)
            .eq(otherParsed.numerator.mul(this.denominator));
    }
    gt(other) {
        const otherParsed = Fraction.tryParseFraction(other);
        return this.numerator
            .mul(otherParsed.denominator)
            .gt(otherParsed.numerator.mul(this.denominator));
    }
    toFixed(decimalPlaces, format = { groupSeparator: '', decimalSeparator: '.' }, rounding = Rounding.ROUND_HALF_UP) {
        invariant(Number.isInteger(decimalPlaces), `${decimalPlaces} is not an integer.`);
        invariant(decimalPlaces >= 0, `${decimalPlaces} is negative.`);
        const BN = BigNumber.clone();
        BN.set({
            DECIMAL_PLACES: decimalPlaces,
            ROUNDING_MODE: toFixedRounding[rounding],
        });
        return new BN(this.numerator.toString())
            .div(this.denominator.toString())
            .toFormat(decimalPlaces, format);
    }
    /**
     * Helper method for converting any super class back to a fraction
     */
    get asFraction() {
        return new Fraction(this.numerator, this.denominator);
    }
    static max(...n) {
        invariant(n.length > 0, 'LENGTH');
        let temp = n[0];
        n.slice(1).forEach((item) => {
            if (item.gt(temp)) {
                temp = item;
            }
        });
        return temp;
    }
    static min(...n) {
        invariant(n.length > 0, 'LENGTH');
        let temp = n[0];
        n.slice(1).forEach((item) => {
            if (item.lt(temp)) {
                temp = item;
            }
        });
        return temp;
    }
}

class Price extends Fraction {
    /**
     * Construct a price, either with the base and quote currency amount, or the
     * @param args
     */
    constructor(...args) {
        const [baseCoin, quoteCoin, denominator, numerator] = args;
        super(numerator, denominator);
        this.baseCoin = baseCoin;
        this.quoteCoin = quoteCoin;
        this.scalar = new Fraction(new BN$1(10).pow(new BN$1(baseCoin.decimals)), new BN$1(10).pow(new BN$1(quoteCoin.decimals)));
    }
    /**
     * Flip the price, switching the base and quote currency
     */
    invert() {
        return new Price(this.quoteCoin, this.baseCoin, this.numerator, this.denominator);
    }
    /**
     * Multiply the price by another price, returning a new price. The other price must have the same base currency as this price's quote currency
     * @param other the other price
     */
    multiply(other) {
        invariant(this.quoteCoin.equals(other.baseCoin), 'COIN');
        const fraction = super.multiply(other);
        return new Price(this.baseCoin, other.quoteCoin, fraction.denominator, fraction.numerator);
    }
    /**
     * Return the amount of quote currency corresponding to a given amount of the base currency
     * @param coinAmount the amount of base currency to quote against the price
     */
    quote(coinAmount) {
        const result = super.multiply(coinAmount);
        return new Fraction(result.numerator, result.denominator);
    }
    /**
     * Get the value scaled by decimals for formatting
     * @private
     */
    get adjustedForDecimals() {
        return super.multiply(this.scalar);
    }
    toFixed(decimalPlaces = 4, format, rounding) {
        return this.adjustedForDecimals.toFixed(decimalPlaces, format, rounding);
    }
}

const ONE_HUNDRED = new Fraction(100);
class Percent extends Fraction {
    constructor() {
        super(...arguments);
        /**
         * This boolean prevents a fraction from being interpreted as a Percent
         */
        this.isPercent = true;
    }
    /**
     * Converts a fraction to a percent
     * @param fraction the fraction to convert
     */
    static toPercent(fraction) {
        return new Percent(fraction.numerator, fraction.denominator);
    }
    add(other) {
        return Percent.toPercent(super.add(other));
    }
    subtract(other) {
        return Percent.toPercent(super.subtract(other));
    }
    multiply(other) {
        return Percent.toPercent(super.multiply(other));
    }
    divide(other) {
        return Percent.toPercent(super.divide(other));
    }
    toFixed(decimalPlaces = 2, format, rounding) {
        return super.multiply(ONE_HUNDRED).toFixed(decimalPlaces, format, rounding);
    }
}

class TxBuilder {
    constructor(network) {
        this.network = network;
        this._tx = new Transaction();
    }
    static createInstance(network) {
        const ins = new this(network);
        return ins;
    }
    static setClient(client) {
        TxBuilder._client = client;
    }
    get _client() {
        var _a;
        return ((_a = TxBuilder._client) !== null && _a !== void 0 ? _a : new SuiClient({ url: getFullnodeUrl(this.network) }));
    }
    clone() {
        return _.cloneDeep(this);
    }
    suiClient(client) {
        TxBuilder._client = client;
        return this;
    }
    tx(tx) {
        this._tx = tx;
        return this;
    }
    getTx() {
        return this._tx;
    }
    coinIn(coinIn) {
        this._coinIn = coinIn;
        return this;
    }
    sender(sender) {
        this._sender = sender;
        return this;
    }
    createU64Option(value) {
        const tx = this._tx;
        return tx.moveCall({
            package: STD_PACKAGE_ID,
            module: MODULE_OPTION,
            function: !isNil(value) ? 'some' : 'none',
            typeArguments: ['u64'],
            arguments: !isNil(value)
                ? [typeof value === 'string' ? tx.pure.u64(value) : value]
                : [],
        });
    }
    createAddressOption(value) {
        const tx = this._tx;
        return tx.moveCall({
            package: STD_PACKAGE_ID,
            module: MODULE_OPTION,
            function: !isNil(value) ? 'some' : 'none',
            typeArguments: ['address'],
            arguments: !isNil(value)
                ? [typeof value === 'string' ? tx.pure.address(value) : value]
                : [],
        });
    }
    createBooleanOption(value) {
        const tx = this._tx;
        return tx.moveCall({
            package: STD_PACKAGE_ID,
            module: MODULE_OPTION,
            function: !isNil(value) ? 'some' : 'none',
            typeArguments: ['bool'],
            arguments: !isNil(value)
                ? [typeof value === 'boolean' ? tx.pure.bool(value) : value]
                : [],
        });
    }
    getFullyOwnedObjects(account, options, filter) {
        return __awaiter(this, void 0, void 0, function* () {
            let hasNextPage = false;
            const data = [];
            let cursor;
            do {
                const results = yield this._client.getOwnedObjects({
                    owner: account,
                    options,
                    cursor,
                    filter,
                });
                cursor = results.nextCursor;
                hasNextPage = results.hasNextPage;
                data.push(...results.data);
            } while (hasNextPage);
            return data;
        });
    }
    getMultipleIds(lpObjectIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const splitObjectIds = [];
            for (let i = 0; i < lpObjectIds.length; i += 50) {
                splitObjectIds.push(lpObjectIds.slice(i, i + 50));
            }
            const splitContentInfos = yield Promise.all(splitObjectIds.map((items) => this._client.multiGetObjects({
                ids: items,
                options: { showContent: true, showType: true },
            })));
            return splitContentInfos.flat();
        });
    }
    getFullyDynamicFields(parentId) {
        return __awaiter(this, void 0, void 0, function* () {
            let cursor, hasNextPage = false;
            const data = [];
            do {
                const result = yield this._client.getDynamicFields({
                    parentId,
                    cursor,
                });
                cursor = result.nextCursor;
                hasNextPage = result.hasNextPage;
                data.push(...result.data);
            } while (hasNextPage);
            return data;
        });
    }
}

class CoinAmount extends Fraction {
    /**
     * Returns a new currency amount instance from the unitless amount of token, i.e. the raw amount
     * @param coin the currency in the amount
     * @param rawAmount the raw token or ether amount
     */
    static fromRawAmount(coin, rawAmount) {
        return new CoinAmount(coin, rawAmount);
    }
    /**
     * Construct a currency amount with a denominator that is not equal to 1
     * @param coin the currency
     * @param numerator the numerator of the fractional token amount
     * @param denominator the denominator of the fractional token amount
     */
    static fromFractionalAmount(coin, numerator, denominator) {
        return new CoinAmount(coin, numerator, denominator);
    }
    static ONE(coin) {
        const oneAmount = new BN(10).pow(new BN(coin.decimals));
        return new CoinAmount(coin, oneAmount);
    }
    constructor(coin, numerator, denominator) {
        super(numerator, denominator);
        invariant(new BN(this.quotient).lte(MaxUint256), 'AMOUNT');
        this.coin = coin;
        this.decimalScale = new BN(10).pow(new BN(coin.decimals));
    }
    add(other) {
        invariant(this.coin.equals(other.coin), 'CURRENCY');
        const added = super.add(other);
        return CoinAmount.fromFractionalAmount(this.coin, added.numerator, added.denominator);
    }
    subtract(other) {
        invariant(this.coin.equals(other.coin), 'CURRENCY');
        const subtracted = super.subtract(other);
        return CoinAmount.fromFractionalAmount(this.coin, subtracted.numerator, subtracted.denominator);
    }
    multiply(other) {
        const multiplied = super.multiply(other);
        return CoinAmount.fromFractionalAmount(this.coin, multiplied.numerator, multiplied.denominator);
    }
    divide(other) {
        const divided = super.divide(other);
        return CoinAmount.fromFractionalAmount(this.coin, divided.numerator, divided.denominator);
    }
    toFixed(decimalPlaces = this.coin.decimals, format = { groupSeparator: '', decimalSeparator: '.' }, rounding = Rounding.ROUND_DOWN) {
        invariant(decimalPlaces <= this.coin.decimals, 'DECIMALS');
        return super
            .divide(this.decimalScale)
            .toFixed(decimalPlaces, format, rounding);
    }
    toExact(format = { groupSeparator: '', decimalSeparator: '.' }) {
        const BN = BigNumber.clone();
        BN.set({ DECIMAL_PLACES: this.coin.decimals });
        return new BN(this.quotient.toString())
            .div(this.decimalScale.toString())
            .toFormat(format);
    }
}

function sumBn$1(bigNumbers) {
    return bigNumbers.reduce((memo, bn) => memo.add(bn), ZERO);
}
function minBn(...bigNumbers) {
    invariant(bigNumbers.length > 0, 'EMPTY');
    let min = bigNumbers[0];
    for (let i = 1; i < bigNumbers.length; i++) {
        if (bigNumbers[i].lt(min))
            min = bigNumbers[i];
    }
    return min;
}
function maxBn(...bigNumbers) {
    invariant(bigNumbers.length > 0, 'EMPTY');
    let max = bigNumbers[0];
    for (let i = 1; i < bigNumbers.length; i++) {
        if (bigNumbers[i].gt(max))
            max = bigNumbers[i];
    }
    return max;
}
const sqrtBn = (x) => {
    let bit = new BN('1').shln(256);
    let res = new BN(0); // Result starts at 0
    // Perform bitwise algorithm to calculate the integer square root
    while (!bit.isZero()) {
        if (x.gte(res.add(bit))) {
            x = x.sub(res.add(bit));
            res = res.shrn(1).add(bit);
        }
        else {
            res = res.shrn(1);
        }
        bit = bit.shrn(2);
    }
    return res;
};

const getDeadlineAtTimestampMs = () => {
    const now = Date.now();
    return now + DEADLINE_TIME_SECONDS * 1000;
};

const bn = (val) => {
    return new BigNumber(val);
};
const mapArgs = (...args) => {
    return args.map((arg) => {
        if (arg instanceof BigNumber) {
            return arg;
        }
        return bn(arg);
    });
};
const sumBn = (...args) => {
    if (args.length < 2) {
        throw new Error('sumBn: Must have at least 2 parameters');
    }
    const newArgs = mapArgs(...args);
    return newArgs.reduce((acc, val) => acc.plus(val), bn(0));
};
const subBn = (...args) => {
    if (args.length < 2) {
        throw new Error('subBn: Must have at least 2 parameters');
    }
    const newArgs = mapArgs(...args);
    const first = newArgs.shift();
    return newArgs.reduce((acc, val) => acc.minus(val), first);
};
const mulBn = (...args) => {
    if (args.length < 2) {
        throw new Error('mulBn: Must have at least 2 parameters');
    }
    const newArgs = mapArgs(...args);
    return newArgs.reduce((acc, val) => acc.times(val), bn(1));
};
const divBn = (...args) => {
    if (args.length < 2) {
        throw new Error('divBn: Must have at least 2 parameters');
    }
    const newArgs = mapArgs(...args);
    const first = newArgs.shift();
    return newArgs.reduce((acc, val) => acc.div(val), first);
};

var bigNumber = /*#__PURE__*/Object.freeze({
  __proto__: null,
  bn: bn,
  divBn: divBn,
  mulBn: mulBn,
  subBn: subBn,
  sumBn: sumBn
});

function removeEmptyFields(data) {
    if (Array.isArray(data)) {
        // For arrays: remove empty elements recursively
        return data
            .map((item) => removeEmptyFields(item))
            .filter((element) => {
            return element !== null && element !== undefined && element !== '';
        });
    }
    else if (typeof data === 'object' && data !== null) {
        // For objects: recursively remove empty fields
        const newObj = {};
        Object.keys(data).forEach((key) => {
            const cleanedValue = removeEmptyFields(data[key]);
            if (cleanedValue !== null &&
                cleanedValue !== undefined &&
                cleanedValue !== '') {
                newObj[key] = cleanedValue;
            }
        });
        return newObj;
    }
    else {
        // Return data as is for other types (numbers, strings, etc.) and null values
        return data;
    }
}

function nowInMilliseconds() {
    return Date.now();
}
// Alias for nowInMillisecond
function now() {
    return nowInMilliseconds();
}
function toSeconds(ms) {
    return Math.floor(ms / 1000);
}

const sdkCache = new NodeCache({ stdTTL: 100, checkperiod: 120 });

const getAllOwnedObjects = (_a, client_1) => __awaiter(void 0, [_a, client_1], void 0, function* ({ owner, objectType }, client) {
    let cursor, hasNextPage = false;
    const results = [];
    do {
        const reps = yield client.getOwnedObjects({
            owner,
            filter: {
                StructType: objectType,
            },
            cursor,
            options: {
                showContent: true,
                showType: true,
            },
        });
        cursor = reps.nextCursor;
        hasNextPage = reps.hasNextPage;
        results.push(...reps.data.map((it) => it.data));
    } while (hasNextPage);
    return results;
});
const getAllDynamicFields = (parentId, client) => __awaiter(void 0, void 0, void 0, function* () {
    let cursor, hasNextPage = false;
    const results = [];
    do {
        const reps = yield client.getDynamicFields({
            parentId,
            cursor,
        });
        cursor = reps.nextCursor;
        hasNextPage = reps.hasNextPage;
        results.push(...reps.data);
    } while (hasNextPage);
    return results;
});
const limit$2 = pLimit(DEFAULT_CONCURRENCY);
const multiGetObjects = (client, objectIds, options) => __awaiter(void 0, void 0, void 0, function* () {
    const batches = chunk(objectIds, MAX_OBJECTS_PER_QUERY);
    const results = yield Promise.all(batches.map((batch) => limit$2(() => client.multiGetObjects({
        ids: batch,
        options: options !== null && options !== void 0 ? options : {
            showOwner: true,
            showType: true,
            showContent: true,
        },
    }))));
    return results
        .flat()
        .filter((item) => !!item.data)
        .map((item) => item.data);
});
const queryAllEvents = (query, client) => __awaiter(void 0, void 0, void 0, function* () {
    let result = [];
    let hasNextPage = true;
    let nextCursor;
    do {
        const res = yield client.queryEvents({
            query,
            cursor: nextCursor,
        });
        if (res.data) {
            result = [...result, ...res.data];
            hasNextPage = res.hasNextPage;
            nextCursor = res.nextCursor;
        }
        else {
            hasNextPage = false;
        }
    } while (hasNextPage);
    return result;
});
const fetchCoin = (coinType) => (client) => __awaiter(void 0, void 0, void 0, function* () {
    const cached = sdkCache.get(coinType);
    if (cached) {
        return cached;
    }
    const metadata = yield client.getCoinMetadata({
        coinType: coinType,
    });
    invariant(metadata, 'coin not found');
    const token = new Coin(coinType, metadata.decimals, metadata.symbol, metadata.name);
    sdkCache.set(coinType, token, 0);
    return token;
});

const standardShortCoinType = (hexString) => {
    return '0x' + hexString.replace('0x', '').replace(/^0+/, '');
};
const stripZeros = function (a) {
    let first = a[0];
    while (a.length > 0 && first.toString() === '0') {
        a = a.slice(1);
        first = a[0];
    }
    return a;
};
function shortedCoinType(type) {
    const { address, module, name, typeParams } = typeof type === 'string' ? parseStructTag(type) : type;
    const formattedTypeParams = (typeParams === null || typeParams === void 0 ? void 0 : typeParams.length) > 0
        ? `<${typeParams
            .map((typeParam) => typeof typeParam === 'string'
            ? typeParam
            : shortedCoinType(typeParam))
            .join(',')}>`
        : '';
    return `0x${stripZeros(address.replace('0x', ''))}::${module}::${name}${formattedTypeParams}`;
}

function reflect(promise) {
    return promise
        .then((data) => {
        return { data, status: 'resolved' };
    })
        .catch((error) => {
        return { error, status: 'rejected' };
    });
}
function PromiseAll(values_1) {
    return __awaiter(this, arguments, void 0, function* (values, concurrency = 10) {
        const limit = pLimit(concurrency);
        const results = [];
        yield (() => __awaiter(this, void 0, void 0, function* () {
            return yield Promise.all(values.map((value) => limit(() => reflect(value))));
        }))().then((res) => __awaiter(this, void 0, void 0, function* () {
            const errors = [];
            res.forEach((r) => {
                if (r.status === 'rejected') {
                    errors.push(r.error);
                }
                else {
                    results.push(r.data);
                }
            });
            if (errors.length > 0) {
                // have lots of error, throw first error
                throw errors[0];
            }
        }));
        return results;
    });
}

class CustomError extends Error {
    constructor(message) {
        super(`FlowxSDK: ${message}`);
    }
}

class GraphqlProvider {
    constructor(network = 'mainnet', config) {
        this.client = new GraphQLClient(CONFIGS$5[network].graphql.baseURI, config);
    }
}

const queryCoins = gql `
  query QueryCoins(
    $size: Int
    $page: Int
    $isVerified: Boolean
    $coinTypes: [String!]
    $sortBy: String
    $sortDirection: SortDirection
    $searchKey: String
  ) {
    queryCoins(
      size: $size
      page: $page
      isVerified: $isVerified
      coinTypes: $coinTypes
      sortBy: $sortBy
      sortDirection: $sortDirection
      searchKey: $searchKey
    ) {
      page
      size
      total
      items {
        _id
        name
        symbol
        type
        decimals
        iconUrl
        description
        explorerUrl
        derivedSUI
        derivedSUIV3
        derivedPriceInUSD
        totalVolume
        totalVolumeV3
        totalVolumeInUSD
        totalVolumeInUSDV3
        totalLiquidity
        totalLiquidityV3
        txCount
        isVerified
        twitterUrl
        websiteUrl
        coinMarketcapUrl
        coingeckoUrl
      }
    }
  }
`;
const multiGetCoins = gql `
  query MultiGetCoins($coinTypes: [String!]!) {
    multiGetCoins(coinTypes: $coinTypes) {
      markets {
        price
      }
      name
      iconUrl
      decimals
      description
      type
      symbol
      isVerified
    }
  }
`;

const CACHE_TTL = 60;
class CoinProvider {
    constructor(network = 'mainnet') {
        this.graphqlProvider = new GraphqlProvider(network);
    }
    getCoins(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const variables = {
                size: (_a = filter === null || filter === void 0 ? void 0 : filter.limit) !== null && _a !== void 0 ? _a : 10,
                page: (_b = filter === null || filter === void 0 ? void 0 : filter.page) !== null && _b !== void 0 ? _b : 1,
                isVerified: filter === null || filter === void 0 ? void 0 : filter.isVerified,
                coinTypes: (_c = filter === null || filter === void 0 ? void 0 : filter.coinTypes) === null || _c === void 0 ? void 0 : _c.map((type) => standardShortCoinType(type)),
                sortBy: (_d = filter === null || filter === void 0 ? void 0 : filter.sortBy) !== null && _d !== void 0 ? _d : 'createdAt',
                sortDirection: (_e = filter === null || filter === void 0 ? void 0 : filter.sortDirection) !== null && _e !== void 0 ? _e : 'asc',
                searchKey: filter === null || filter === void 0 ? void 0 : filter.searchKey,
            };
            const key = `QUERY_COIN ${CryptoJS.MD5(JSON.stringify(_.values(variables)))}`;
            let response = sdkCache.get(key);
            if (!response) {
                response = yield this.graphqlProvider.client.request(queryCoins, {
                    size: (_f = filter === null || filter === void 0 ? void 0 : filter.limit) !== null && _f !== void 0 ? _f : 10,
                    page: (_g = filter === null || filter === void 0 ? void 0 : filter.page) !== null && _g !== void 0 ? _g : 1,
                    isVerified: filter === null || filter === void 0 ? void 0 : filter.isVerified,
                    coinTypes: (_h = filter === null || filter === void 0 ? void 0 : filter.coinTypes) === null || _h === void 0 ? void 0 : _h.map((type) => standardShortCoinType(type)),
                    sortBy: (_j = filter === null || filter === void 0 ? void 0 : filter.sortBy) !== null && _j !== void 0 ? _j : 'createdAt',
                    sortDirection: (_k = filter === null || filter === void 0 ? void 0 : filter.sortDirection) !== null && _k !== void 0 ? _k : 'asc',
                    searchKey: filter === null || filter === void 0 ? void 0 : filter.searchKey,
                });
                sdkCache.set(`QUERY_COIN ${CryptoJS.MD5(JSON.stringify(_.values(variables)))}`, response);
            }
            const listCoins = [];
            response.queryCoins.items.map((it) => {
                listCoins.push(new Coin(it.type, it.decimals, it.symbol, it.name, it.description, it.iconUrl, it.derivedPriceInUSD, it.derivedSUI, it.isVerified));
            });
            return listCoins;
        });
    }
    multiGetCoins(coinTypes_1) {
        return __awaiter(this, arguments, void 0, function* (coinTypes, refreshCache = false) {
            const key = `MULTI_GET_COINS_${CryptoJS.MD5(JSON.stringify(_.values(coinTypes)))}`;
            if (!refreshCache) {
                const cached = sdkCache.get(key);
                if (cached) {
                    return cached;
                }
            }
            const res = yield this.graphqlProvider.client.request(multiGetCoins, {
                coinTypes,
            });
            const coins = res.multiGetCoins.map((item) => new Coin(item.type, item.decimals, item.symbol, item.name, item.description, item.iconUrl, item.markets.price, '0', item.isVerified));
            sdkCache.set(key, coins, CACHE_TTL);
            return coins;
        });
    }
    multiGetPrices(coinTypes_1) {
        return __awaiter(this, arguments, void 0, function* (coinTypes, refreshCache = false) {
            const coins = yield this.multiGetCoins(coinTypes, refreshCache);
            const mappingPrice = coins.reduce((memo, coin) => {
                memo[coin.coinType] = Number(coin.derivedPriceInUSD);
                return memo;
            }, {});
            return coinTypes.map((coinType) => { var _a; return (_a = mappingPrice[normalizeStructTag$1(coinType)]) !== null && _a !== void 0 ? _a : 0; });
        });
    }
}

var _SuiBatchClient_queue, _SuiBatchClient_pendingAggregator;
const limit$1 = pLimit(DEFAULT_CONCURRENCY);
class SuiBatchClient extends SuiClient {
    constructor(options) {
        super(options);
        _SuiBatchClient_queue.set(this, []);
        _SuiBatchClient_pendingAggregator.set(this, void 0);
        this.scheduleTimeMs = options.scheduleTimeMs;
    }
    getObject(input) {
        return __awaiter(this, void 0, void 0, function* () {
            if (__classPrivateFieldGet(this, _SuiBatchClient_queue, "f") == null) {
                __classPrivateFieldSet(this, _SuiBatchClient_queue, [], "f");
            }
            const inflightRequest = {
                request: normalizeSuiObjectId(input.id),
                resolve: null,
                reject: null,
            };
            const promise = new Promise((resolve, reject) => {
                inflightRequest.resolve = resolve;
                inflightRequest.reject = reject;
            });
            __classPrivateFieldGet(this, _SuiBatchClient_queue, "f").push(inflightRequest);
            if (!__classPrivateFieldGet(this, _SuiBatchClient_pendingAggregator, "f")) {
                // Schedule batch for next event loop + short duration
                __classPrivateFieldSet(this, _SuiBatchClient_pendingAggregator, setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    // Get the current batch and clear it, so new requests
                    // go into the next batch
                    const batches = chunk((_a = __classPrivateFieldGet(this, _SuiBatchClient_queue, "f")) === null || _a === void 0 ? void 0 : _a.slice(), MAX_OBJECTS_PER_QUERY);
                    __classPrivateFieldSet(this, _SuiBatchClient_queue, null, "f");
                    __classPrivateFieldSet(this, _SuiBatchClient_pendingAggregator, null, "f");
                    yield Promise.all(batches.map((batch) => limit$1(() => __awaiter(this, void 0, void 0, function* () {
                        const mappingRequestToResult = {};
                        const uniqueRequests = new Set();
                        batch.forEach((inflight) => {
                            if (!uniqueRequests.has(inflight.request)) {
                                uniqueRequests.add(inflight.request);
                                mappingRequestToResult[inflight.request] =
                                    uniqueRequests.size - 1;
                            }
                        });
                        const results = yield this.call('sui_multiGetObjects', [
                            [...uniqueRequests],
                            {
                                showContent: true,
                                showDisplay: true,
                                showOwner: true,
                                showType: true,
                            },
                        ]);
                        // For each result, feed it to the correct Promise, depending
                        // on whether it was a success or error
                        batch.forEach((inflight) => {
                            var _a;
                            (_a = inflight.resolve) === null || _a === void 0 ? void 0 : _a.call(inflight, results[mappingRequestToResult[inflight.request]]);
                        });
                    }))));
                }), this.scheduleTimeMs), "f");
            }
            return promise;
        });
    }
}
_SuiBatchClient_queue = new WeakMap(), _SuiBatchClient_pendingAggregator = new WeakMap();

const MODULE_UNIVERSAL_ROUTER = 'universal_router';
const MODULE_COMMISSION = 'commission';
const MODULE_COMMISSION_TYPE = 'commission_type';
var Protocol;
(function (Protocol) {
    Protocol["FLOWX_V2"] = "FLOWX";
    Protocol["FLOWX_V3"] = "FLOWX_CLMM";
    Protocol["KRIYA_DEX"] = "KRIYA";
    Protocol["TURBOS_FIANCE"] = "TURBOS";
    Protocol["CETUS"] = "CETUS";
    Protocol["AFTERMATH"] = "AFTERMATH";
    Protocol["DEEPBOOK"] = "DEEPBOOK";
    Protocol["KRIYA_V3"] = "KRIYA_CLMM";
    Protocol["DEEPBOOK_V3"] = "DEEPBOOK_V3";
    Protocol["BLUEMOVE"] = "BLUEMOVE";
    Protocol["BLUEFIN"] = "BLUEFIN";
    Protocol["FLOWX_PMM"] = "FLOWX_PMM";
    Protocol["BLUEMOVE_FUN"] = "BLUEMOVE_FUN";
    Protocol["HOP_FUN"] = "HOP_FUN";
    Protocol["SEVEN_K_FUN"] = "7K_FUN";
    Protocol["TURBOS_FUN"] = "TURBOS_FUN";
    Protocol["OBRIC"] = "OBRIC";
    Protocol["HAEDAL_PMM"] = "HAEDAL_PMM";
    Protocol["HAEDAL"] = "HAEDAL";
    Protocol["SPRING_SUI"] = "SPRING_SUI";
    Protocol["ALPHA_FI"] = "ALPHA_FI";
    Protocol["VOLO_LSD"] = "VOLO_LSD";
    Protocol["AFTERMATH_LSD"] = "AFTERMATH_LSD";
    Protocol["STEAMM"] = "STEAMM";
    Protocol["METASTABLE"] = "METASTABLE";
    Protocol["MAGMA_FINANCE"] = "MAGMA_FINANCE";
    Protocol["MOMENTUM_FINANCE"] = "MOMENTUM_FINANCE";
    Protocol["FULL_SAIL"] = "FULL_SAIL";
    Protocol["SEVENK_V1"] = "SEVENK_V1";
    Protocol["IPX_TIDE"] = "IPX_TIDE";
    Protocol["TRADEPORT"] = "TRADEPORT";
    Protocol["DIPCOIN"] = "DIPCOIN";
    Protocol["FERRA_DLMM"] = "FERRA_DLMM";
    Protocol["FERRA_CLMM"] = "FERRA_CLMM";
    Protocol["MAGMA_ALMM"] = "MAGMA_ALMM";
    Protocol["SUI_REWARDS"] = "SUI_REWARDS";
    Protocol["CETUS_DLMM"] = "CETUS_DLMM";
    Protocol["BOLT"] = "BOLT";
})(Protocol || (Protocol = {}));
var CommissionType;
(function (CommissionType) {
    CommissionType[CommissionType["PERCENTAGE"] = 0] = "PERCENTAGE";
    CommissionType[CommissionType["FLAT"] = 1] = "FLAT";
})(CommissionType || (CommissionType = {}));
const BPS$2 = new BN$1(1000000);
const CONFIGS$5 = {
    mainnet: {
        packageId: '0xc263060d3cbb4155057f0010f92f63ca56d5121c298d01f7a33607342ec299b0',
        packageIdOld: '0xc263060d3cbb4155057f0010f92f63ca56d5121c298d01f7a33607342ec299b0',
        treasuryObjectId: '0x25db8128dc9ccbe5fcd15e5700fea555c6b111a8c8a1f20c426b696caac2bea4',
        tradeIdTrackerObjectId: '0x9ab469842f85fd2a1bac9ba695d867adb1caa7d5705809737922b5cee552eb6f',
        partnerRegistryObjectId: '0x29e6c1c2176485dc045a2e39eb8844b4ca1cf8452d964447c11202f84a76cb1a',
        versionedObjectId: '0xada98dd9e028db64e206dd81fdecb3dbc8b4c16be08d9f175550032bfdcf56f3',
        partnerCommissionCollectEvent: '0xc263060d3cbb4155057f0010f92f63ca56d5121c298d01f7a33607342ec299b0::partner_manager::Collect',
        quoter: {
            singleQuoteURI: 'https://api.flowx.finance/flowx-ag-routing/api/v1/quote',
            batchQuoteURI: 'https://api.flowx.finance/flowx-ag-routing/api/v1/batch-quotes',
            multipleQuotesURI: 'https://api.flowx.finance/flowx-ag-routing/api/v1/multi-quotes',
            requestTimeout: 30000,
        },
        graphql: {
            baseURI: 'https://api.flowx.finance/flowx-be/graphql',
        },
        pyth: {
            priceServiceEndpoint: 'https://hermes.pyth.network/v2',
            stateObjectId: '0x1f9310238ee9298fb703c3419030b35b22bb1cc37113e3bb5007c99aec79e5b8',
        },
        wormhole: {
            stateObjectId: '0xaeab97f96cf9877fee2883315d459552b2b921edc16d7ceac6eab944dd88919c',
        },
    },
    testnet: {
        packageIdOld: '0xf055dc4f52856906c31aade424cbdd2a9aae827b4ea1fe7b9eb904d70e34ae60',
        packageId: '0xf055dc4f52856906c31aade424cbdd2a9aae827b4ea1fe7b9eb904d70e34ae60',
        treasuryObjectId: '0xfe423684ac5de04438a0f11e84e085ada4cf961c861ac65720b30a9c2e5c1c55',
        tradeIdTrackerObjectId: '0xa42c1eee22693aebe12c226519a958293c4a9b679e0dae84a8c37ed9709688e5',
        partnerRegistryObjectId: '0x8e7a2955e3898c296bf7b95dfef0b4d0c693e1018a6ef68ea9dc0ea1f2c6087f',
        partnerCommissionCollectEvent: '0xf055dc4f52856906c31aade424cbdd2a9aae827b4ea1fe7b9eb904d70e34ae60::partner_manager::Collect',
        versionedObjectId: '0x458a5128e93435f50e09d035ef7437f04dd8b931ca5ec7818d1b6b5c36a1bf79',
        quoter: {
            singleQuoteURI: 'https://flowx-dev.flowx.finance/flowx-ag-routing/api/v1/quote',
            batchQuoteURI: 'https://flowx-dev.flowx.finance/flowx-ag-routing/api/v1/batch-quotes',
            multipleQuotesURI: 'http://localhost:8080/flowx-be/api/v1/multi-quotes',
            requestTimeout: 30000,
        },
        graphql: {
            baseURI: 'https://flowx-dev.flowx.finance/flowx-be/graphql',
        },
        pyth: {
            priceServiceEndpoint: '',
            stateObjectId: '',
        },
        wormhole: {
            stateObjectId: '',
        },
    },
};

class METHCapacityCreator {
    constructor() {
        this.createDepositCap = (coinIn, config) => (tx) => {
            var _a, _b;
            const { mETHVault, oracles, pythMap } = config;
            const [coinInPriceId, metaCoinPriceId] = [
                pythMap[(_a = oracles === null || oracles === void 0 ? void 0 : oracles[0]) === null || _a === void 0 ? void 0 : _a.priceId],
                pythMap[(_b = oracles === null || oracles === void 0 ? void 0 : oracles[1]) === null || _b === void 0 ? void 0 : _b.priceId],
            ];
            invariant(coinInPriceId && metaCoinPriceId, 'priceIds not found');
            return tx.moveCall({
                target: `${mETHVault.metaVaultIntegrationPackageId}::pyth::create_deposit_cap`,
                typeArguments: [mETHVault.metaCoinType, coinIn],
                arguments: [
                    tx.object(mETHVault.metaVaultIntegrationObjectId),
                    tx.object(mETHVault.vaultId),
                    tx.object(coinInPriceId),
                    tx.object(metaCoinPriceId),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
        this.createWithdrawCap = (coinOut, config) => (tx) => {
            var _a, _b;
            const { mETHVault, oracles, pythMap } = config;
            const [metaCoinPriceId, coinOutPriceId] = [
                pythMap[(_a = oracles === null || oracles === void 0 ? void 0 : oracles[0]) === null || _a === void 0 ? void 0 : _a.priceId],
                pythMap[(_b = oracles === null || oracles === void 0 ? void 0 : oracles[1]) === null || _b === void 0 ? void 0 : _b.priceId],
            ];
            invariant(coinOutPriceId && metaCoinPriceId, 'priceIds not found');
            return tx.moveCall({
                target: `${mETHVault.metaVaultIntegrationPackageId}::pyth::create_withdraw_cap`,
                typeArguments: [mETHVault.metaCoinType, coinOut],
                arguments: [
                    tx.object(mETHVault.metaVaultIntegrationObjectId),
                    tx.object(mETHVault.vaultId),
                    tx.object(coinOutPriceId),
                    tx.object(metaCoinPriceId),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
    }
}

class MUSDCapacityCreator {
    constructor() {
        this.createDepositCap = (coinIn, config) => (tx) => {
            var _a;
            const { mUSDVault, oracles, pythMap } = config;
            const priceId = pythMap[(_a = oracles === null || oracles === void 0 ? void 0 : oracles[0]) === null || _a === void 0 ? void 0 : _a.priceId];
            invariant(priceId, 'priceId not found');
            return tx.moveCall({
                target: `${mUSDVault.metaVaultIntegrationPackageId}::pyth::create_deposit_cap`,
                typeArguments: [mUSDVault.metaCoinType, coinIn],
                arguments: [
                    tx.object(mUSDVault.metaVaultIntegrationObjectId),
                    tx.object(mUSDVault.vaultId),
                    tx.object(priceId),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
        this.createWithdrawCap = (coinOut, config) => (tx) => {
            var _a;
            const { mUSDVault, oracles, pythMap } = config;
            const priceId = pythMap[(_a = oracles === null || oracles === void 0 ? void 0 : oracles[0]) === null || _a === void 0 ? void 0 : _a.priceId];
            invariant(priceId, 'priceId not found');
            return tx.moveCall({
                target: `${mUSDVault.metaVaultIntegrationPackageId}::pyth::create_withdraw_cap`,
                typeArguments: [mUSDVault.metaCoinType, coinOut],
                arguments: [
                    tx.object(mUSDVault.metaVaultIntegrationObjectId),
                    tx.object(mUSDVault.vaultId),
                    tx.object(priceId),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
    }
}

const UNIVERSAL_META_VAULT_INTEGRATION_PACKAGE_ID = '0xfd12517a9fc87c6a1f2357ad13b3421fb27a8bd7ca07d5fd5934ac35733baa47';
class SuperSUICapacityCreator {
    constructor() {
        this.createDepositCap = (coinIn, config) => (tx) => {
            const { superSUIVault } = config;
            const metaVaultIntegrationPackageId = superSUIVault.mappingMetaVaultIntegrationPackageId[coinIn] ||
                superSUIVault.defaultMetaVaultIntegrationPackageId;
            const metaVaultIntegrationObjectId = superSUIVault.mappingMetaVaultIntegrationObjectId[coinIn] ||
                superSUIVault.defaultMetaVaultIntegrationObjectId;
            invariant(metaVaultIntegrationPackageId && metaVaultIntegrationObjectId, 'invalid meta vault');
            return tx.moveCall({
                target: `${metaVaultIntegrationPackageId}::exchange_rate::create_deposit_cap`,
                typeArguments: metaVaultIntegrationPackageId ===
                    UNIVERSAL_META_VAULT_INTEGRATION_PACKAGE_ID
                    ? [superSUIVault.metaCoinType, coinIn]
                    : [superSUIVault.metaCoinType],
                arguments: [
                    tx.object(metaVaultIntegrationObjectId),
                    tx.object(superSUIVault.vaultId),
                    tx.object(superSUIVault.exchangeRateRegistryObjectId),
                ],
            });
        };
        this.createWithdrawCap = (coinOut, config) => (tx) => {
            const { superSUIVault } = config;
            const metaVaultIntegrationPackageId = superSUIVault.mappingMetaVaultIntegrationPackageId[coinOut] ||
                superSUIVault.defaultMetaVaultIntegrationPackageId;
            const metaVaultIntegrationObjectId = superSUIVault.mappingMetaVaultIntegrationObjectId[coinOut] ||
                superSUIVault.defaultMetaVaultIntegrationObjectId;
            invariant(metaVaultIntegrationPackageId && metaVaultIntegrationObjectId, 'invalid meta vault');
            return tx.moveCall({
                target: `${metaVaultIntegrationPackageId}::exchange_rate::create_withdraw_cap`,
                typeArguments: metaVaultIntegrationPackageId ===
                    UNIVERSAL_META_VAULT_INTEGRATION_PACKAGE_ID
                    ? [superSUIVault.metaCoinType, coinOut]
                    : [superSUIVault.metaCoinType],
                arguments: [
                    tx.object(metaVaultIntegrationObjectId),
                    tx.object(superSUIVault.vaultId),
                    tx.object(superSUIVault.exchangeRateRegistryObjectId),
                ],
            });
        };
    }
}

var JsonBigInt = JSONbig({
    useNativeBigInt: true,
});

class SuiPriceServiceConnection {
    constructor(endpoint, config) {
        var _a;
        this._endpoint = endpoint;
        this._timeout = (_a = config === null || config === void 0 ? void 0 : config.timeout) !== null && _a !== void 0 ? _a : 30000;
    }
    /**
     * Gets price update data (either batch price attestation VAAs or accumulator messages, depending on the chosen endpoint), which then
     * can be submitted to the Pyth contract to update the prices. This will throw an axios error if there is a network problem or
     * the price service returns a non-ok response (e.g: Invalid price ids)
     *
     * @param priceIds Array of hex-encoded price ids.
     * @returns Array of buffers containing the price update data.
     */
    getPriceFeedsUpdateData(priceIds) {
        return __awaiter(this, void 0, void 0, function* () {
            // Fetch the latest price feed update VAAs from the price service
            const queryParams = priceIds
                .map((priceId) => `ids[]=${encodeURIComponent(priceId)}`)
                .join('&');
            const response = yield fetch(`${this._endpoint}/updates/price/latest?` + queryParams, {
                signal: AbortSignal.timeout(this._timeout),
                keepalive: true,
            });
            const rawResponse = yield response.text();
            invariant(response.ok, rawResponse);
            const parsedResponse = JsonBigInt.parse(rawResponse);
            const { data: latestVaas, encoding } = parsedResponse.binary;
            return latestVaas.map((latestVaa) => Buffer.from(latestVaa, encoding));
        });
    }
}

class SuiPythClient {
    constructor(provider, pythStateId, wormholeStateId, priceFeedObjectIdCache) {
        this.provider = provider;
        this.pythStateId = pythStateId;
        this.wormholeStateId = wormholeStateId;
        this.priceFeedObjectIdCache = new Map();
        this.pythPackageId = undefined;
        this.wormholePackageId = undefined;
        if (priceFeedObjectIdCache) {
            Object.keys(priceFeedObjectIdCache).map((feedId) => {
                const normalizedFeedId = feedId.replace('0x', '');
                this.priceFeedObjectIdCache.set(normalizedFeedId, priceFeedObjectIdCache[feedId]);
            });
        }
    }
    getBaseUpdateFee() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.baseUpdateFee === undefined) {
                const result = yield this.provider.getObject({
                    id: this.pythStateId,
                    options: { showContent: true },
                });
                if (!result.data ||
                    !result.data.content ||
                    result.data.content.dataType !== 'moveObject')
                    throw new Error('Unable to fetch pyth state object');
                this.baseUpdateFee = result.data.content.fields['base_update_fee'];
            }
            return this.baseUpdateFee;
        });
    }
    /**
     * getPackageId returns the latest package id that the object belongs to. Use this to
     * fetch the latest package id for a given object id and handle package upgrades automatically.
     * @param objectId
     * @returns package id
     */
    getPackageId(objectId) {
        return __awaiter(this, void 0, void 0, function* () {
            const state = yield this.provider
                .getObject({
                id: objectId,
                options: {
                    showContent: true,
                },
            })
                .then((result) => {
                var _a, _b, _c;
                if (((_b = (_a = result.data) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.dataType) == 'moveObject') {
                    return result.data.content.fields;
                }
                console.log((_c = result.data) === null || _c === void 0 ? void 0 : _c.content);
                throw new Error(`Cannot fetch package id for object ${objectId}`);
            });
            if ('upgrade_cap' in state) {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                return state.upgrade_cap.fields.package;
            }
            throw new Error('upgrade_cap not found');
        });
    }
    /**
     * Adds the commands for calling wormhole and verifying the vaas and returns the verified vaas.
     * @param vaas array of vaas to verify
     * @param tx transaction block to add commands to
     */
    verifyVaas(wormholePackageId, vaas, tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const verifiedVaas = [];
            for (const vaa of vaas) {
                const [verifiedVaa] = tx.moveCall({
                    target: `${wormholePackageId}::vaa::parse_and_verify`,
                    arguments: [
                        tx.object(this.wormholeStateId),
                        tx.pure(bcs.vector(bcs.u8()).serialize(vaa)),
                        tx.object(SUI_CLOCK_OBJECT_ID),
                    ],
                });
                verifiedVaas.push(verifiedVaa);
            }
            return verifiedVaas;
        });
    }
    /**
     * Adds the necessary commands for updating the pyth price feeds to the transaction block.
     * @param tx transaction block to add commands to
     * @param updates array of price feed updates received from the price service
     * @param feedIds array of feed ids to update (in hex format)
     */
    updatePriceFeeds(tx, updates, feedIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const [packageId, baseUpdateFee, wormholePackageId] = yield Promise.all([
                this.getPythPackageId(),
                this.getBaseUpdateFee(),
                this.getWormholePackageId(),
            ]);
            let priceUpdatesHotPotato;
            if (updates.length > 1) {
                throw new Error('SDK does not support sending multiple accumulator messages in a single transaction');
            }
            const vaa = this.extractVaaBytesFromAccumulatorMessage(updates[0]);
            const verifiedVaas = yield this.verifyVaas(wormholePackageId, [vaa], tx);
            [priceUpdatesHotPotato] = tx.moveCall({
                target: `${packageId}::pyth::create_authenticated_price_infos_using_accumulator`,
                arguments: [
                    tx.object(this.pythStateId),
                    tx.pure(bcs.vector(bcs.u8()).serialize(updates[0])),
                    verifiedVaas[0],
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
            const priceInfoObjects = [];
            const coins = tx.splitCoins(tx.gas, feedIds.map(() => tx.pure.u64(baseUpdateFee)));
            for (const [idx, feedId] of feedIds.entries()) {
                const priceInfoObjectId = yield this.getPriceFeedObjectId(feedId);
                if (!priceInfoObjectId) {
                    throw new Error(`Price feed ${feedId} not found, please create it first`);
                }
                priceInfoObjects.push(priceInfoObjectId);
                [priceUpdatesHotPotato] = tx.moveCall({
                    target: `${packageId}::pyth::update_single_price_feed`,
                    arguments: [
                        tx.object(this.pythStateId),
                        priceUpdatesHotPotato,
                        tx.object(priceInfoObjectId),
                        coins[idx],
                        tx.object(SUI_CLOCK_OBJECT_ID),
                    ],
                });
            }
            tx.moveCall({
                target: `${packageId}::hot_potato_vector::destroy`,
                arguments: [priceUpdatesHotPotato],
                typeArguments: [`${packageId}::price_info::PriceInfo`],
            });
            return priceInfoObjects;
        });
    }
    /**
     * Get the packageId for the wormhole package if not already cached
     */
    getWormholePackageId() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.wormholePackageId) {
                this.wormholePackageId = yield this.getPackageId(this.wormholeStateId);
            }
            return this.wormholePackageId;
        });
    }
    /**
     * Get the packageId for the pyth package if not already cached
     */
    getPythPackageId() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.pythPackageId) {
                this.pythPackageId = yield this.getPackageId(this.pythStateId);
            }
            return this.pythPackageId;
        });
    }
    /**
     * Get the priceFeedObjectId for a given feedId if not already cached
     * @param feedId
     */
    getPriceFeedObjectId(feedId) {
        return __awaiter(this, void 0, void 0, function* () {
            const normalizedFeedId = feedId.replace('0x', '');
            if (!this.priceFeedObjectIdCache.has(normalizedFeedId)) {
                const { id: tableId, fieldType } = yield this.getPriceTableInfo();
                const result = yield this.provider.getDynamicFieldObject({
                    parentId: tableId,
                    name: {
                        type: `${fieldType}::price_identifier::PriceIdentifier`,
                        value: {
                            bytes: Array.from(Buffer.from(normalizedFeedId, 'hex')),
                        },
                    },
                });
                if (!result.data || !result.data.content) {
                    return undefined;
                }
                if (result.data.content.dataType !== 'moveObject') {
                    throw new Error('Price feed type mismatch');
                }
                this.priceFeedObjectIdCache.set(normalizedFeedId, 
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                result.data.content.fields.value);
            }
            return this.priceFeedObjectIdCache.get(normalizedFeedId);
        });
    }
    /**
     * Fetches the price table object id for the current state id if not cached
     * @returns price table object id
     */
    getPriceTableInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.priceTableInfo === undefined) {
                const result = yield this.provider.getDynamicFieldObject({
                    parentId: this.pythStateId,
                    name: {
                        type: 'vector<u8>',
                        value: 'price_info',
                    },
                });
                if (!result.data || !result.data.type) {
                    throw new Error('Price Table not found, contract may not be initialized');
                }
                let type = result.data.type.replace('0x2::table::Table<', '');
                type = type.replace('::price_identifier::PriceIdentifier, 0x2::object::ID>', '');
                this.priceTableInfo = { id: result.data.objectId, fieldType: type };
            }
            return this.priceTableInfo;
        });
    }
    /**
     * Obtains the vaa bytes embedded in an accumulator message.
     * @param accumulatorMessage - the accumulator price update message
     * @returns vaa bytes as a uint8 array
     */
    extractVaaBytesFromAccumulatorMessage(accumulatorMessage) {
        // the first 6 bytes in the accumulator message encode the header, major, and minor bytes
        // we ignore them, since we are only interested in the VAA bytes
        const trailingPayloadSize = accumulatorMessage.readUint8(6);
        const vaaSizeOffset = 7 + // header bytes (header(4) + major(1) + minor(1) + trailing payload size(1))
            trailingPayloadSize + // trailing payload (variable number of bytes)
            1; // proof_type (1 byte)
        const vaaSize = accumulatorMessage.readUint16BE(vaaSizeOffset);
        const vaaOffset = vaaSizeOffset + 2;
        return accumulatorMessage.subarray(vaaOffset, vaaOffset + vaaSize);
    }
}

var SteammQuoterType;
(function (SteammQuoterType) {
    SteammQuoterType["CONSTANT_PRODUCT"] = "constant_product";
    SteammQuoterType["ORACLE"] = "oracle";
    SteammQuoterType["ORACLE_V2"] = "oracle_v2";
})(SteammQuoterType || (SteammQuoterType = {}));
var OracleType;
(function (OracleType) {
    OracleType["PYTH"] = "pyth";
    OracleType["SWITCHBOARD"] = "switchboard";
})(OracleType || (OracleType = {}));

class PythHelper {
    constructor(options) {
        this._pythPriceServiceConnection = new SuiPriceServiceConnection(options.pythConfig.priceServiceEndpoint, { timeout: 30000 });
        this._pythClient = new SuiPythClient(options.client, options.pythConfig.pythStateObjectId, options.pythConfig.wormholeStateObjectId);
    }
    static getInstance(options) {
        const key = objectHash(options);
        let instance = PythHelper._instances[key];
        if (!instance) {
            instance = new PythHelper(options);
            PythHelper._instances[key] = instance;
        }
        return instance;
    }
    updatePythPriceFeedsIfNecessary(routes, tx) {
        return __awaiter(this, void 0, void 0, function* () {
            const oracles = routes.reduce((acc, route) => {
                return acc.concat(route.paths.map((path) => path.oracles || []).flat());
            }, new Array());
            const pythOracles = oracles.filter((oracle) => oracle.oracleType === OracleType.PYTH);
            if (pythOracles.length === 0) {
                return {};
            }
            const uniquePriceIds = uniq(pythOracles.map((oracle) => oracle.priceId));
            const priceFeedsUpdateData = yield this._pythPriceServiceConnection.getPriceFeedsUpdateData(uniquePriceIds);
            const priceFeedObjectIds = yield this._pythClient.updatePriceFeeds(tx, priceFeedsUpdateData, uniquePriceIds);
            const priceFeedObjectIdMap = {};
            uniquePriceIds.forEach((priceId, idx) => {
                priceFeedObjectIdMap[priceId] = priceFeedObjectIds[idx];
            });
            return priceFeedObjectIdMap;
        });
    }
}
PythHelper._instances = {};

class Trade {
    constructor(options) {
        this._swap = (coinIn, pythMap) => (tx) => {
            //Initialize commission object if necessary
            let commissionOpt;
            if (!!this.commission &&
                (this.commission.coin.equals(this.input) ||
                    this.commission.coin.equals(this.output))) {
                const commissionType = this.commission.type === CommissionType.PERCENTAGE
                    ? tx.moveCall({
                        target: `${CONFIGS$5[this.network].packageId}::${MODULE_COMMISSION_TYPE}::percentage`,
                    })
                    : tx.moveCall({
                        target: `${CONFIGS$5[this.network].packageId}::${MODULE_COMMISSION_TYPE}::flat`,
                    });
                const commissionObject = tx.moveCall({
                    target: `${CONFIGS$5[this.network].packageId}::${MODULE_COMMISSION}::new`,
                    arguments: [
                        tx.pure.address(this.commission.partner),
                        commissionType,
                        tx.pure.u64(this.commission.value.toString()),
                        tx.pure.bool(this.commission.coin.equals(this.input)),
                        tx.pure.bool(this.commission.directTransfer),
                    ],
                });
                commissionOpt = tx.moveCall({
                    target: `${STD_PACKAGE_ID}::${MODULE_OPTION}::some`,
                    typeArguments: [
                        `${CONFIGS$5[this.network].packageId}::${MODULE_COMMISSION}::Commission`,
                    ],
                    arguments: [commissionObject],
                });
            }
            else {
                commissionOpt = tx.moveCall({
                    target: `${STD_PACKAGE_ID}::${MODULE_OPTION}::none`,
                    typeArguments: [
                        `${CONFIGS$5[this.network].packageId}::${MODULE_COMMISSION}::Commission`,
                    ],
                });
            }
            // Perform build trade object
            const tradeObject = tx.moveCall({
                target: `${CONFIGS$5[this.network].packageId}::${MODULE_UNIVERSAL_ROUTER}::build`,
                typeArguments: [this.input.coinType, this.output.coinType],
                arguments: [
                    tx.object(CONFIGS$5[this.network].treasuryObjectId),
                    tx.object(CONFIGS$5[this.network].tradeIdTrackerObjectId),
                    tx.object(CONFIGS$5[this.network].partnerRegistryObjectId),
                    coinIn,
                    tx.pure.u64(this.amountOut.toString()),
                    tx.pure.u64(this.slippage),
                    tx.pure.u64(this.deadline),
                    tx.pure(bcs
                        .vector(bcs.U64)
                        .serialize(this.routes.map((route) => route.amountIn.toString()))),
                    commissionOpt,
                    tx.object(CONFIGS$5[this.network].versionedObjectId),
                ],
            });
            //Perform swap for each route
            for (const route of this.routes) {
                route.swap(tradeObject, new Percent(this.slippage, BPS$2), pythMap)(tx);
            }
            //Perform settle move call and transfer coin out to sender
            const coinOut = tx.moveCall({
                target: `${CONFIGS$5[this.network].packageId}::${MODULE_UNIVERSAL_ROUTER}::settle`,
                typeArguments: [this.input.coinType, this.output.coinType],
                arguments: [
                    tx.object(CONFIGS$5[this.network].treasuryObjectId),
                    tx.object(CONFIGS$5[this.network].partnerRegistryObjectId),
                    tradeObject,
                    tx.object(CONFIGS$5[this.network].versionedObjectId),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
            return coinOut;
        };
        this.network = options.network;
        this.sender = options.sender;
        this.recipient = options.recipient;
        this.input = options.routes[0].input;
        this.output = options.routes[0].output;
        this.amountIn = options.amountIn;
        this.amountOut = options.amountOut;
        this.slippage = options.slippage;
        this.deadline = options.deadline;
        this.routes = options.routes;
        this.commission = options.commission;
    }
    buildTransaction(params) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            invariant(this.sender, 'SENDER');
            const tx = new Transaction();
            // Take coin in from sender
            const coinIn = yield this.input.take({
                owner: this.sender,
                amount: this.amountIn,
                tx,
                client: params.client,
                isDevInspect: params.isDevInspect,
            });
            const pythHelper = PythHelper.getInstance({
                client: params.client,
                pythConfig: {
                    priceServiceEndpoint: CONFIGS$5[this.network].pyth.priceServiceEndpoint,
                    pythStateObjectId: CONFIGS$5[this.network].pyth.stateObjectId,
                    wormholeStateObjectId: CONFIGS$5[this.network].wormhole.stateObjectId,
                },
            });
            const pythMap = yield pythHelper.updatePythPriceFeedsIfNecessary(this.routes, tx);
            const coinOut = this._swap(coinIn, pythMap)(tx);
            tx.transferObjects([coinOut], (_a = this.recipient) !== null && _a !== void 0 ? _a : this.sender);
            return tx;
        });
    }
    swap(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { tx } = params;
            let coinIn = params.coinIn;
            if (!coinIn) {
                invariant(this.sender, 'SENDER');
                coinIn = coinWithBalance({
                    balance: BigInt(this.amountIn.toString()),
                    type: this.input.coinType,
                    useGasCoin: this.input.coinType === normalizeStructTag$1(SUI_TYPE_ARG),
                })(tx);
            }
            const pythHelper = PythHelper.getInstance({
                client: params.client,
                pythConfig: {
                    priceServiceEndpoint: CONFIGS$5[this.network].pyth.priceServiceEndpoint,
                    pythStateObjectId: CONFIGS$5[this.network].pyth.stateObjectId,
                    wormholeStateObjectId: CONFIGS$5[this.network].wormhole.stateObjectId,
                },
            });
            const pythMap = yield pythHelper.updatePythPriceFeedsIfNecessary(this.routes, tx);
            const coinOut = this._swap(coinIn, pythMap)(tx);
            if (this.recipient) {
                tx.transferObjects([coinOut], this.recipient);
            }
            else {
                return coinOut;
            }
        });
    }
}

class TradeBuilder {
    static fromRoutes(routes) {
        var _a;
        return new TradeBuilder((_a = routes[0]) === null || _a === void 0 ? void 0 : _a.network, routes);
    }
    constructor(network, routes) {
        invariant(routes.length > 0 &&
            routes
                .slice(1)
                .every((route) => route.input.equals(routes[0].input) &&
                route.output.equals(routes[0].output)), 'ROUTES');
        this._network = network;
        this._routes = routes;
        this._amountIn = sumBn$1(routes.map((route) => new BN$1(route.amountIn)));
        this._amountOut = sumBn$1(routes.map((route) => new BN$1(route.amountOut)));
        this._slippage = 0;
        this._deadline = Number.MAX_SAFE_INTEGER;
    }
    sender(sender) {
        this._sender = sender;
        return this;
    }
    recipient(recipient) {
        this._recipient = recipient;
        return this;
    }
    /**
     * @deprecated remove in feature
     * We don't need pass amount in anymore, it always auto calculate
     * */
    amountIn(amountIn) {
        this._amountIn = amountIn;
        return this;
    }
    /**
     * @deprecated remove in feature
     * We don't need pass amount out anymore, it always auto calculate
     * */
    amountOut(amountOut) {
        this._amountOut = amountOut;
        return this;
    }
    deadline(deadline) {
        this._deadline = deadline;
        return this;
    }
    slippage(slippage) {
        this._slippage = slippage;
        return this;
    }
    commission(commission) {
        this._commission = commission;
        return this;
    }
    build() {
        var _a;
        invariant(!this._commission ||
            this._routes[0].input.equals(this._commission.coin) ||
            this._routes[0].output.equals(this._commission.coin), 'INVALID_COMMISSION');
        invariant(new BN$1(this._amountIn).gt(ZERO), 'AMOUNT_IN');
        invariant(new BN$1(this._amountOut).gt(ZERO), 'AMOUNT_OUT');
        invariant(new BN$1(this._slippage).lte(BPS$2), 'SLIPPAGE');
        invariant((!this._sender || isValidSuiAddress(this._sender)) &&
            (!this._recipient || isValidSuiAddress(this._recipient)), 'ADDRESSEES');
        const amountIn = new BN$1(this._amountIn).add(((_a = this._commission) === null || _a === void 0 ? void 0 : _a.coin.equals(this._routes[0].input))
            ? this._commission.computeCommissionAmount(this._amountIn, {
                coinIn: this._routes[0].input,
                coinOut: this._routes[0].output,
            })
            : ZERO);
        return new Trade({
            network: this._network,
            sender: this._sender,
            amountIn: amountIn,
            amountOut: this._amountOut,
            slippage: this._slippage,
            deadline: this._deadline,
            routes: this._routes,
            commission: this._commission,
        });
    }
}

class MultipleTrades {
    constructor(trades) {
        this.trades = trades;
    }
    buildTransaction(sender, params) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = new Transaction();
            tx.setSender(sender);
            for (const trade of this.trades) {
                const coinOut = yield trade.swap({ client: params.client, tx });
                tx.transferObjects([coinOut], sender);
            }
            return tx;
        });
    }
}

class MultiTradesBuilder {
    static fromRoutesGroups(routeGroups) {
        var _a;
        return new MultiTradesBuilder((_a = routeGroups[0][0]) === null || _a === void 0 ? void 0 : _a.network, routeGroups);
    }
    constructor(network, routeGroups) {
        this._deadline = Number.MAX_SAFE_INTEGER;
        this._commissions = [];
        this._routeGroups = [];
        invariant(routeGroups.length > 0, 'ROUTES_REQUIRED');
        this._network = network;
        this._routeGroups = routeGroups;
        for (const routes of routeGroups) {
            invariant(routes.length > 0 &&
                routes
                    .slice(1)
                    .every((route) => route.input.equals(routes[0].input) &&
                    route.output.equals(routes[0].output)), 'INVALID_ROUTE_GROUP');
        }
    }
    sender(sender) {
        this._sender = sender;
        return this;
    }
    recipient(recipient) {
        this._recipient = recipient;
        return this;
    }
    slippage(slippage) {
        this._slippage = slippage;
        return this;
    }
    deadline(deadline) {
        this._deadline = deadline;
        return this;
    }
    commissions(commissions) {
        this._commissions = commissions;
        return this;
    }
    build() {
        invariant((!this._sender || isValidSuiAddress(this._sender)) &&
            (!this._recipient || isValidSuiAddress(this._recipient)), 'ADDRESSEES');
        const trades = [];
        this._routeGroups.map((routes, index) => {
            var _a;
            const amountIn = sumBn$1(routes.map((r) => new BN$1(r.amountIn)));
            const amountOut = sumBn$1(routes.map((r) => new BN$1(r.amountOut)));
            const commission = (_a = this._commissions) === null || _a === void 0 ? void 0 : _a[index];
            invariant(new BN$1(amountIn).gt(ZERO), 'AMOUNT_IN');
            invariant(new BN$1(amountOut).gt(ZERO), 'AMOUNT_OUT');
            invariant(new BN$1(this._slippage).lte(BPS$2), 'SLIPPAGE');
            if (commission) {
                invariant(routes[0].input.equals(commission.coin) ||
                    routes[0].output.equals(commission.coin), 'INVALID_COMMISSION');
            }
            const totalAmountIn = new BN$1(amountIn).add((commission === null || commission === void 0 ? void 0 : commission.coin.equals(routes[0].input))
                ? commission.computeCommissionAmount(amountIn, {
                    coinIn: routes[0].input,
                    coinOut: routes[0].output,
                })
                : ZERO);
            trades.push(new Trade({
                network: this._network,
                sender: this._sender,
                recipient: this._recipient,
                amountIn: totalAmountIn,
                amountOut,
                slippage: this._slippage,
                deadline: this._deadline,
                routes,
                commission,
            }));
        });
        return new MultipleTrades(trades);
    }
}

class Commission {
    constructor(partner, coin, type, value, directTransfer = false) {
        invariant(isValidSuiAddress(partner), 'PARTNER');
        invariant(type === CommissionType.FLAT ||
            (type === CommissionType.PERCENTAGE && value < BPS$2), 'COMMISSION');
        this.partner = partner;
        this.coin = coin;
        this.type = type;
        this.value = value;
        this.directTransfer = directTransfer;
    }
    computeCommissionAmount(amountInOrAmountOut, trade) {
        switch (this.type) {
            case CommissionType.FLAT:
                return new BN$1(this.value);
            case CommissionType.PERCENTAGE:
                return this.coin.equals(trade.coinIn)
                    ? new BN$1(amountInOrAmountOut)
                        .mul(new BN$1(this.value))
                        .div(BPS$2.sub(new BN$1(this.value)))
                    : new BN$1(amountInOrAmountOut).mul(new BN$1(this.value)).div(BPS$2);
            default:
                return ZERO;
        }
    }
}

class Route {
    constructor(network, paths) {
        this.swap = (tradeObject, slippage, pythMap) => (tx) => {
            const firstPath = this.paths[0];
            const routeObject = tx.moveCall({
                target: `${CONFIGS$5[this.network].packageId}::${MODULE_UNIVERSAL_ROUTER}::start_routing`,
                typeArguments: [
                    this.input.coinType,
                    this.output.coinType,
                    firstPath.output.coinType,
                ],
                arguments: [
                    tradeObject,
                    tx.object(CONFIGS$5[this.network].versionedObjectId),
                ],
            });
            for (const [index, path] of this.paths.entries()) {
                path.swap(routeObject, slippage, pythMap)(tx);
                //next to the next path if necessary
                const nextPath = this.paths[index + 1];
                if (nextPath) {
                    tx.moveCall({
                        target: `${CONFIGS$5[this.network].packageId}::${MODULE_UNIVERSAL_ROUTER}::next`,
                        typeArguments: [
                            path.input.coinType,
                            path.output.coinType,
                            nextPath.output.coinType,
                        ],
                        arguments: [
                            routeObject,
                            tx.object(CONFIGS$5[this.network].versionedObjectId),
                        ],
                    });
                }
            }
            const lastPath = this.paths[this.paths.length - 1];
            return tx.moveCall({
                target: `${CONFIGS$5[this.network].packageId}::${MODULE_UNIVERSAL_ROUTER}::finish_routing`,
                typeArguments: [
                    this.input.coinType,
                    this.output.coinType,
                    lastPath.input.coinType,
                ],
                arguments: [
                    tradeObject,
                    routeObject,
                    tx.object(CONFIGS$5[this.network].versionedObjectId),
                ],
            });
        };
        invariant(paths.length > 0 &&
            !paths[0].input.equals(paths[paths.length - 1].output), 'PATHS');
        this.network = network;
        this.paths = paths;
        this.input = paths[0].input;
        this.output = paths[paths.length - 1].output;
        this.amountIn = paths[0].amountIn;
        this.amountOut = paths[paths.length - 1].amountOut;
    }
}

class Swap {
    constructor(options) {
        invariant(!options.input.equals(options.output), 'COINS');
        this.network = options.network;
        this.pool = options.pool;
        this.input = options.input;
        this.output = options.output;
        this.amountIn = options.amountIn;
        this.amountOut = options.amountOut;
        this.oracles = options.oracles;
        this.protocolConfig = options.protocolConfig;
    }
}

/* eslint-disable no-bitwise */
const BIT_PRECISION = 14;
const LOG_B_2_X32 = '59543866431248';
const LOG_B_P_ERR_MARGIN_LOWER_X64 = '184467440737095516';
const LOG_B_P_ERR_MARGIN_UPPER_X64 = '15793534762490258745';
function signedShiftLeft(n0, shiftBy, bitWidth) {
    const twosN0 = n0.toTwos(bitWidth).shln(shiftBy);
    twosN0.imaskn(bitWidth + 1);
    return twosN0.fromTwos(bitWidth);
}
function signedShiftRight(n0, shiftBy, bitWidth) {
    const twoN0 = n0.toTwos(bitWidth).shrn(shiftBy);
    twoN0.imaskn(bitWidth - shiftBy + 1);
    return twoN0.fromTwos(bitWidth - shiftBy);
}
function tickIndexToSqrtPricePositive(tick) {
    let ratio;
    if ((tick & 1) !== 0) {
        ratio = new BN('79232123823359799118286999567');
    }
    else {
        ratio = new BN('79228162514264337593543950336');
    }
    if ((tick & 2) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('79236085330515764027303304731')), 96, 256);
    }
    if ((tick & 4) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('79244008939048815603706035061')), 96, 256);
    }
    if ((tick & 8) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('79259858533276714757314932305')), 96, 256);
    }
    if ((tick & 16) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('79291567232598584799939703904')), 96, 256);
    }
    if ((tick & 32) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('79355022692464371645785046466')), 96, 256);
    }
    if ((tick & 64) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('79482085999252804386437311141')), 96, 256);
    }
    if ((tick & 128) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('79736823300114093921829183326')), 96, 256);
    }
    if ((tick & 256) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('80248749790819932309965073892')), 96, 256);
    }
    if ((tick & 512) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('81282483887344747381513967011')), 96, 256);
    }
    if ((tick & 1024) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('83390072131320151908154831281')), 96, 256);
    }
    if ((tick & 2048) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('87770609709833776024991924138')), 96, 256);
    }
    if ((tick & 4096) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('97234110755111693312479820773')), 96, 256);
    }
    if ((tick & 8192) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('119332217159966728226237229890')), 96, 256);
    }
    if ((tick & 16384) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('179736315981702064433883588727')), 96, 256);
    }
    if ((tick & 32768) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('407748233172238350107850275304')), 96, 256);
    }
    if ((tick & 65536) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('2098478828474011932436660412517')), 96, 256);
    }
    if ((tick & 131072) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('55581415166113811149459800483533')), 96, 256);
    }
    if ((tick & 262144) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('38992368544603139932233054999993551')), 96, 256);
    }
    return signedShiftRight(ratio, 32, 256);
}
function tickIndexToSqrtPriceNegative(tickIndex) {
    const tick = Math.abs(tickIndex);
    let ratio;
    if ((tick & 1) !== 0) {
        ratio = new BN('18445821805675392311');
    }
    else {
        ratio = new BN('18446744073709551616');
    }
    if ((tick & 2) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('18444899583751176498')), 64, 256);
    }
    if ((tick & 4) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('18443055278223354162')), 64, 256);
    }
    if ((tick & 8) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('18439367220385604838')), 64, 256);
    }
    if ((tick & 16) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('18431993317065449817')), 64, 256);
    }
    if ((tick & 32) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('18417254355718160513')), 64, 256);
    }
    if ((tick & 64) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('18387811781193591352')), 64, 256);
    }
    if ((tick & 128) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('18329067761203520168')), 64, 256);
    }
    if ((tick & 256) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('18212142134806087854')), 64, 256);
    }
    if ((tick & 512) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('17980523815641551639')), 64, 256);
    }
    if ((tick & 1024) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('17526086738831147013')), 64, 256);
    }
    if ((tick & 2048) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('16651378430235024244')), 64, 256);
    }
    if ((tick & 4096) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('15030750278693429944')), 64, 256);
    }
    if ((tick & 8192) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('12247334978882834399')), 64, 256);
    }
    if ((tick & 16384) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('8131365268884726200')), 64, 256);
    }
    if ((tick & 32768) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('3584323654723342297')), 64, 256);
    }
    if ((tick & 65536) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('696457651847595233')), 64, 256);
    }
    if ((tick & 131072) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('26294789957452057')), 64, 256);
    }
    if ((tick & 262144) !== 0) {
        ratio = signedShiftRight(ratio.mul(new BN('37481735321082')), 64, 256);
    }
    return ratio;
}
class ClmmTickMath {
    static tickIndexToSqrtPriceX64(tickIndex) {
        if (tickIndex > 0) {
            return new BN(tickIndexToSqrtPricePositive(tickIndex));
        }
        return new BN(tickIndexToSqrtPriceNegative(tickIndex));
    }
    static sqrtPriceX64ToTickIndex(sqrtPriceX64) {
        invariant(sqrtPriceX64.gte(ClmmTickMath.MIN_SQRT_RATIO) &&
            sqrtPriceX64.lte(ClmmTickMath.MAX_SQRT_RATIO), 'SQRT_RATIO');
        const msb = sqrtPriceX64.bitLength() - 1;
        const adjustedMsb = new BN(msb - 64);
        const log2pIntegerX32 = signedShiftLeft(adjustedMsb, 32, 128);
        let bit = new BN('8000000000000000', 'hex');
        let precision = 0;
        let log2pFractionX64 = new BN(0);
        let r = msb >= 64 ? sqrtPriceX64.shrn(msb - 63) : sqrtPriceX64.shln(63 - msb);
        while (bit.gt(new BN(0)) && precision < BIT_PRECISION) {
            r = r.mul(r);
            const rMoreThanTwo = r.shrn(127);
            r = r.shrn(63 + rMoreThanTwo.toNumber());
            log2pFractionX64 = log2pFractionX64.add(bit.mul(rMoreThanTwo));
            bit = bit.shrn(1);
            precision += 1;
        }
        const log2pFractionX32 = log2pFractionX64.shrn(32);
        const log2pX32 = log2pIntegerX32.add(log2pFractionX32);
        const logbpX64 = log2pX32.mul(new BN(LOG_B_2_X32));
        const tickLow = signedShiftRight(logbpX64.sub(new BN(LOG_B_P_ERR_MARGIN_LOWER_X64)), 64, 128).toNumber();
        const tickHigh = signedShiftRight(logbpX64.add(new BN(LOG_B_P_ERR_MARGIN_UPPER_X64)), 64, 128).toNumber();
        if (tickLow === tickHigh) {
            return tickLow;
        }
        const derivedTickHighSqrtPriceX64 = ClmmTickMath.tickIndexToSqrtPriceX64(tickHigh);
        if (derivedTickHighSqrtPriceX64.lte(sqrtPriceX64)) {
            return tickHigh;
        }
        return tickLow;
    }
    static getInitializableTickIndex(tickIndex, tickSpacing) {
        return Math.floor(tickIndex / tickSpacing) * tickSpacing;
    }
}
/**
 * The minimum tick that can be used on any pool.
 */
ClmmTickMath.MIN_TICK = -443636;
/**
 * The maximum tick that can be used on any pool.
 */
ClmmTickMath.MAX_TICK = -ClmmTickMath.MIN_TICK;
/**
 * The sqrt ratio corresponding to the minimum tick that could be used on any pool.
 */
ClmmTickMath.MIN_SQRT_RATIO = new BN('4295048016');
/**
 * The sqrt ratio corresponding to the maximum tick that could be used on any pool.
 */
ClmmTickMath.MAX_SQRT_RATIO = new BN('79226673515401279992447579055');

/**
 * Returns the sqrt ratio as a Q64.96 corresponding to a given ratio of amount1 and amount0
 * @param amount1 The numerator amount i.e., the amount of token1
 * @param amount0 The denominator amount i.e., the amount of token0
 * @returns The sqrt ratio
 */
function encodeSqrtRatioX64(amount1, amount0) {
    const numerator = new BN(amount1).shln(128);
    const denominator = new BN(amount0);
    const ratioX128 = numerator.div(denominator);
    return sqrtBn(ratioX128);
}

/**
 * Returns a price object corresponding to the input tick and the base/quote token
 * Inputs must be tokens because the address order is used to interpret the price represented by the tick
 * @param baseCoin the base token of the price
 * @param quoteCoin the quote token of the price
 * @param tick the tick for which to return the price
 */
function tickToPrice(baseCoin, quoteCoin, tick) {
    const sqrtRatioX64 = ClmmTickMath.tickIndexToSqrtPriceX64(tick);
    return sqrtPriceX64ToPrice(baseCoin, quoteCoin, sqrtRatioX64);
}
/**
 *
 *
 * @param baseCoin
 * @param quoteCoin
 * @param sqrtPriceX64
 * @returns
 */
function sqrtPriceX64ToPrice(baseCoin, quoteCoin, sqrtPriceX64) {
    const ratioX128 = new BN$1(sqrtPriceX64).mul(new BN$1(sqrtPriceX64));
    return baseCoin.sortsBefore(quoteCoin)
        ? new Price(baseCoin, quoteCoin, Q128, ratioX128)
        : new Price(baseCoin, quoteCoin, ratioX128, Q128);
}
/**
 * Returns the first tick for which the given price is greater than or equal to the tick price
 * @param price for which to return the closest tick that represents a price less than or equal to the input price,
 * i.e. the price of the returned tick is less than or equal to the input price
 */
function priceToClosestTick(price) {
    const sorted = price.baseCoin.sortsBefore(price.quoteCoin);
    const sqrtRatioX96 = sorted
        ? encodeSqrtRatioX64(price.numerator, price.denominator)
        : encodeSqrtRatioX64(price.denominator, price.numerator);
    let tick = ClmmTickMath.sqrtPriceX64ToTickIndex(sqrtRatioX96);
    const nextTickPrice = tickToPrice(price.baseCoin, price.quoteCoin, tick + 1);
    if (sorted) {
        if (!price.lt(nextTickPrice)) {
            tick++;
        }
    }
    else {
        if (!price.gt(nextTickPrice)) {
            tick++;
        }
    }
    return tick;
}

class ClmmFullMath {
    static mulDivRoundingUp(a, b, denominator) {
        const product = a.mul(b);
        let result = product.div(denominator);
        if (!product.mod(denominator).eq(ZERO))
            result = result.add(ONE);
        return result;
    }
    static mulDivRoundingDown(a, b, denominator) {
        const product = a.mul(b);
        const result = product.div(denominator);
        return result;
    }
    static wrappingSubIn128(x, y) {
        const difference = x.sub(y);
        if (difference.lt(ZERO)) {
            return Q128.add(difference);
        }
        else {
            return difference;
        }
    }
}

class ClmmSqrtPriceMath {
    static getAmountXDelta(sqrtRatioAX64, sqrtRatioBX64, liquidity, roundUp) {
        if (sqrtRatioAX64.gt(sqrtRatioBX64)) {
            [sqrtRatioAX64, sqrtRatioBX64] = [sqrtRatioBX64, sqrtRatioAX64];
        }
        const numerator1 = liquidity.shln(64);
        const numerator2 = sqrtRatioBX64.sub(sqrtRatioAX64);
        return roundUp
            ? ClmmFullMath.mulDivRoundingUp(ClmmFullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX64), ONE, sqrtRatioAX64)
            : numerator1.mul(numerator2).div(sqrtRatioBX64).div(sqrtRatioAX64);
    }
    static getAmountYDelta(sqrtRatioAX64, sqrtRatioBX64, liquidity, roundUp) {
        if (sqrtRatioAX64.gt(sqrtRatioBX64)) {
            [sqrtRatioAX64, sqrtRatioBX64] = [sqrtRatioBX64, sqrtRatioAX64];
        }
        return roundUp
            ? ClmmFullMath.mulDivRoundingUp(liquidity, sqrtRatioBX64.sub(sqrtRatioAX64), Q64)
            : liquidity.mul(sqrtRatioBX64.sub(sqrtRatioAX64)).div(Q64);
    }
}

class ClmmLiquidityMath {
    static maxLiquidityForAmountXImprecise(sqrtRatioAX64, sqrtRatioBX64, amountX) {
        if (sqrtRatioAX64.gt(sqrtRatioBX64)) {
            [sqrtRatioAX64, sqrtRatioBX64] = [sqrtRatioBX64, sqrtRatioAX64];
        }
        const intermediate = sqrtRatioAX64.mul(sqrtRatioBX64).div(Q64);
        return new BN(amountX)
            .mul(intermediate)
            .div(sqrtRatioBX64.sub(sqrtRatioAX64));
    }
    static maxLiquidityForAmountXPrecise(sqrtRatioAX64, sqrtRatioBX64, amountX) {
        if (sqrtRatioAX64.gt(sqrtRatioBX64)) {
            [sqrtRatioAX64, sqrtRatioBX64] = [sqrtRatioBX64, sqrtRatioAX64];
        }
        const numerator = new BN(amountX).mul(sqrtRatioAX64).mul(sqrtRatioBX64);
        const denominator = Q64.mul(sqrtRatioBX64.sub(sqrtRatioAX64));
        return numerator.div(denominator);
    }
    static maxLiquidityForAmountY(sqrtRatioAX64, sqrtRatioBX64, amountY) {
        if (sqrtRatioAX64.gt(sqrtRatioBX64)) {
            [sqrtRatioAX64, sqrtRatioBX64] = [sqrtRatioBX64, sqrtRatioAX64];
        }
        return new BN(amountY).mul(Q64).div(sqrtRatioBX64.sub(sqrtRatioAX64));
    }
    static maxLiquidityForAmounts(sqrtRatioCurrentX64, sqrtRatioAX64, sqrtRatioBX64, amountX, amountY, useFullPrecision) {
        if (sqrtRatioAX64.gt(sqrtRatioBX64)) {
            [sqrtRatioAX64, sqrtRatioBX64] = [sqrtRatioBX64, sqrtRatioAX64];
        }
        const maxLiquidityForAmountX = useFullPrecision
            ? ClmmLiquidityMath.maxLiquidityForAmountXPrecise
            : ClmmLiquidityMath.maxLiquidityForAmountXImprecise;
        if (sqrtRatioCurrentX64.lte(sqrtRatioAX64)) {
            return maxLiquidityForAmountX(sqrtRatioAX64, sqrtRatioBX64, amountX);
        }
        else if (sqrtRatioCurrentX64.lt(sqrtRatioBX64)) {
            const liquidity0 = maxLiquidityForAmountX(sqrtRatioCurrentX64, sqrtRatioBX64, amountX);
            const liquidity1 = ClmmLiquidityMath.maxLiquidityForAmountY(sqrtRatioAX64, sqrtRatioCurrentX64, amountY);
            return liquidity0.lt(liquidity1) ? liquidity0 : liquidity1;
        }
        else {
            return ClmmLiquidityMath.maxLiquidityForAmountY(sqrtRatioAX64, sqrtRatioBX64, amountY);
        }
    }
}

/**
 * Determines if a tick list is sorted
 * @param list The tick list
 * @param comparator The comparator
 * @returns true if sorted
 */
function isSorted(list, comparator) {
    for (let i = 0; i < list.length - 1; i++) {
        if (comparator(list[i], list[i + 1]) > 0) {
            return false;
        }
    }
    return true;
}

class TickLibrary {
    static getFeeGrowthInside(feeGrowthOutsideLower, feeGrowthOutsideUpper, tickLower, tickUpper, tickCurrent, feeGrowthGlobalX, feeGrowthGlobalY) {
        let feeGrowthBelowX, feeGrowthBelowY;
        if (tickCurrent >= tickLower) {
            feeGrowthBelowX = feeGrowthOutsideLower.feeGrowthOutsideX;
            feeGrowthBelowY = feeGrowthOutsideLower.feeGrowthOutsideY;
        }
        else {
            feeGrowthBelowX = ClmmFullMath.wrappingSubIn128(feeGrowthGlobalX, feeGrowthOutsideLower.feeGrowthOutsideX);
            feeGrowthBelowY = ClmmFullMath.wrappingSubIn128(feeGrowthGlobalY, feeGrowthOutsideLower.feeGrowthOutsideY);
        }
        let feeGrowthAboveX, feeGrowthAboveY;
        if (tickCurrent < tickUpper) {
            feeGrowthAboveX = feeGrowthOutsideUpper.feeGrowthOutsideX;
            feeGrowthAboveY = feeGrowthOutsideUpper.feeGrowthOutsideY;
        }
        else {
            feeGrowthAboveX = ClmmFullMath.wrappingSubIn128(feeGrowthGlobalX, feeGrowthOutsideUpper.feeGrowthOutsideX);
            feeGrowthAboveY = ClmmFullMath.wrappingSubIn128(feeGrowthGlobalY, feeGrowthOutsideUpper.feeGrowthOutsideY);
        }
        return [
            ClmmFullMath.wrappingSubIn128(ClmmFullMath.wrappingSubIn128(feeGrowthGlobalX, feeGrowthBelowX), feeGrowthAboveX),
            ClmmFullMath.wrappingSubIn128(ClmmFullMath.wrappingSubIn128(feeGrowthGlobalY, feeGrowthBelowY), feeGrowthAboveY),
        ];
    }
    static getRewardsGrowthInside(rewardsGrowthOutsideLower, rewardsGrowthOutsideUpper, tickLower, tickUpper, tickCurrent, rewardsGrowthGlobal) {
        let rewardsGrowthBelow;
        if (tickCurrent >= tickLower) {
            rewardsGrowthBelow = rewardsGrowthOutsideLower.slice();
        }
        else {
            rewardsGrowthBelow = rewardsGrowthGlobal.map((rewardGrowthGlobal, idx) => {
                var _a;
                return ClmmFullMath.wrappingSubIn128(rewardGrowthGlobal, (_a = rewardsGrowthOutsideLower[idx]) !== null && _a !== void 0 ? _a : ZERO);
            });
        }
        let rewardsGrowthAbove;
        if (tickCurrent < tickUpper) {
            rewardsGrowthAbove = rewardsGrowthOutsideUpper.slice();
        }
        else {
            rewardsGrowthAbove = rewardsGrowthGlobal.map((rewardGrowthGlobal, idx) => {
                var _a;
                return ClmmFullMath.wrappingSubIn128(rewardGrowthGlobal, (_a = rewardsGrowthOutsideUpper[idx]) !== null && _a !== void 0 ? _a : ZERO);
            });
        }
        return rewardsGrowthGlobal.map((rewardGrowthGlobal, idx) => {
            var _a, _b;
            return ClmmFullMath.wrappingSubIn128(ClmmFullMath.wrappingSubIn128(rewardGrowthGlobal, (_a = rewardsGrowthBelow[idx]) !== null && _a !== void 0 ? _a : ZERO), (_b = rewardsGrowthAbove[idx]) !== null && _b !== void 0 ? _b : ZERO);
        });
    }
}

var _TickList_contents;
function tickComparator(a, b) {
    return a.index - b.index;
}
/**
 * Utility methods for interacting with sorted lists of ticks
 */
class TickList {
    constructor(ticks) {
        _TickList_contents.set(this, {});
        ticks.forEach((tick) => {
            invariant(!__classPrivateFieldGet(this, _TickList_contents, "f")[tick.index], 'DUPLICATE_TICK');
            __classPrivateFieldGet(this, _TickList_contents, "f")[tick.index] = tick;
        });
    }
    static validateList(ticks, tickSpacing) {
        invariant(tickSpacing > 0, 'TICK_SPACING_NONZERO');
        // ensure ticks are spaced appropriately
        invariant(ticks.every(({ index }) => index % tickSpacing === 0), 'TICK_SPACING');
        // ensure tick liquidity deltas sum to 0
        invariant(ticks.reduce((accumulator, { liquidityNet }) => accumulator.add(new BN$1(liquidityNet)), ZERO), 'ZERO_NET');
        invariant(isSorted(ticks, tickComparator), 'SORTED');
    }
    getTick(index) {
        const tick = __classPrivateFieldGet(this, _TickList_contents, "f")[index];
        invariant((tick === null || tick === void 0 ? void 0 : tick.index) === index, 'NOT_CONTAINED');
        return tick;
    }
}
_TickList_contents = new WeakMap();

/**
 * The default enabled fee amounts, denominated in hundredths of bips.
 */
var FeeAmount;
(function (FeeAmount) {
    FeeAmount[FeeAmount["ZERO"] = 0] = "ZERO";
    FeeAmount[FeeAmount["VERY_LOWEST"] = 10] = "VERY_LOWEST";
    FeeAmount[FeeAmount["LOWEST"] = 100] = "LOWEST";
    FeeAmount[FeeAmount["LOW"] = 500] = "LOW";
    FeeAmount[FeeAmount["LOW_HIGH"] = 1000] = "LOW_HIGH";
    FeeAmount[FeeAmount["MEDIUM_LOW"] = 2000] = "MEDIUM_LOW";
    FeeAmount[FeeAmount["MEDIUM"] = 3000] = "MEDIUM";
    FeeAmount[FeeAmount["HIGH"] = 10000] = "HIGH";
})(FeeAmount || (FeeAmount = {}));
/**
 * The default tick spacings by fee amount.
 */
const TICK_SPACINGS = {
    [FeeAmount.ZERO]: 1,
    [FeeAmount.VERY_LOWEST]: 1,
    [FeeAmount.LOWEST]: 2,
    [FeeAmount.LOW]: 10,
    [FeeAmount.LOW_HIGH]: 20,
    [FeeAmount.MEDIUM_LOW]: 40,
    [FeeAmount.MEDIUM]: 60,
    [FeeAmount.HIGH]: 200,
};
const MODULE_POOL_MANAGER = 'pool_manager';
const MODULE_POSITION_MANAGER = 'position_manager';
const MODULE_I32 = 'i32';
const BPS$1 = 1e6;
const I32_BITS = 32;
const I128_BITS = 128;
const CONFIGS$4 = {
    mainnet: {
        packageId: '0xde2c47eb0da8c74e4d0f6a220c41619681221b9c2590518095f0f0c2d3f3c772',
        poolRegistryObject: '0x27565d24a4cd51127ac90e4074a841bbe356cca7bf5759ddc14a975be1632abc',
        positionRegistryObject: '0x7dffe3229d675645564273aa68c67406b6a80aa29e245ac78283acd7ed5e4912',
        versionObject: '0x67624a1533b5aff5d0dfcf5e598684350efd38134d2d245f475524c03a64e656',
        positionType: '0x25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::position::Position',
        poolType: '0x25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::pool::Pool',
        i32Type: '0x25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::i32::I32',
        poolFeeCollectEventType: '0x25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::pool::Collect',
        poolRewardCollectEventType: '0x25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::pool::CollectPoolReward',
    },
    testnet: {
        packageId: '0x99c4e760b488a56b6be0f5e7afbf2e3640579e2cf7833bd703269b128ef54277',
        poolRegistryObject: '0xbc975b5ab2b3986a6bfbcb6d733d8ba98a774e0e1dd9b704a236c0810a33b3bf',
        positionRegistryObject: '0x7a8a99814eccd13a8b71b19631b8a659ffd6ab999508acae58ddc4eff64f5410',
        versionObject: '0x36a148eccf25b4126c53eb42686895aca7bb1faab0a70a5c98eab6d3cd63e9fc',
        poolFeeCollectEventType: '0x40aa5119ae0633e7ba3c80fe4fd3d9b5277300dead42f6f9e565e7dd589cf6cb::pool::Collect',
        positionType: '0x40aa5119ae0633e7ba3c80fe4fd3d9b5277300dead42f6f9e565e7dd589cf6cb::position::Position',
        poolType: '0x40aa5119ae0633e7ba3c80fe4fd3d9b5277300dead42f6f9e565e7dd589cf6cb::pool::Pool',
        i32Type: '0x40aa5119ae0633e7ba3c80fe4fd3d9b5277300dead42f6f9e565e7dd589cf6cb::i32::I32',
        poolRewardCollectEventType: '0x40aa5119ae0633e7ba3c80fe4fd3d9b5277300dead42f6f9e565e7dd589cf6cb::pool::CollectPoolReward',
    },
};

const FLOAT_SCALING$1 = 1000000000;
/**
 * Calculate swap amount to balance assets with formula
 * x + y = a; ration = y/x
 * x = a / (1 + ratio)
 * y = a - x
 */
class ZapCalculator {
    static zapAmount(_a) {
        return __awaiter(this, arguments, void 0, function* ({ pool, tickLower, tickUpper, amount, isCoinX, priceProvider, }) {
            const [priceX, priceY] = yield Promise.all([
                priceProvider.getPrice(pool.coins[0].coinType),
                priceProvider.getPrice(pool.coins[1].coinType),
            ]);
            // The ratio is the proportion between the amount of asset X and the amount of asset Y
            // when adding liquidity to the range [tickLower, tickUpper]
            let ratio = pool
                .getRatio(tickLower, tickUpper)
                .multiply(new Fraction(new BigNumber(priceY).multipliedBy(FLOAT_SCALING$1).toFixed(0), new BigNumber(priceX).multipliedBy(FLOAT_SCALING$1).toFixed(0)).divide(new Fraction(new BN(10).pow(new BN(pool.coins[1].decimals)), new BN(10).pow(new BN(pool.coins[0].decimals)))));
            if (!isCoinX) {
                ratio = new Fraction(ONE).divide(ratio);
            }
            const fraction = ratio
                .multiply(new Percent(1).subtract(new Percent(pool.fee.toString(), BPS$1)))
                .add(ONE.toString());
            return new BN(amount).sub(new BN(new Fraction(amount).divide(fraction).toFixed(0)));
        });
    }
}

const closestActiveRange = (pool, multiplier = 1) => {
    const halfRange = (multiplier * pool.tickSpacing) / 2;
    const candidateTickLower = Math.round((pool.tickCurrent - halfRange) / pool.tickSpacing) *
        pool.tickSpacing;
    let lowerTick = candidateTickLower;
    const currentSqrtPriceX64 = new BN(pool.sqrtPriceX64);
    if (currentSqrtPriceX64.lt(ClmmTickMath.tickIndexToSqrtPriceX64(pool.tickCurrent))) {
        if (lowerTick === pool.tickCurrent) {
            lowerTick -= pool.tickSpacing;
        }
    }
    return [lowerTick, lowerTick + multiplier * pool.tickSpacing];
};

class AftermathSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const { wrappedRouterPackageId, poolRegistryObjectId, protocolFeeVaultObjectId, treasuryObjectId, insuranceFundObjectId, referralVaultOjectId, } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::swap_exact_input`,
                typeArguments: [
                    this.lpCoinType,
                    this.input.coinType,
                    this.output.coinType,
                ],
                arguments: [
                    routeObject,
                    tx.object(poolRegistryObjectId),
                    tx.object(this.pool.id),
                    tx.object(protocolFeeVaultObjectId),
                    tx.object(treasuryObjectId),
                    tx.object(insuranceFundObjectId),
                    tx.object(referralVaultOjectId),
                    tx.pure.u64(this.amountOut.toString()),
                ],
            });
        };
        this.lpCoinType = options.lpCoinType;
    }
    protocol() {
        return Protocol.AFTERMATH;
    }
}

class CetusSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const sqrtPriceX64LimitAdjusted = this.xForY
                ? new Fraction(this.sqrtPriceX64Limit).multiply(new Percent(1).subtract(slippage))
                : new Fraction(this.sqrtPriceX64Limit).multiply(slippage.add(1));
            const { wrappedRouterPackageId, globalConfigObjectId } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [
                    this.xForY ? this.input.coinType : this.output.coinType,
                    this.xForY ? this.output.coinType : this.input.coinType,
                ],
                arguments: [
                    routeObject,
                    tx.object(globalConfigObjectId),
                    tx.object(this.pool.id),
                    tx.pure.u128(this.xForY
                        ? Fraction.max(sqrtPriceX64LimitAdjusted, new Fraction(this.minSqrtPriceX64HasLiquidity)).toFixed(0)
                        : Fraction.min(sqrtPriceX64LimitAdjusted, new Fraction(this.maxSqrtPriceX64HasLiquidity)).toFixed(0)),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
        this.xForY = options.xForY;
        this.sqrtPriceX64Limit = options.sqrtPriceX64Limit;
        this.maxSqrtPriceX64HasLiquidity = options.maxSqrtPriceX64HasLiquidity;
        this.minSqrtPriceX64HasLiquidity = options.minSqrtPriceX64HasLiquidity;
    }
    protocol() {
        return Protocol.CETUS;
    }
}

class DeepbookSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            throw new Error('DeepbookSwap is not implemented yet. Please use DeepbookSwapV3 instead.');
        };
        this.xForY = options.xForY;
        this.lotSize = options.lotSize;
    }
    protocol() {
        return Protocol.DEEPBOOK;
    }
}

class FlowxV2Swap extends Swap {
    constructor() {
        super(...arguments);
        this.swap = (routeObject, slippage) => (tx) => {
            const { wrappedRouterPackageId, containerObjectId } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::swap_exact_input`,
                typeArguments: [this.input.coinType, this.output.coinType],
                arguments: [routeObject, tx.object(containerObjectId)],
            });
        };
    }
    protocol() {
        return Protocol.FLOWX_V2;
    }
}

class FlowxV3Swap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const sqrtPriceX64LimitAdjusted = this.xForY
                ? new Fraction(this.sqrtPriceX64Limit).multiply(new Percent(1).subtract(slippage))
                : new Fraction(this.sqrtPriceX64Limit).multiply(slippage.add(1));
            const { wrappedRouterPackageId, poolRegistryObjectId, versionedObjectId, } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::swap_exact_input`,
                typeArguments: [this.input.coinType, this.output.coinType],
                arguments: [
                    routeObject,
                    tx.object(poolRegistryObjectId),
                    tx.pure.u64(this.poolFee.toString()),
                    tx.pure.u128(this.xForY
                        ? Fraction.max(sqrtPriceX64LimitAdjusted, new Fraction(this.minSqrtPriceX64HasLiquidity)).toFixed(0)
                        : Fraction.min(sqrtPriceX64LimitAdjusted, new Fraction(this.maxSqrtPriceX64HasLiquidity)).toFixed(0)),
                    tx.object(versionedObjectId),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
        this.xForY = options.xForY;
        this.poolFee = options.poolFee;
        this.sqrtPriceX64Limit = options.sqrtPriceX64Limit;
        this.maxSqrtPriceX64HasLiquidity = options.maxSqrtPriceX64HasLiquidity;
        this.minSqrtPriceX64HasLiquidity = options.minSqrtPriceX64HasLiquidity;
    }
    protocol() {
        return Protocol.FLOWX_V3;
    }
}

class KriyaDexSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const { wrappedRouterPackageId } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [
                    this.xForY ? this.input.coinType : this.output.coinType,
                    this.xForY ? this.output.coinType : this.input.coinType,
                ],
                arguments: [routeObject, tx.object(this.pool.id)],
            });
        };
        this.xForY = options.xForY;
    }
    protocol() {
        return Protocol.KRIYA_DEX;
    }
}

class TurbosSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const [coinX, coinY] = this.xForY
                ? [this.input.coinType, this.output.coinType]
                : [this.output.coinType, this.input.coinType];
            const sqrtPriceX64LimitAdjusted = this.xForY
                ? new Fraction(this.sqrtPriceX64Limit).multiply(new Percent(1).subtract(slippage))
                : new Fraction(this.sqrtPriceX64Limit).multiply(slippage.add(1));
            const { wrappedRouterPackageId, versionedObjectId } = this.protocolConfig;
            const [, , swapFeeType] = parseStructTag(this.poolStructTag).typeParams;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [coinX, coinY, normalizeStructTag$1(swapFeeType)],
                arguments: [
                    routeObject,
                    tx.object(this.pool.id),
                    tx.pure.u128(this.xForY
                        ? Fraction.max(sqrtPriceX64LimitAdjusted, new Fraction(this.minSqrtPriceX64HasLiquidity)).toFixed(0)
                        : Fraction.min(sqrtPriceX64LimitAdjusted, new Fraction(this.maxSqrtPriceX64HasLiquidity)).toFixed(0)),
                    tx.object(versionedObjectId),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
        this.xForY = options.xForY;
        this.sqrtPriceX64Limit = options.sqrtPriceX64Limit;
        this.maxSqrtPriceX64HasLiquidity = options.maxSqrtPriceX64HasLiquidity;
        this.minSqrtPriceX64HasLiquidity = options.minSqrtPriceX64HasLiquidity;
        this.poolStructTag = options.poolStructTag;
    }
    protocol() {
        return Protocol.TURBOS_FIANCE;
    }
}

class KriyaV3Swap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const sqrtPriceX64LimitAdjusted = this.xForY
                ? new Fraction(this.sqrtPriceX64Limit).multiply(new Percent(1).subtract(slippage))
                : new Fraction(this.sqrtPriceX64Limit).multiply(slippage.add(1));
            const { wrappedRouterPackageId, versionObjectId } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [
                    this.xForY ? this.input.coinType : this.output.coinType,
                    this.xForY ? this.output.coinType : this.input.coinType,
                ],
                arguments: [
                    routeObject,
                    tx.object(this.pool.id),
                    tx.pure.u128(this.xForY
                        ? Fraction.max(sqrtPriceX64LimitAdjusted, new Fraction(this.minSqrtPriceX64HasLiquidity)).toFixed(0)
                        : Fraction.min(sqrtPriceX64LimitAdjusted, new Fraction(this.maxSqrtPriceX64HasLiquidity)).toFixed(0)),
                    tx.object(versionObjectId),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
        this.xForY = options.xForY;
        this.sqrtPriceX64Limit = options.sqrtPriceX64Limit;
        this.maxSqrtPriceX64HasLiquidity = options.maxSqrtPriceX64HasLiquidity;
        this.minSqrtPriceX64HasLiquidity = options.minSqrtPriceX64HasLiquidity;
    }
    protocol() {
        return Protocol.KRIYA_V3;
    }
}

class BluemoveSwap extends Swap {
    constructor() {
        super(...arguments);
        this.swap = (routeObject, slippage) => (tx) => {
            const { wrappedRouterPackageId, dexInfoObjectId } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::swap_exact_input`,
                typeArguments: [this.input.coinType, this.output.coinType],
                arguments: [routeObject, tx.object(dexInfoObjectId)],
            });
        };
    }
    protocol() {
        return Protocol.BLUEMOVE;
    }
}

class DeepbookV3Swap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const { wrappedRouterPackageId, treasuryObjectId } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [
                    this.xForY ? this.input.coinType : this.output.coinType,
                    this.xForY ? this.output.coinType : this.input.coinType,
                ],
                arguments: [
                    tx.object(treasuryObjectId),
                    routeObject,
                    tx.object(this.pool.id),
                    tx.pure.u64(this.deepFeeAmount.toString()),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
        this.xForY = options.xForY;
        this.deepFeeAmount = new BigNumber(options.deepFeeAmount.toString())
            .multipliedBy(120)
            .dividedBy(100)
            .toFixed(0);
    }
    protocol() {
        return Protocol.DEEPBOOK_V3;
    }
}

class BluefinSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const sqrtPriceX64LimitAdjusted = this.xForY
                ? new Fraction(this.sqrtPriceX64Limit).multiply(new Percent(1).subtract(slippage))
                : new Fraction(this.sqrtPriceX64Limit).multiply(slippage.add(1));
            const { wrappedRouterPackageId, globalConfigObjectId } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [
                    this.xForY ? this.input.coinType : this.output.coinType,
                    this.xForY ? this.output.coinType : this.input.coinType,
                ],
                arguments: [
                    routeObject,
                    tx.object(globalConfigObjectId),
                    tx.object(this.pool.id),
                    tx.pure.u128(this.xForY
                        ? Fraction.max(sqrtPriceX64LimitAdjusted, new Fraction(this.minSqrtPriceX64HasLiquidity)).toFixed(0)
                        : Fraction.min(sqrtPriceX64LimitAdjusted, new Fraction(this.maxSqrtPriceX64HasLiquidity)).toFixed(0)),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
        this.xForY = options.xForY;
        this.sqrtPriceX64Limit = options.sqrtPriceX64Limit;
        this.maxSqrtPriceX64HasLiquidity = options.maxSqrtPriceX64HasLiquidity;
        this.minSqrtPriceX64HasLiquidity = options.minSqrtPriceX64HasLiquidity;
    }
    protocol() {
        return Protocol.BLUEFIN;
    }
}

class FlowxPmmSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const { sourcePackageId, wrappedRouterPackageId, stateObjectId } = this.protocolConfig;
            const quote = tx.moveCall({
                target: `${sourcePackageId}::quote::new`,
                typeArguments: [this.input.coinType, this.output.coinType],
                arguments: [
                    tx.pure.u64(this.amountIn.toString()),
                    tx.pure.u64(this.amountOut.toString()),
                    tx.pure.u64(this.swapTimestampMs),
                ],
            });
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [
                    this.xForY ? this.input.coinType : this.output.coinType,
                    this.xForY ? this.output.coinType : this.input.coinType,
                ],
                arguments: [
                    routeObject,
                    tx.object(stateObjectId),
                    tx.object(this.pool.id),
                    quote,
                    tx.pure(bcs
                        .vector(bcs.vector(bcs.u8()))
                        .serialize(this.signatures.map((item) => bcs.bytes(item.replace('0x', '').length / 2).fromHex(item)))),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
        this.xForY = options.xForY;
        this.swapTimestampMs = options.swapTimestampMs;
        this.signatures = options.signatures;
    }
    protocol() {
        return Protocol.FLOWX_PMM;
    }
}

class BlueMoveFunSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const { wrappedRouterPackageId, configurationObjectId, thresholdObjectId, dexInfoObjectId, } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_for_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [
                    this.xForY ? this.input.coinType : this.output.coinType,
                ],
                arguments: this.xForY
                    ? [
                        routeObject,
                        tx.object(configurationObjectId),
                        tx.object(SUI_CLOCK_OBJECT_ID),
                    ]
                    : [
                        routeObject,
                        tx.object(configurationObjectId),
                        tx.object(thresholdObjectId),
                        tx.object(dexInfoObjectId),
                        tx.pure.u64(this.amountOut.toString()),
                        tx.object(SUI_CLOCK_OBJECT_ID),
                    ],
            });
        };
        this.xForY = options.xForY;
    }
    protocol() {
        return Protocol.BLUEMOVE_FUN;
    }
}

class HopFunSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const { wrappedRouterPackageId, memeConfigObjectId } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [
                    this.xForY ? this.input.coinType : this.output.coinType,
                ],
                arguments: this.xForY
                    ? [
                        routeObject,
                        tx.object(memeConfigObjectId),
                        tx.object(this.pool.id),
                    ]
                    : [
                        routeObject,
                        tx.object(memeConfigObjectId),
                        tx.object(this.pool.id),
                        tx.pure.u64(this.amountOut.toString()),
                    ],
            });
        };
        this.xForY = options.xForY;
    }
    protocol() {
        return Protocol.HOP_FUN;
    }
}

class SevenKFunSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const { wrappedRouterPackageId, configurationObjectId, flowxV2ContainerObjectId, } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [
                    this.xForY ? this.input.coinType : this.output.coinType,
                ],
                arguments: this.xForY
                    ? [routeObject, tx.object(configurationObjectId)]
                    : [
                        routeObject,
                        tx.object(configurationObjectId),
                        tx.object(flowxV2ContainerObjectId),
                        tx.object(SUI_CLOCK_OBJECT_ID),
                    ],
            });
        };
        this.xForY = options.xForY;
    }
    protocol() {
        return Protocol.SEVEN_K_FUN;
    }
}

class TurbosFunSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const { wrappedRouterPackageId, configurationObjectId } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [
                    this.xForY ? this.input.coinType : this.output.coinType,
                ],
                arguments: [
                    routeObject,
                    tx.object(configurationObjectId),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
        this.xForY = options.xForY;
    }
    protocol() {
        return Protocol.TURBOS_FUN;
    }
}

class ObricSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const [coinX, coinY] = [
                this.xForY ? this.input.coinType : this.output.coinType,
                this.xForY ? this.output.coinType : this.input.coinType,
            ];
            const { wrappedRouterPackageId } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [coinX, coinY],
                arguments: [
                    routeObject,
                    tx.object(this.pool.id),
                    tx.object(CONFIGS$5[this.network].pyth.stateObjectId),
                    tx.object(this.xPriceId),
                    tx.object(this.yPriceId),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
        this.xForY = options.xForY;
        this.xPriceId = options.xPriceId;
        this.yPriceId = options.yPriceId;
    }
    protocol() {
        return Protocol.OBRIC;
    }
}

class HaedalPMMSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage, pythMap) => (tx) => {
            var _a, _b, _c, _d;
            const [coinX, coinY] = [
                this.xForY ? this.input.coinType : this.output.coinType,
                this.xForY ? this.output.coinType : this.input.coinType,
            ];
            const [priceFeedObjectIdX, priceFeedObjectIdY] = [
                ((_b = (_a = this.oracles) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.priceId)
                    ? pythMap[this.oracles[0].priceId]
                    : undefined,
                ((_d = (_c = this.oracles) === null || _c === void 0 ? void 0 : _c[1]) === null || _d === void 0 ? void 0 : _d.priceId)
                    ? pythMap[this.oracles[1].priceId]
                    : undefined,
            ];
            invariant(priceFeedObjectIdX && priceFeedObjectIdY, 'Price feed object IDs must be defined for both coins');
            const { wrappedRouterPackageId } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [coinX, coinY],
                arguments: [
                    routeObject,
                    tx.object(this.pool.id),
                    tx.object(priceFeedObjectIdX),
                    tx.object(priceFeedObjectIdY),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
        this.xForY = options.xForY;
    }
    protocol() {
        return Protocol.HAEDAL_PMM;
    }
}

class HaedalSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const { wrappedRouterPackageId } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                arguments: [
                    routeObject,
                    tx.object(SUI_SYSTEM_STATE_OBJECT_ID),
                    tx.object(this.pool.id),
                ],
            });
        };
        this.xForY = options.xForY;
    }
    protocol() {
        return Protocol.HAEDAL;
    }
}

class SpringSuiSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const { wrappedRouterPackageId } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [
                    this.xForY ? this.input.coinType : this.output.coinType,
                ],
                arguments: [
                    routeObject,
                    tx.object(SUI_SYSTEM_STATE_OBJECT_ID),
                    tx.object(this.pool.id),
                ],
            });
        };
        this.xForY = options.xForY;
    }
    protocol() {
        return Protocol.SPRING_SUI;
    }
}

class AlphaFiSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const { wrappedRouterPackageId } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [
                    this.xForY ? this.input.coinType : this.output.coinType,
                ],
                arguments: [
                    routeObject,
                    tx.object(SUI_SYSTEM_STATE_OBJECT_ID),
                    tx.object(this.pool.id),
                ],
            });
        };
        this.xForY = options.xForY;
    }
    protocol() {
        return Protocol.ALPHA_FI;
    }
}

class VoloLsdSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const { wrappedRouterPackageId, vSuiMetadataObjectId } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                arguments: [
                    routeObject,
                    tx.object(this.pool.id),
                    tx.object(vSuiMetadataObjectId),
                    tx.object(SUI_SYSTEM_STATE_OBJECT_ID),
                ],
            });
        };
        this.xForY = options.xForY;
    }
    protocol() {
        return Protocol.VOLO_LSD;
    }
}

class AftermathLsdSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const { wrappedRouterPackageId, afSuiSafeTreasuryCapObjectId, referralVaultObjectId, treasuryObjectId, validatorAddr, } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                arguments: this.xForY
                    ? [
                        routeObject,
                        tx.object(this.pool.id),
                        tx.object(afSuiSafeTreasuryCapObjectId),
                        tx.object(referralVaultObjectId),
                        tx.object(treasuryObjectId),
                    ]
                    : [
                        routeObject,
                        tx.object(this.pool.id),
                        tx.object(afSuiSafeTreasuryCapObjectId),
                        tx.object(SUI_SYSTEM_STATE_OBJECT_ID),
                        tx.object(referralVaultObjectId),
                        tx.pure.address(validatorAddr),
                    ],
            });
        };
        this.xForY = options.xForY;
    }
    protocol() {
        return Protocol.AFTERMATH_LSD;
    }
}

class SteammSwap extends Swap {
    constructor(options) {
        super(options);
        this._handlers = {};
        this.cpmmSwap = (poolInfo, bankX, bankY) => (routeObject, tx) => {
            const { wrappedRouterPackageId } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'cpmm_swap_exact_x_to_y' : 'cpmm_swap_exact_y_to_x'}`,
                typeArguments: [
                    bankX.lendingMarketType,
                    bankX.nativeCoinType,
                    bankY.nativeCoinType,
                    bankX.bTokenType,
                    bankY.bTokenType,
                    poolInfo.lpTokenType,
                ],
                arguments: [
                    routeObject,
                    tx.object(this.pool.id),
                    tx.object(bankX.bankId),
                    tx.object(bankY.bankId),
                    tx.object(bankX.lendingMarketId),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
        this.getOraclePriceUpdate = (oracleInfo, pythMap) => (tx) => {
            const { oraclePackageId, oracleRegistryId } = this.protocolConfig;
            const priceObjectId = pythMap[oracleInfo === null || oracleInfo === void 0 ? void 0 : oracleInfo.priceId];
            invariant(priceObjectId && oracleInfo.oracleIndex !== undefined, `Price object ID and oracle index must be defined for oracle type ${oracleInfo.oracleType}`);
            switch (oracleInfo.oracleType) {
                case OracleType.PYTH:
                    return tx.moveCall({
                        target: `${oraclePackageId}::oracles::get_pyth_price`,
                        arguments: [
                            tx.object(oracleRegistryId),
                            tx.object(priceObjectId),
                            tx.pure.u64(oracleInfo.oracleIndex),
                            tx.object(SUI_CLOCK_OBJECT_ID),
                        ],
                    });
                default:
                    throw new Error(`Unsupported oracle type: ${oracleInfo.oracleType}`);
            }
        };
        this.getOraclePriceUpdates = (pythMap) => (tx) => {
            const [oracleInfoX, oracleInfoY] = this.oracles || [];
            const [oraclePriceUpdateX, oraclePriceUpdateY] = [
                this.getOraclePriceUpdate(oracleInfoX, pythMap)(tx),
                this.getOraclePriceUpdate(oracleInfoY, pythMap)(tx),
            ];
            return [oraclePriceUpdateX, oraclePriceUpdateY];
        };
        this.ommSwap = (poolInfo, bankX, bankY, pythMap) => (routeObject, tx) => {
            const [oraclePriceUpdateX, oraclePriceUpdateY] = this.getOraclePriceUpdates(pythMap)(tx);
            const { wrappedRouterPackageId } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'omm_swap_exact_x_to_y' : 'omm_swap_exact_y_to_x'}`,
                typeArguments: [
                    bankX.lendingMarketType,
                    bankX.nativeCoinType,
                    bankY.nativeCoinType,
                    bankX.bTokenType,
                    bankY.bTokenType,
                    poolInfo.lpTokenType,
                ],
                arguments: [
                    routeObject,
                    tx.object(this.pool.id),
                    tx.object(bankX.bankId),
                    tx.object(bankY.bankId),
                    tx.object(bankX.lendingMarketId),
                    oraclePriceUpdateX,
                    oraclePriceUpdateY,
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
        this.ommV2Swap = (poolInfo, bankX, bankY, pythMap) => (routeObject, tx) => {
            const [oraclePriceUpdateX, oraclePriceUpdateY] = this.getOraclePriceUpdates(pythMap)(tx);
            const { wrappedRouterPackageId } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'omm_v2_swap_exact_x_to_y' : 'omm_v2_swap_exact_y_to_x'}`,
                typeArguments: [
                    bankX.lendingMarketType,
                    bankX.nativeCoinType,
                    bankY.nativeCoinType,
                    bankX.bTokenType,
                    bankY.bTokenType,
                    poolInfo.lpTokenType,
                ],
                arguments: [
                    routeObject,
                    tx.object(this.pool.id),
                    tx.object(bankX.bankId),
                    tx.object(bankY.bankId),
                    tx.object(bankX.lendingMarketId),
                    oraclePriceUpdateX,
                    oraclePriceUpdateY,
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
        this.swap = (routeObject, slippage, pythMap) => (tx) => {
            const handler = this._handlers[this.quoterType];
            invariant(handler && typeof handler === 'function', `unsupported quoter with type=${this.quoterType}`);
            handler(this.poolInfo, this.bankXInfo, this.bankYInfo, pythMap)(routeObject, tx);
        };
        this.xForY = options.xForY;
        this.quoterType = options.quoterType;
        const bankXTypeParams = parseStructTag(options.bankXStructTag).typeParams;
        const bankYTypeParams = parseStructTag(options.bankYStructTag).typeParams;
        const poolTypeParams = parseStructTag(options.poolStructTag).typeParams;
        this.bankXInfo = {
            bankId: options.bankX,
            lendingMarketId: options.lendingMarketX,
            nativeCoinType: normalizeStructTag$1(bankXTypeParams[1]),
            bTokenType: normalizeStructTag$1(bankXTypeParams[2]),
            lendingMarketType: normalizeStructTag$1(bankXTypeParams[0]),
        };
        this.bankYInfo = {
            bankId: options.bankY,
            lendingMarketId: options.lendingMarketY,
            nativeCoinType: normalizeStructTag$1(bankYTypeParams[1]),
            bTokenType: normalizeStructTag$1(bankYTypeParams[2]),
            lendingMarketType: normalizeStructTag$1(bankYTypeParams[0]),
        };
        this.poolInfo = {
            poolId: this.pool.id,
            lpTokenType: normalizeStructTag$1(poolTypeParams[poolTypeParams.length - 1]),
        };
        this._handlers = {
            [SteammQuoterType.CONSTANT_PRODUCT]: this.cpmmSwap.bind(this),
            [SteammQuoterType.ORACLE]: this.ommSwap.bind(this),
            [SteammQuoterType.ORACLE_V2]: this.ommV2Swap.bind(this),
        };
    }
    protocol() {
        return Protocol.STEAMM;
    }
}

var Action;
(function (Action) {
    Action[Action["SWAP_COIN_TO_META_COIN"] = 0] = "SWAP_COIN_TO_META_COIN";
    Action[Action["SWAP_META_COIN_TO_COIN"] = 1] = "SWAP_META_COIN_TO_COIN";
    Action[Action["SWAP_COIN_TO_COIN"] = 2] = "SWAP_COIN_TO_COIN";
})(Action || (Action = {}));
class MetastableSwap extends Swap {
    constructor(options) {
        super(options);
        this.mappingMetaCoinType = {};
        this.capacityCapCreators = {};
        this.routers = {};
        this.swapCoinToMetaCoin = (routeObject, pythMap) => (tx) => {
            const capacityCapCreator = this.capacityCapCreators[this.pool.id];
            const metaCoinType = this.mappingMetaCoinType[this.pool.id];
            invariant(capacityCapCreator && metaCoinType, 'invalid meta vault');
            const { wrappedRouterPackageId, versionObjectId } = this.protocolConfig;
            const depositCap = capacityCapCreator.createDepositCap(this.input.coinType, Object.assign(Object.assign({}, this.protocolConfig), { oracles: this.oracles, pythMap }))(tx);
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::swap_exact_coin_to_meta_coin`,
                typeArguments: [metaCoinType, this.input.coinType],
                arguments: [
                    routeObject,
                    tx.object(this.pool.id),
                    tx.object(versionObjectId),
                    depositCap,
                ],
            });
        };
        this.swapMetaCoinToCoin = (routeObject, pythMap) => (tx) => {
            const capacityCapCreator = this.capacityCapCreators[this.pool.id];
            const metaCoinType = this.mappingMetaCoinType[this.pool.id];
            invariant(capacityCapCreator && metaCoinType, 'invalid meta vault');
            const { wrappedRouterPackageId, versionObjectId } = this.protocolConfig;
            const withdrawCap = capacityCapCreator.createWithdrawCap(this.output.coinType, Object.assign(Object.assign({}, this.protocolConfig), { oracles: this.oracles, pythMap }))(tx);
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::swap_exact_meta_coin_to_coin`,
                typeArguments: [metaCoinType, this.output.coinType],
                arguments: [
                    routeObject,
                    tx.object(this.pool.id),
                    tx.object(versionObjectId),
                    withdrawCap,
                ],
            });
        };
        this.swapCoinToCoin = (routeObject, pythMap) => (tx) => {
            var _a;
            const capacityCapCreator = this.capacityCapCreators[this.pool.id];
            const metaCoinType = this.mappingMetaCoinType[this.pool.id];
            invariant(capacityCapCreator && metaCoinType, 'invalid meta vault');
            const { wrappedRouterPackageId, versionObjectId } = this.protocolConfig;
            const depositCap = capacityCapCreator.createDepositCap(this.input.coinType, Object.assign(Object.assign({}, this.protocolConfig), { oracles: this.oracles, pythMap }))(tx);
            const withdrawCap = capacityCapCreator.createWithdrawCap(this.output.coinType, Object.assign(Object.assign({}, this.protocolConfig), { oracles: (_a = this.oracles) === null || _a === void 0 ? void 0 : _a.slice(1), pythMap }))(tx);
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::swap_exact_input`,
                typeArguments: [
                    metaCoinType,
                    this.input.coinType,
                    this.output.coinType,
                ],
                arguments: [
                    routeObject,
                    tx.object(this.pool.id),
                    tx.object(versionObjectId),
                    depositCap,
                    withdrawCap,
                ],
            });
        };
        this.swap = (routeObject, slippage, pythMap) => (tx) => {
            const metaCoinType = this.mappingMetaCoinType[this.pool.id];
            let action;
            if (this.input.coinType !== metaCoinType) {
                action = Action.SWAP_COIN_TO_META_COIN;
            }
            if (this.output.coinType !== metaCoinType) {
                action = isNil(action)
                    ? Action.SWAP_META_COIN_TO_COIN
                    : Action.SWAP_COIN_TO_COIN;
            }
            const router = this.routers[action];
            invariant(router, 'invalid routing');
            router(routeObject, pythMap)(tx);
        };
        const { superSUIVault, mUSDVault, mETHVault } = this.protocolConfig;
        this.mappingMetaCoinType[superSUIVault.vaultId] =
            superSUIVault.metaCoinType;
        this.mappingMetaCoinType[mUSDVault.vaultId] = mUSDVault.metaCoinType;
        this.mappingMetaCoinType[mETHVault.vaultId] = mETHVault.metaCoinType;
        this.capacityCapCreators[superSUIVault.vaultId] =
            new SuperSUICapacityCreator();
        this.capacityCapCreators[mUSDVault.vaultId] = new MUSDCapacityCreator();
        this.capacityCapCreators[mETHVault.vaultId] = new METHCapacityCreator();
        this.routers[Action.SWAP_COIN_TO_META_COIN] =
            this.swapCoinToMetaCoin.bind(this);
        this.routers[Action.SWAP_META_COIN_TO_COIN] =
            this.swapMetaCoinToCoin.bind(this);
        this.routers[Action.SWAP_COIN_TO_COIN] = this.swapCoinToCoin.bind(this);
    }
    protocol() {
        return Protocol.METASTABLE;
    }
}

class MagmaFinanceSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const sqrtPriceX64LimitAdjusted = this.xForY
                ? new Fraction(this.sqrtPriceX64Limit).multiply(new Percent(1).subtract(slippage))
                : new Fraction(this.sqrtPriceX64Limit).multiply(slippage.add(1));
            const { wrappedRouterPackageId, globalConfigObjectId } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [
                    this.xForY ? this.input.coinType : this.output.coinType,
                    this.xForY ? this.output.coinType : this.input.coinType,
                ],
                arguments: [
                    routeObject,
                    tx.object(globalConfigObjectId),
                    tx.object(this.pool.id),
                    tx.pure.u128(this.xForY
                        ? Fraction.max(sqrtPriceX64LimitAdjusted, new Fraction(this.minSqrtPriceX64HasLiquidity)).toFixed(0)
                        : Fraction.min(sqrtPriceX64LimitAdjusted, new Fraction(this.maxSqrtPriceX64HasLiquidity)).toFixed(0)),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
        this.xForY = options.xForY;
        this.sqrtPriceX64Limit = options.sqrtPriceX64Limit;
        this.maxSqrtPriceX64HasLiquidity = options.maxSqrtPriceX64HasLiquidity;
        this.minSqrtPriceX64HasLiquidity = options.minSqrtPriceX64HasLiquidity;
    }
    protocol() {
        return Protocol.MAGMA_FINANCE;
    }
}

class MomentumFinanceSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const sqrtPriceX64LimitAdjusted = this.xForY
                ? new Fraction(this.sqrtPriceX64Limit).multiply(new Percent(1).subtract(slippage))
                : new Fraction(this.sqrtPriceX64Limit).multiply(slippage.add(1));
            const { wrappedRouterPackageId, versionObjectId } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [
                    this.xForY ? this.input.coinType : this.output.coinType,
                    this.xForY ? this.output.coinType : this.input.coinType,
                ],
                arguments: [
                    routeObject,
                    tx.object(this.pool.id),
                    tx.pure.u128(this.xForY
                        ? Fraction.max(sqrtPriceX64LimitAdjusted, new Fraction(this.minSqrtPriceX64HasLiquidity)).toFixed(0)
                        : Fraction.min(sqrtPriceX64LimitAdjusted, new Fraction(this.maxSqrtPriceX64HasLiquidity)).toFixed(0)),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                    tx.object(versionObjectId),
                ],
            });
        };
        this.xForY = options.xForY;
        this.sqrtPriceX64Limit = options.sqrtPriceX64Limit;
        this.maxSqrtPriceX64HasLiquidity = options.maxSqrtPriceX64HasLiquidity;
        this.minSqrtPriceX64HasLiquidity = options.minSqrtPriceX64HasLiquidity;
    }
    protocol() {
        return Protocol.MOMENTUM_FINANCE;
    }
}

class FullSailSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const sqrtPriceX64LimitAdjusted = this.xForY
                ? new Fraction(this.sqrtPriceX64Limit).multiply(new Percent(1).subtract(slippage))
                : new Fraction(this.sqrtPriceX64Limit).multiply(slippage.add(1));
            const { wrappedRouterPackageId, globalConfigObjectId, rewarderGlobalVaultObjectId, statsObjectId, priceProviderObjectId, } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [
                    this.xForY ? this.input.coinType : this.output.coinType,
                    this.xForY ? this.output.coinType : this.input.coinType,
                ],
                arguments: [
                    routeObject,
                    tx.object(globalConfigObjectId),
                    tx.object(rewarderGlobalVaultObjectId),
                    tx.object(this.pool.id),
                    tx.object(statsObjectId),
                    tx.object(priceProviderObjectId),
                    tx.pure.u128(this.xForY
                        ? Fraction.max(sqrtPriceX64LimitAdjusted, new Fraction(this.minSqrtPriceX64HasLiquidity)).toFixed(0)
                        : Fraction.min(sqrtPriceX64LimitAdjusted, new Fraction(this.maxSqrtPriceX64HasLiquidity)).toFixed(0)),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
        this.xForY = options.xForY;
        this.sqrtPriceX64Limit = options.sqrtPriceX64Limit;
        this.maxSqrtPriceX64HasLiquidity = options.maxSqrtPriceX64HasLiquidity;
        this.minSqrtPriceX64HasLiquidity = options.minSqrtPriceX64HasLiquidity;
    }
    protocol() {
        return Protocol.FULL_SAIL;
    }
}

class SevenKV1DexSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, _, pythMap) => (tx) => {
            const { wrappedRouterPackageId, oraclePackageId } = this.protocolConfig;
            const oracleHolder = tx.moveCall({
                target: `${oraclePackageId}::oracle::new_holder`,
            });
            const [oracleInfoX, oracleInfoY] = this.oracles || [];
            invariant(oracleInfoX && oracleInfoX.oracleId && oracleInfoX.priceId, 'Oracle info for X is required');
            invariant(oracleInfoY && oracleInfoY.oracleId && oracleInfoY.priceId, 'Oracle info for Y is required');
            const [priceObjectIdX, priceObjectIdY] = [
                pythMap[oracleInfoX === null || oracleInfoX === void 0 ? void 0 : oracleInfoX.priceId],
                pythMap[oracleInfoY === null || oracleInfoY === void 0 ? void 0 : oracleInfoY.priceId],
            ];
            invariant(priceObjectIdX, `Price object for ${oracleInfoX.priceId} is required`);
            invariant(priceObjectIdY, `Price object for ${oracleInfoY.priceId} is required`);
            tx.moveCall({
                target: `${oraclePackageId}::pyth::get_price`,
                arguments: [
                    tx.object(oracleInfoX.oracleId),
                    oracleHolder,
                    tx.object(priceObjectIdX),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
            tx.moveCall({
                target: `${oraclePackageId}::pyth::get_price`,
                arguments: [
                    tx.object(oracleInfoY.oracleId),
                    oracleHolder,
                    tx.object(priceObjectIdY),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
            const poolTypeArgs = parseStructTag(this.poolStructTag).typeParams.map(normalizeStructTag$1);
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: poolTypeArgs,
                arguments: [routeObject, tx.object(this.pool.id), oracleHolder],
            });
        };
        this.xForY = options.xForY;
        this.poolStructTag = options.poolStructTag;
    }
    protocol() {
        return Protocol.SEVENK_V1;
    }
}

class IpxTideSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage, pythMap) => (tx) => {
            var _a, _b, _c, _d;
            const { wrappedRouterPackageId } = this.protocolConfig;
            const [priceFeedObjectIdX, priceFeedObjectIdY] = [
                ((_b = (_a = this.oracles) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.priceId)
                    ? pythMap[this.oracles[0].priceId]
                    : undefined,
                ((_d = (_c = this.oracles) === null || _c === void 0 ? void 0 : _c[1]) === null || _d === void 0 ? void 0 : _d.priceId)
                    ? pythMap[this.oracles[1].priceId]
                    : undefined,
            ];
            invariant(priceFeedObjectIdX && priceFeedObjectIdY, 'Price feed object IDs must be defined for both coins');
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::swap_exact`,
                typeArguments: [this.input.coinType, this.output.coinType],
                arguments: [
                    routeObject,
                    tx.object(this.pool.id),
                    tx.object(priceFeedObjectIdX),
                    tx.object(priceFeedObjectIdY),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
    }
    protocol() {
        return Protocol.IPX_TIDE;
    }
}

class TradeportSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const sqrtPriceX64LimitAdjusted = this.xForY
                ? new Fraction(this.sqrtPriceX64Limit).multiply(new Percent(1).subtract(slippage))
                : new Fraction(this.sqrtPriceX64Limit).multiply(slippage.add(1));
            const { wrappedRouterPackageId, poolRegistryObjectId, versionedObjectId, } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::swap_exact_input`,
                typeArguments: [this.input.coinType, this.output.coinType],
                arguments: [
                    routeObject,
                    tx.object(poolRegistryObjectId),
                    tx.pure.u64(this.poolFee.toString()),
                    tx.pure.u128(this.xForY
                        ? Fraction.max(sqrtPriceX64LimitAdjusted, new Fraction(this.minSqrtPriceX64HasLiquidity)).toFixed(0)
                        : Fraction.min(sqrtPriceX64LimitAdjusted, new Fraction(this.maxSqrtPriceX64HasLiquidity)).toFixed(0)),
                    tx.object(versionedObjectId),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
        this.xForY = options.xForY;
        this.poolFee = options.poolFee;
        this.sqrtPriceX64Limit = options.sqrtPriceX64Limit;
        this.maxSqrtPriceX64HasLiquidity = options.maxSqrtPriceX64HasLiquidity;
        this.minSqrtPriceX64HasLiquidity = options.minSqrtPriceX64HasLiquidity;
    }
    protocol() {
        return Protocol.TRADEPORT;
    }
}

class DipCoinDexSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const { wrappedRouterPackageId, globalObjectId } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [
                    this.xForY ? this.input.coinType : this.output.coinType,
                    this.xForY ? this.output.coinType : this.input.coinType,
                ],
                arguments: [
                    routeObject,
                    tx.object(globalObjectId),
                    tx.object(this.pool.id),
                ],
            });
        };
        this.xForY = options.xForY;
    }
    protocol() {
        return Protocol.DIPCOIN;
    }
}

class CetusDlmmSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject) => (tx) => {
            const { wrappedRouterPackageId, globalConfigObjectId, versionedObjectId, } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [
                    this.xForY ? this.input.coinType : this.output.coinType,
                    this.xForY ? this.output.coinType : this.input.coinType,
                ],
                arguments: [
                    routeObject,
                    tx.object(this.pool.id),
                    tx.object(globalConfigObjectId),
                    tx.object(versionedObjectId),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
        this.xForY = options.xForY;
    }
    protocol() {
        return Protocol.CETUS_DLMM;
    }
}

class FerraClmmSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const sqrtPriceX64LimitAdjusted = this.xForY
                ? new Fraction(this.sqrtPriceX64Limit).multiply(new Percent(1).subtract(slippage))
                : new Fraction(this.sqrtPriceX64Limit).multiply(slippage.add(1));
            const { wrappedRouterPackageId, globalConfigObjectId } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [
                    this.xForY ? this.input.coinType : this.output.coinType,
                    this.xForY ? this.output.coinType : this.input.coinType,
                ],
                arguments: [
                    routeObject,
                    tx.object(globalConfigObjectId),
                    tx.object(this.pool.id),
                    tx.pure.u128(this.xForY
                        ? Fraction.max(sqrtPriceX64LimitAdjusted, new Fraction(this.minSqrtPriceX64HasLiquidity)).toFixed(0)
                        : Fraction.min(sqrtPriceX64LimitAdjusted, new Fraction(this.maxSqrtPriceX64HasLiquidity)).toFixed(0)),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
        this.xForY = options.xForY;
        this.sqrtPriceX64Limit = options.sqrtPriceX64Limit;
        this.maxSqrtPriceX64HasLiquidity = options.maxSqrtPriceX64HasLiquidity;
        this.minSqrtPriceX64HasLiquidity = options.minSqrtPriceX64HasLiquidity;
    }
    protocol() {
        return Protocol.FERRA_CLMM;
    }
}

class FerraDlmmSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject) => (tx) => {
            const { wrappedRouterPackageId, globalConfigObjectId } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [
                    this.xForY ? this.input.coinType : this.output.coinType,
                    this.xForY ? this.output.coinType : this.input.coinType,
                ],
                arguments: [
                    routeObject,
                    tx.object(globalConfigObjectId),
                    tx.object(this.pool.id),
                    tx.object(SUI_CLOCK_OBJECT_ID$1),
                ],
            });
        };
        this.xForY = options.xForY;
    }
    protocol() {
        return Protocol.FERRA_DLMM;
    }
}

class MagmaAlmmSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject) => (tx) => {
            const { wrappedRouterPackageId, globalConfigObjectId, factoryConfigObjectId, } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [
                    this.xForY ? this.input.coinType : this.output.coinType,
                    this.xForY ? this.output.coinType : this.input.coinType,
                ],
                arguments: [
                    routeObject,
                    tx.object(this.pool.id),
                    tx.object(factoryConfigObjectId),
                    tx.object(globalConfigObjectId),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
        this.xForY = options.xForY;
    }
    protocol() {
        return Protocol.MAGMA_ALMM;
    }
}

class SuiRewardsMeSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject, slippage) => (tx) => {
            const { wrappedRouterPackageId, configObjectId } = this.protocolConfig;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [
                    this.xForY ? this.input.coinType : this.output.coinType,
                    this.xForY ? this.output.coinType : this.input.coinType,
                ],
                arguments: [
                    routeObject,
                    tx.object(configObjectId),
                    tx.object(this.pool.id),
                    tx.object('0x6'),
                ],
            });
        };
        this.xForY = options.xForY;
    }
    protocol() {
        return Protocol.SUI_REWARDS;
    }
}

class BoltSwap extends Swap {
    constructor(options) {
        super(options);
        this.swap = (routeObject) => (tx) => {
            var _a, _b;
            const { wrappedRouterPackageId } = this.protocolConfig;
            const oraclePriceId = (_b = (_a = this.oracles) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.priceId;
            tx.moveCall({
                target: `${wrappedRouterPackageId}::swap_router::${this.xForY ? 'swap_exact_x_to_y' : 'swap_exact_y_to_x'}`,
                typeArguments: [
                    this.xForY ? this.input.coinType : this.output.coinType,
                    this.xForY ? this.output.coinType : this.input.coinType,
                ],
                arguments: [
                    routeObject,
                    tx.object(this.pool.id),
                    tx.object(oraclePriceId),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        };
        this.xForY = options.xForY;
    }
    protocol() {
        return Protocol.BOLT;
    }
}

const AGGREGATOR_BPS = 10000;
class AggregatorQuoter {
    constructor(network, apiKey) {
        this.network = network;
        this.apiKey = apiKey;
    }
    buildPath(path, protocolConfig) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8;
        switch (path.source) {
            case Protocol.FLOWX_V2:
                return new FlowxV2Swap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    protocolConfig,
                });
            case Protocol.FLOWX_V3: {
                const extra = path.extra;
                const [minSqrtPriceX64HasLiquidity, maxSqrtPriceX64HasLiquidity] = [
                    new BN$1(((_a = extra.minSqrtPriceHasLiquidity) === null || _a === void 0 ? void 0 : _a.toString()) ||
                        ClmmTickMath.MIN_SQRT_RATIO),
                    new BN$1(((_b = extra.maxSqrtPriceHasLiquidity) === null || _b === void 0 ? void 0 : _b.toString()) ||
                        ClmmTickMath.MAX_SQRT_RATIO),
                ];
                return new FlowxV3Swap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!extra.swapXToY,
                    poolFee: extra.fee || '0',
                    sqrtPriceX64Limit: ((_c = extra.nextStateSqrtRatioX64) === null || _c === void 0 ? void 0 : _c.toString()) || '0',
                    maxSqrtPriceX64HasLiquidity: minBn(ClmmTickMath.MAX_SQRT_RATIO.sub(ONE), maxSqrtPriceX64HasLiquidity),
                    minSqrtPriceX64HasLiquidity: maxBn(ClmmTickMath.MIN_SQRT_RATIO.add(ONE), minSqrtPriceX64HasLiquidity),
                    protocolConfig,
                });
            }
            case Protocol.AFTERMATH: {
                const extra = path.extra;
                return new AftermathSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    lpCoinType: extra.lpCoinType || '',
                    protocolConfig,
                });
            }
            case Protocol.CETUS: {
                const extra = path.extra;
                const [minSqrtPriceX64HasLiquidity, maxSqrtPriceX64HasLiquidity] = [
                    new BN$1(((_d = extra.minSqrtPriceHasLiquidity) === null || _d === void 0 ? void 0 : _d.toString()) ||
                        ClmmTickMath.MIN_SQRT_RATIO),
                    new BN$1(((_e = extra.maxSqrtPriceHasLiquidity) === null || _e === void 0 ? void 0 : _e.toString()) ||
                        ClmmTickMath.MAX_SQRT_RATIO),
                ];
                return new CetusSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!extra.swapXToY,
                    sqrtPriceX64Limit: ((_f = extra.nextStateSqrtRatioX64) === null || _f === void 0 ? void 0 : _f.toString()) || '0',
                    maxSqrtPriceX64HasLiquidity: minBn(ClmmTickMath.MAX_SQRT_RATIO.sub(ONE), maxSqrtPriceX64HasLiquidity),
                    minSqrtPriceX64HasLiquidity: maxBn(ClmmTickMath.MIN_SQRT_RATIO.add(ONE), minSqrtPriceX64HasLiquidity),
                    protocolConfig,
                });
            }
            case Protocol.DEEPBOOK: {
                const extra = path.extra;
                return new DeepbookSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!extra.swapXToY,
                    lotSize: extra.lotSize || '0',
                    protocolConfig,
                });
            }
            case Protocol.KRIYA_DEX:
                return new KriyaDexSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!path.extra.swapXToY,
                    protocolConfig,
                });
            case Protocol.TURBOS_FIANCE: {
                const extra = path.extra;
                const [minSqrtPriceX64HasLiquidity, maxSqrtPriceX64HasLiquidity] = [
                    new BN$1(((_g = extra.minSqrtPriceHasLiquidity) === null || _g === void 0 ? void 0 : _g.toString()) ||
                        ClmmTickMath.MIN_SQRT_RATIO),
                    new BN$1(((_h = extra.maxSqrtPriceHasLiquidity) === null || _h === void 0 ? void 0 : _h.toString()) ||
                        ClmmTickMath.MAX_SQRT_RATIO),
                ];
                return new TurbosSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!extra.swapXToY,
                    sqrtPriceX64Limit: ((_j = extra.nextStateSqrtRatioX64) === null || _j === void 0 ? void 0 : _j.toString()) || '0',
                    maxSqrtPriceX64HasLiquidity: minBn(ClmmTickMath.MAX_SQRT_RATIO.sub(ONE), maxSqrtPriceX64HasLiquidity),
                    minSqrtPriceX64HasLiquidity: maxBn(ClmmTickMath.MIN_SQRT_RATIO.add(ONE), minSqrtPriceX64HasLiquidity),
                    poolStructTag: extra.poolStructTag,
                    protocolConfig,
                });
            }
            case Protocol.KRIYA_V3: {
                const extra = path.extra;
                const [minSqrtPriceX64HasLiquidity, maxSqrtPriceX64HasLiquidity] = [
                    new BN$1(((_k = extra.minSqrtPriceHasLiquidity) === null || _k === void 0 ? void 0 : _k.toString()) ||
                        ClmmTickMath.MIN_SQRT_RATIO),
                    new BN$1(((_l = extra.maxSqrtPriceHasLiquidity) === null || _l === void 0 ? void 0 : _l.toString()) ||
                        ClmmTickMath.MAX_SQRT_RATIO),
                ];
                return new KriyaV3Swap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!extra.swapXToY,
                    sqrtPriceX64Limit: ((_m = extra.nextStateSqrtRatioX64) === null || _m === void 0 ? void 0 : _m.toString()) || '0',
                    maxSqrtPriceX64HasLiquidity: minBn(ClmmTickMath.MAX_SQRT_RATIO.sub(ONE), maxSqrtPriceX64HasLiquidity),
                    minSqrtPriceX64HasLiquidity: maxBn(ClmmTickMath.MIN_SQRT_RATIO.add(ONE), minSqrtPriceX64HasLiquidity),
                    protocolConfig,
                });
            }
            case Protocol.DEEPBOOK_V3: {
                const extra = path.extra;
                return new DeepbookV3Swap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!extra.swapXToY,
                    deepFeeAmount: extra.deepFee || '0',
                    protocolConfig,
                });
            }
            case Protocol.BLUEMOVE:
                return new BluemoveSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    protocolConfig,
                });
            case Protocol.BLUEFIN: {
                const extra = path.extra;
                const [minSqrtPriceX64HasLiquidity, maxSqrtPriceX64HasLiquidity] = [
                    new BN$1(((_o = extra.minSqrtPriceHasLiquidity) === null || _o === void 0 ? void 0 : _o.toString()) ||
                        ClmmTickMath.MIN_SQRT_RATIO),
                    new BN$1(((_p = extra.maxSqrtPriceHasLiquidity) === null || _p === void 0 ? void 0 : _p.toString()) ||
                        ClmmTickMath.MAX_SQRT_RATIO),
                ];
                return new BluefinSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!extra.swapXToY,
                    sqrtPriceX64Limit: ((_q = extra.nextStateSqrtRatioX64) === null || _q === void 0 ? void 0 : _q.toString()) || '0',
                    maxSqrtPriceX64HasLiquidity: minBn(ClmmTickMath.MAX_SQRT_RATIO.sub(ONE), maxSqrtPriceX64HasLiquidity),
                    minSqrtPriceX64HasLiquidity: maxBn(ClmmTickMath.MIN_SQRT_RATIO.add(ONE), minSqrtPriceX64HasLiquidity),
                    protocolConfig,
                });
            }
            case Protocol.FLOWX_PMM: {
                const extra = path.extra;
                return new FlowxPmmSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: path.extra.swapXToY,
                    signatures: extra.signatures,
                    swapTimestampMs: extra.swapTimestampMs,
                    protocolConfig,
                });
            }
            case Protocol.BLUEMOVE_FUN:
                return new BlueMoveFunSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!((_r = path.extra) === null || _r === void 0 ? void 0 : _r.swapXToY),
                    protocolConfig,
                });
            case Protocol.HOP_FUN:
                return new HopFunSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!path.extra.swapXToY,
                    protocolConfig,
                });
            case Protocol.SEVEN_K_FUN:
                return new SevenKFunSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!path.extra.swapXToY,
                    protocolConfig,
                });
            case Protocol.TURBOS_FUN:
                return new TurbosFunSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!path.extra.swapXToY,
                    protocolConfig,
                });
            case Protocol.OBRIC: {
                const extra = path.extra;
                return new ObricSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!extra.swapXToY,
                    xPriceId: (_s = extra.xPriceId) !== null && _s !== void 0 ? _s : '',
                    yPriceId: (_t = extra.yPriceId) !== null && _t !== void 0 ? _t : '',
                    protocolConfig,
                });
            }
            case Protocol.HAEDAL_PMM: {
                const extra = path.extra;
                return new HaedalPMMSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!extra.swapXToY,
                    oracles: extra.oracles,
                    protocolConfig,
                });
            }
            case Protocol.HAEDAL:
                return new HaedalSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!path.extra.swapXToY,
                    protocolConfig,
                });
            case Protocol.SPRING_SUI:
                return new SpringSuiSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!path.extra.swapXToY,
                    protocolConfig,
                });
            case Protocol.ALPHA_FI:
                return new AlphaFiSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!path.extra.swapXToY,
                    protocolConfig,
                });
            case Protocol.VOLO_LSD:
                return new VoloLsdSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!path.extra.swapXToY,
                    protocolConfig,
                });
            case Protocol.AFTERMATH_LSD:
                return new AftermathLsdSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!path.extra.swapXToY,
                    protocolConfig,
                });
            case Protocol.STEAMM: {
                const extra = path.extra;
                return new SteammSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!extra.swapXToY,
                    quoterType: extra.quoterType,
                    oracles: extra.oracles,
                    bankX: extra.bankX,
                    bankY: extra.bankY,
                    bankXStructTag: extra.bankXStructTag,
                    bankYStructTag: extra.bankYStructTag,
                    lendingMarketX: extra.lendingMarketX,
                    lendingMarketY: extra.lendingMarketY,
                    poolStructTag: extra.poolStructTag,
                    protocolConfig,
                });
            }
            case Protocol.METASTABLE: {
                const extra = path.extra;
                return new MetastableSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    oracles: extra.oracles,
                    protocolConfig,
                });
            }
            case Protocol.MAGMA_FINANCE: {
                const extra = path.extra;
                const [minSqrtPriceX64HasLiquidity, maxSqrtPriceX64HasLiquidity] = [
                    new BN$1(((_u = extra.minSqrtPriceHasLiquidity) === null || _u === void 0 ? void 0 : _u.toString()) ||
                        ClmmTickMath.MIN_SQRT_RATIO),
                    new BN$1(((_v = extra.maxSqrtPriceHasLiquidity) === null || _v === void 0 ? void 0 : _v.toString()) ||
                        ClmmTickMath.MAX_SQRT_RATIO),
                ];
                return new MagmaFinanceSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!extra.swapXToY,
                    sqrtPriceX64Limit: ((_w = extra.nextStateSqrtRatioX64) === null || _w === void 0 ? void 0 : _w.toString()) || '0',
                    maxSqrtPriceX64HasLiquidity: minBn(ClmmTickMath.MAX_SQRT_RATIO.sub(ONE), maxSqrtPriceX64HasLiquidity),
                    minSqrtPriceX64HasLiquidity: maxBn(ClmmTickMath.MIN_SQRT_RATIO.add(ONE), minSqrtPriceX64HasLiquidity),
                    protocolConfig,
                });
            }
            case Protocol.MOMENTUM_FINANCE: {
                const extra = path.extra;
                const [minSqrtPriceX64HasLiquidity, maxSqrtPriceX64HasLiquidity] = [
                    new BN$1(((_x = extra.minSqrtPriceHasLiquidity) === null || _x === void 0 ? void 0 : _x.toString()) ||
                        ClmmTickMath.MIN_SQRT_RATIO),
                    new BN$1(((_y = extra.maxSqrtPriceHasLiquidity) === null || _y === void 0 ? void 0 : _y.toString()) ||
                        ClmmTickMath.MAX_SQRT_RATIO),
                ];
                return new MomentumFinanceSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!extra.swapXToY,
                    sqrtPriceX64Limit: ((_z = extra.nextStateSqrtRatioX64) === null || _z === void 0 ? void 0 : _z.toString()) || '0',
                    maxSqrtPriceX64HasLiquidity: minBn(ClmmTickMath.MAX_SQRT_RATIO.sub(ONE), maxSqrtPriceX64HasLiquidity),
                    minSqrtPriceX64HasLiquidity: maxBn(ClmmTickMath.MIN_SQRT_RATIO.add(ONE), minSqrtPriceX64HasLiquidity),
                    protocolConfig,
                });
            }
            case Protocol.FULL_SAIL: {
                const extra = path.extra;
                const [minSqrtPriceX64HasLiquidity, maxSqrtPriceX64HasLiquidity] = [
                    new BN$1(((_0 = extra.minSqrtPriceHasLiquidity) === null || _0 === void 0 ? void 0 : _0.toString()) ||
                        ClmmTickMath.MIN_SQRT_RATIO),
                    new BN$1(((_1 = extra.maxSqrtPriceHasLiquidity) === null || _1 === void 0 ? void 0 : _1.toString()) ||
                        ClmmTickMath.MAX_SQRT_RATIO),
                ];
                return new FullSailSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!extra.swapXToY,
                    sqrtPriceX64Limit: ((_2 = extra.nextStateSqrtRatioX64) === null || _2 === void 0 ? void 0 : _2.toString()) || '0',
                    maxSqrtPriceX64HasLiquidity: minBn(ClmmTickMath.MAX_SQRT_RATIO.sub(ONE), maxSqrtPriceX64HasLiquidity),
                    minSqrtPriceX64HasLiquidity: maxBn(ClmmTickMath.MIN_SQRT_RATIO.add(ONE), minSqrtPriceX64HasLiquidity),
                    protocolConfig,
                });
            }
            case Protocol.SEVENK_V1: {
                const extra = path.extra;
                return new SevenKV1DexSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!extra.swapXToY,
                    oracles: extra.oracles,
                    poolStructTag: extra.poolStructTag,
                    protocolConfig,
                });
            }
            case Protocol.IPX_TIDE: {
                const extra = path.extra;
                return new IpxTideSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    oracles: extra.oracles,
                    protocolConfig,
                });
            }
            case Protocol.TRADEPORT: {
                const extra = path.extra;
                const [minSqrtPriceX64HasLiquidity, maxSqrtPriceX64HasLiquidity] = [
                    new BN$1(((_3 = extra.minSqrtPriceHasLiquidity) === null || _3 === void 0 ? void 0 : _3.toString()) ||
                        ClmmTickMath.MIN_SQRT_RATIO),
                    new BN$1(((_4 = extra.maxSqrtPriceHasLiquidity) === null || _4 === void 0 ? void 0 : _4.toString()) ||
                        ClmmTickMath.MAX_SQRT_RATIO),
                ];
                return new TradeportSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!extra.swapXToY,
                    poolFee: extra.fee || '0',
                    sqrtPriceX64Limit: ((_5 = extra.nextStateSqrtRatioX64) === null || _5 === void 0 ? void 0 : _5.toString()) || '0',
                    maxSqrtPriceX64HasLiquidity: minBn(ClmmTickMath.MAX_SQRT_RATIO.sub(ONE), maxSqrtPriceX64HasLiquidity),
                    minSqrtPriceX64HasLiquidity: maxBn(ClmmTickMath.MIN_SQRT_RATIO.add(ONE), minSqrtPriceX64HasLiquidity),
                    protocolConfig,
                });
            }
            case Protocol.DIPCOIN: {
                return new DipCoinDexSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!path.extra.swapXToY,
                    protocolConfig,
                });
            }
            case Protocol.FERRA_DLMM: {
                return new FerraDlmmSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!path.extra.swapXToY,
                    protocolConfig,
                });
            }
            case Protocol.FERRA_CLMM: {
                const extra = path.extra;
                const [minSqrtPriceX64HasLiquidity, maxSqrtPriceX64HasLiquidity] = [
                    new BN$1(((_6 = extra.minSqrtPriceHasLiquidity) === null || _6 === void 0 ? void 0 : _6.toString()) ||
                        ClmmTickMath.MIN_SQRT_RATIO),
                    new BN$1(((_7 = extra.maxSqrtPriceHasLiquidity) === null || _7 === void 0 ? void 0 : _7.toString()) ||
                        ClmmTickMath.MAX_SQRT_RATIO),
                ];
                return new FerraClmmSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!extra.swapXToY,
                    sqrtPriceX64Limit: ((_8 = extra.nextStateSqrtRatioX64) === null || _8 === void 0 ? void 0 : _8.toString()) || '0',
                    maxSqrtPriceX64HasLiquidity: minBn(ClmmTickMath.MAX_SQRT_RATIO.sub(ONE), maxSqrtPriceX64HasLiquidity),
                    minSqrtPriceX64HasLiquidity: maxBn(ClmmTickMath.MIN_SQRT_RATIO.add(ONE), minSqrtPriceX64HasLiquidity),
                    protocolConfig,
                });
            }
            case Protocol.MAGMA_ALMM: {
                return new MagmaAlmmSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: path.extra.swapXToY,
                    protocolConfig,
                });
            }
            case Protocol.SUI_REWARDS:
                return new SuiRewardsMeSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: !!path.extra.swapXToY,
                    protocolConfig,
                });
            case Protocol.CETUS_DLMM: {
                return new CetusDlmmSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: path.extra.swapXToY,
                    protocolConfig,
                });
            }
            case Protocol.BOLT: {
                const extra = path.extra;
                return new BoltSwap({
                    network: this.network,
                    pool: new ObjectId(path.poolId),
                    input: new Coin(path.tokenIn),
                    output: new Coin(path.tokenOut),
                    amountIn: path.amountIn.toString(),
                    amountOut: path.amountOut.toString(),
                    xForY: path.extra.swapXToY,
                    oracles: extra.oracles,
                    protocolConfig,
                });
            }
            default:
                throw new Error(`${path.source} protocol not supported yet`);
        }
    }
    fromRawQuote(rawQuote) {
        const priceImpact = new BigNumber(rawQuote.priceImpact)
            .multipliedBy(BPS$2.toString())
            .div(100)
            .toFixed(0);
        return {
            rawQuote: rawQuote,
            coinIn: new Coin(rawQuote.tokenIn),
            coinOut: new Coin(rawQuote.tokenOut),
            amountIn: rawQuote.amountIn,
            amountOut: rawQuote.amountOut,
            priceImpact: new Percent(priceImpact, BPS$2),
            routes: rawQuote.paths.map((paths) => new Route(this.network, paths.map((path) => this.buildPath(path, rawQuote.protocolConfig[path.source.toLowerCase()])))),
        };
    }
    getRoutes(params) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            const coinIn = new Coin(params.tokenIn);
            const coinOut = new Coin(params.tokenOut);
            const sources = params.includeSources || Object.values(Protocol);
            const excludeSources = (_a = params.excludeSources) !== null && _a !== void 0 ? _a : [Protocol.FLOWX_PMM];
            const queryParams = {
                apiKey: this.apiKey,
                tokenIn: coinIn.coinType,
                tokenOut: coinOut.coinType,
                amountIn: params.amountIn,
                includeSources: sources.join(','),
                excludeSources: excludeSources.join(','),
                excludePools: (_b = params.excludePools) === null || _b === void 0 ? void 0 : _b.map((pool) => normalizeSuiObjectId(pool)).join(','),
                maxHops: (_c = params.maxHops) !== null && _c !== void 0 ? _c : 0,
                splitDistributionPercent: (_d = params.splitDistributionPercent) !== null && _d !== void 0 ? _d : 0,
            };
            if (params.commission &&
                (params.commission.coin.equals(coinIn) ||
                    params.commission.coin.equals(coinOut))) {
                queryParams['feeToken'] = params.commission.coin.coinType;
                if (params.commission.type === CommissionType.PERCENTAGE) {
                    queryParams['feeInBps'] = new BN$1(params.commission.value)
                        .mul(new BN$1(AGGREGATOR_BPS))
                        .div(BPS$2)
                        .toString();
                }
                else {
                    queryParams['feeAmount'] = params.commission.value.toString();
                }
            }
            const resp = yield fetch(`${CONFIGS$5[this.network].quoter.singleQuoteURI}?` +
                new URLSearchParams(removeEmptyFields(queryParams)).toString(), {
                method: 'GET',
                signal: AbortSignal.timeout(CONFIGS$5[this.network].quoter.requestTimeout),
                keepalive: true,
            });
            const rawResp = yield resp.text();
            invariant(resp.ok, rawResp);
            try {
                const quoteResponse = JsonBigInt.parse(rawResp);
                invariant(quoteResponse.code === 0, quoteResponse.message);
                return this.fromRawQuote(quoteResponse.data);
            }
            catch (error) {
                throw new Error(`Get quote failed due to error ${error.message}`);
            }
        });
    }
    batchQuote(params) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            invariant(params.amountIns.length > 0, 'AMOUNT_INS');
            invariant(params.amountIns.length === params.amountExpectedOuts.length, 'LENGTH_MISMATCH');
            const coinIn = new Coin(params.tokenIn);
            const coinOut = new Coin(params.tokenOut);
            const reqBody = {
                tokenIn: coinIn.coinType,
                tokenOut: coinOut.coinType,
                amountIns: params.amountIns,
                amountExpectedOuts: params.amountExpectedOuts,
                includeSources: (_a = params.includeSources) === null || _a === void 0 ? void 0 : _a.join(','),
                excludeSources: (_b = params.excludeSources) === null || _b === void 0 ? void 0 : _b.join(','),
            };
            const resp = yield fetch(`${CONFIGS$5[this.network].quoter.batchQuoteURI}?apiKey=${this.apiKey}`, {
                method: 'POST',
                signal: AbortSignal.timeout(CONFIGS$5[this.network].quoter.requestTimeout),
                body: JSON.stringify(removeEmptyFields(reqBody)),
                headers: {
                    'Content-Type': 'application/json',
                },
            });
            const batchQuoteResponse = JsonBigInt.parse(yield resp.text());
            invariant(batchQuoteResponse.code === 0, batchQuoteResponse.message);
            const priceImpact = new BigNumber(batchQuoteResponse.data.priceImpact)
                .multipliedBy(BPS$2.toString())
                .div(100)
                .toFixed(0);
            return {
                coinIn,
                coinOut,
                amountIn: batchQuoteResponse.data.amountIn,
                amountOut: batchQuoteResponse.data.amountOut,
                priceImpact: new Percent(priceImpact, BPS$2),
                routes: batchQuoteResponse.data.paths.map((paths) => new Route(this.network, paths.map((path) => this.buildPath(path, batchQuoteResponse.data.protocolConfig[path.source.toLowerCase()])))),
            };
        });
    }
    getMultipleRoutes(params, externalSignal) {
        return __awaiter(this, void 0, void 0, function* () {
            invariant(params.length > 0, 'PARAMS_EMPTY');
            invariant(params.every((p) => p.tokenIn &&
                p.tokenOut &&
                p.amountIn &&
                p.includeSources &&
                p.includeSources.length > 0), 'INVALID_PARAMS');
            const requestBody = params.map((p) => {
                var _a, _b, _c, _d, _e;
                const coinIn = new Coin(p.tokenIn);
                const coinOut = new Coin(p.tokenOut);
                const r = {
                    tokenIn: normalizeStructTag$1(p.tokenIn),
                    tokenOut: normalizeStructTag$1(p.tokenOut),
                    amountIn: p.amountIn,
                    includeSources: ((_a = p.includeSources) === null || _a === void 0 ? void 0 : _a.join(',')) || '',
                    excludeSources: ((_b = p.excludeSources) === null || _b === void 0 ? void 0 : _b.join(',')) || '',
                    excludePools: ((_c = p.excludePools) === null || _c === void 0 ? void 0 : _c.map((pool) => normalizeSuiObjectId(pool)).join(',')) ||
                        '',
                    maxHops: (_d = p.maxHops) !== null && _d !== void 0 ? _d : 0,
                    splitDistributionPercent: (_e = p.splitDistributionPercent) !== null && _e !== void 0 ? _e : 0,
                };
                if (p.commission &&
                    (p.commission.coin.equals(coinIn) || p.commission.coin.equals(coinOut))) {
                    r['feeToken'] = p.commission.coin.coinType;
                    if (p.commission.type === CommissionType.PERCENTAGE) {
                        r['feeInBps'] = new BN$1(p.commission.value)
                            .mul(new BN$1(AGGREGATOR_BPS))
                            .div(BPS$2)
                            .toNumber();
                    }
                    else {
                        r['feeAmount'] = p.commission.value.toString();
                    }
                }
                return r;
            });
            const resp = yield fetch(`${CONFIGS$5[this.network].quoter.multipleQuotesURI}`, {
                method: 'POST',
                signal: externalSignal !== null && externalSignal !== void 0 ? externalSignal : AbortSignal.timeout(CONFIGS$5[this.network].quoter.requestTimeout),
                body: JSON.stringify(requestBody),
                headers: {
                    'Content-Type': 'application/json',
                },
            });
            const rawResp = JsonBigInt.parse(yield resp.text());
            invariant(rawResp.code === 0, rawResp.message);
            return rawResp.data.response.map((data) => {
                data.protocolConfig = rawResp.data.protocolConfig;
                return this.fromRawQuote(data);
            });
        });
    }
}

class PartnerManager {
    constructor({ network, client }) {
        this.mappingPartnerBalancesParentId = {};
        this.withdrawCommissions = ({ address, coins, recipient }) => (...args_1) => __awaiter(this, [...args_1], void 0, function* (tx = new Transaction()) {
            const commissionAmounts = yield this.getCommissionAmounts({
                address,
                coins,
            });
            if (commissionAmounts.length > 0) {
                const { packageId, partnerRegistryObjectId, versionedObjectId } = CONFIGS$5[this.network];
                commissionAmounts.forEach((commissionAmount) => {
                    tx.moveCall({
                        target: `${packageId}::partner_manager::withdraw`,
                        typeArguments: [commissionAmount.coin.coinType],
                        arguments: [
                            tx.object(partnerRegistryObjectId),
                            tx.pure.u64(commissionAmount.quotient.toString()),
                            tx.pure.address(recipient),
                            tx.object(versionedObjectId),
                        ],
                    });
                });
            }
            return tx;
        });
        this.network = network;
        this.client =
            client !== null && client !== void 0 ? client : new SuiClient({
                url: getFullnodeUrl(network),
            });
    }
    getPartnersBalanceParentId(address) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.partnersParentId) {
                const partnerRegistryObjectId = CONFIGS$5[this.network].partnerRegistryObjectId;
                const partnerRegistryObject = yield this.client.getObject({
                    id: partnerRegistryObjectId,
                    options: {
                        showType: true,
                        showContent: true,
                    },
                });
                invariant(!partnerRegistryObject.error, `PartnerRegistry object not found with ID=${partnerRegistryObjectId}`);
                this.partnersParentId =
                    partnerRegistryObject.data.content.fields.partners.fields.id.id;
            }
            if (!this.mappingPartnerBalancesParentId[address]) {
                const df = yield this.client.getDynamicFieldObject({
                    parentId: this.partnersParentId,
                    name: {
                        type: 'address',
                        value: address,
                    },
                });
                if (!df.error) {
                    this.mappingPartnerBalancesParentId[address] =
                        df.data.content.fields.value.fields.balances.fields.id.id;
                }
            }
            return this.mappingPartnerBalancesParentId[address];
        });
    }
    getCommissionAmounts(_a) {
        return __awaiter(this, arguments, void 0, function* ({ address, coins }) {
            const isAll = isNil(coins);
            const partnerBalancesParentId = yield this.getPartnersBalanceParentId(address);
            if (!partnerBalancesParentId) {
                return [];
            }
            if (isAll) {
                const dfs = yield getAllDynamicFields(partnerBalancesParentId, this.client);
                const dfObjectIds = dfs.map((df) => df.objectId);
                const dfObjects = yield multiGetObjects(this.client, dfObjectIds, {
                    showType: true,
                    showContent: true,
                });
                return dfObjects
                    .filter((df) => df.content.fields.value != '0')
                    .map((df) => CoinAmount.fromRawAmount(new Coin(normalizeStructTag$1(df.content.fields.name.fields.name)), df.content.fields.value));
            }
            else {
                const dfObjects = yield PromiseAll(coins.map((coin) => this.client.getDynamicFieldObject({
                    parentId: partnerBalancesParentId,
                    name: {
                        type: '0x1::type_name::TypeName',
                        value: {
                            name: coin.coinType.replace('0x', ''),
                        },
                    },
                })));
                return dfObjects
                    .filter((df) => df.data.content.fields.value != '0')
                    .map((df) => CoinAmount.fromRawAmount(new Coin(normalizeStructTag$1(df.data.content.fields.name.fields.name)), df.data.content.fields.value));
            }
        });
    }
}

const FACTORY_MODULE = 'factory';
const MODULE_ROUTER = 'router';
const BPS = 10000;
const MINIMUM_LIQUIDITY = new BN$1(1000);
const MAPPING_PACKAGE_ID$1 = {
    testnet: '0xebebb67fc6fc6a74be5e57d90563c709631b4da86091c0926db81894add36ed3',
    mainnet: '0xba153169476e8c3114962261d1edc70de5ad9781b83cc617ecc8c1923191cae0',
};
const MAPPING_CONTAINER_OBJECT_ID = {
    testnet: '0xcbca62dbd54d3a8545f27a298872b1af9363a82a04a329504b1f0fef0a5f9ce4',
    mainnet: '0xb65dcbf63fd3ad5d0ebfbf334780dc9f785eff38a4459e37ab08fa79576ee511',
};
const AMM_BAG_PAIRS_PARENT_ID = {
    testnet: '',
    mainnet: '0xd15e209f5a250d6055c264975fee57ec09bf9d6acdda3b5f866f76023d1563e6',
};

const UID = bcs.fixedArray(32, bcs.u8()).transform({
    input: (id) => fromHEX(id),
    output: (id) => toHEX(Uint8Array.from(id)),
});
const CoinBcs = bcs.struct('Coin', {
    id: UID,
    value: bcs.u64(),
});
const CoinSupplyBcs = bcs.struct('CoinSupply', {
    value: bcs.u64(),
});

const PoolMetadataBcs = bcs.struct('PoolMetadata', {
    id: UID,
    reserveX: CoinBcs,
    reserveY: CoinBcs,
    kLast: bcs.u128(),
    lpSupply: CoinSupplyBcs,
    feeRate: bcs.u64(),
});

class AmmPool extends BasePool {
    constructor({ objectId, coins, reserves, feeRate, liquiditySupply, kLast, }) {
        invariant(coins.length === 2, 'COINS_LENGTH');
        coins = coins[0].sortsBefore(coins[1])
            ? [coins[0], coins[1]]
            : [coins[1], coins[0]];
        super(objectId, coins, reserves);
        this.feeRate = feeRate;
        this.liquiditySupply = liquiditySupply;
        this.kLast = kLast;
    }
    static getPoolIdentifier(coinX, coinY) {
        [coinX, coinY] = coinX.sortsBefore(coinY) ? [coinX, coinY] : [coinY, coinX];
        return `LP-${coinX.coinType.replace('0x', '')}-${coinY.coinType.replace('0x', '')}`;
    }
    static getLiquidityCoinType(coinX, coinY, network) {
        return `${MAPPING_PACKAGE_ID$1[network]}::pair::LP<${coinX.coinType}, ${coinY.coinType}>`;
    }
    get reserveX() {
        return CoinAmount.fromRawAmount(this.coins[0], this.reserves[0]);
    }
    get reserveY() {
        return CoinAmount.fromRawAmount(this.coins[1], this.reserves[1]);
    }
    get coinX() {
        return this.coins[0];
    }
    get coinY() {
        return this.coins[1];
    }
}

class AmmPoolManager extends TxBuilder {
    constructor() {
        super(...arguments);
        this.invokeGetPool = (params) => (tx) => {
            const [coinX, coinY] = params.coinX.sortsBefore(params.coinY)
                ? [params.coinX, params.coinY]
                : [params.coinY, params.coinX];
            tx.moveCall({
                target: `${MAPPING_PACKAGE_ID$1[this.network]}::${FACTORY_MODULE}::borrow_pair`,
                typeArguments: [coinX.coinType, coinY.coinType],
                arguments: [tx.object(MAPPING_CONTAINER_OBJECT_ID[this.network])],
            });
        };
    }
    getPool(params) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            const tx = new Transaction();
            this.invokeGetPool(params)(tx);
            const resp = yield this._client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ADDRESS_ZERO,
            });
            invariant(resp.effects.status.status === 'success', resp.effects.status.error);
            const poolMetadata = PoolMetadataBcs.parse(new Uint8Array(((_d = (_c = (_b = (_a = resp === null || resp === void 0 ? void 0 : resp.results) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.returnValues) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d[0]) || []));
            return new AmmPool({
                objectId: poolMetadata.id,
                coins: [params.coinX, params.coinY],
                reserves: [poolMetadata.reserveX.value, poolMetadata.reserveY.value],
                feeRate: Number(poolMetadata.feeRate) / BPS,
                liquiditySupply: poolMetadata.lpSupply.value,
                kLast: poolMetadata.kLast,
            });
        });
    }
    multiGetPools(params) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            invariant(params.length <= MAX_OBJECTS_DEV_INSPECT_PER_QUERY, 'Exceeded limit per query');
            const tx = new Transaction();
            for (const param of params) {
                this.invokeGetPool(param)(tx);
            }
            const resp = yield this._client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ADDRESS_ZERO,
            });
            invariant(resp.effects.status.status === 'success', resp.effects.status.error);
            const pools = [];
            for (const [idx, param] of params.entries()) {
                const poolMetadata = PoolMetadataBcs.parse(new Uint8Array(((_d = (_c = (_b = (_a = resp === null || resp === void 0 ? void 0 : resp.results) === null || _a === void 0 ? void 0 : _a[idx]) === null || _b === void 0 ? void 0 : _b.returnValues) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d[0]) || []));
                pools.push(new AmmPool({
                    objectId: poolMetadata.id,
                    coins: [param.coinX, param.coinY],
                    reserves: [poolMetadata.reserveX.value, poolMetadata.reserveY.value],
                    feeRate: Number(poolMetadata.feeRate) / BPS,
                    liquiditySupply: poolMetadata.lpSupply.value,
                    kLast: poolMetadata.kLast,
                }));
            }
            return pools;
        });
    }
    getPools() {
        return __awaiter(this, void 0, void 0, function* () {
            const dynamicFieldsPairs = yield this.getFullyDynamicFields(AMM_BAG_PAIRS_PARENT_ID[this.network]);
            const pairCoinTypes = dynamicFieldsPairs.map((it) => {
                const data = it.name.value.split('-');
                return {
                    coinX: new Coin(data[1]),
                    coinY: new Coin(data[2]),
                };
            });
            const pairChunks = _.chunk(pairCoinTypes, MAX_OBJECTS_DEV_INSPECT_PER_QUERY);
            const result = [];
            for (let i = 0; i < pairChunks.length; i++) {
                result.push(...(yield this.multiGetPools(pairChunks[i])));
            }
            return result;
        });
    }
}

class AmmLiquidityMath {
    static getAmountFromLiquidity(liquidity, liquiditySupply, reserve) {
        return liquidity.mul(reserve).div(liquiditySupply);
    }
    static maxLiquidityForAmount(liquiditySupply, reserve, amount) {
        return new BN(amount).mul(liquiditySupply).div(reserve);
    }
    static maxLiquidityForAmounts(liquiditySupply, reserveX, reserveY, amountX, amountY) {
        if (liquiditySupply.isZero()) {
            const liquid = sqrtBn(new BN(amountX.toString()).mul(new BN(amountY.toString())));
            return liquid.sub(MINIMUM_LIQUIDITY);
        }
        const liquidity0 = AmmLiquidityMath.maxLiquidityForAmount(liquiditySupply, reserveX, amountX);
        const liquidity1 = AmmLiquidityMath.maxLiquidityForAmount(liquiditySupply, reserveY, amountY);
        return liquidity0.lt(liquidity1) ? liquidity0 : liquidity1;
    }
    static getLiquidityFeeMintAmount(liquiditySupply, reserveX, reserveY, kLast) {
        if (kLast.isZero()) {
            return ZERO;
        }
        const rootK = sqrtBn(reserveX.mul(reserveY));
        const rootKLast = sqrtBn(kLast);
        if (rootK === rootKLast) {
            return ZERO;
        }
        const numerator = liquiditySupply.mul(rootK.sub(rootKLast));
        const denominator = rootK.mul(new BN(5)).add(rootKLast);
        return numerator.div(denominator);
    }
}

class AmmPosition {
    constructor({ owner, pool: pool, liquidity }) {
        this._coinXAmount = null;
        this._coinYAmount = null;
        this._mintAmounts = null;
        this.owner = owner;
        this.pool = pool;
        this.liquidity = new BN(liquidity);
    }
    get amountX() {
        if (this._coinXAmount === null) {
            this._coinXAmount = CoinAmount.fromRawAmount(this.pool.coinX, new BN(this.pool.liquiditySupply).isZero()
                ? ZERO
                : AmmLiquidityMath.getAmountFromLiquidity(new BN(this.liquidity), new BN(this.pool.liquiditySupply).add(AmmLiquidityMath.getLiquidityFeeMintAmount(new BN(this.pool.liquiditySupply), new BN(this.pool.reserveX.quotient), new BN(this.pool.reserveY.quotient), new BN(this.pool.kLast))), this.pool.reserveX.quotient));
        }
        return this._coinXAmount;
    }
    get amountY() {
        if (this._coinYAmount === null) {
            this._coinYAmount = CoinAmount.fromRawAmount(this.pool.coinY, new BN(this.pool.liquiditySupply).isZero()
                ? ZERO
                : AmmLiquidityMath.getAmountFromLiquidity(new BN(this.liquidity), new BN(this.pool.liquiditySupply).add(AmmLiquidityMath.getLiquidityFeeMintAmount(new BN(this.pool.liquiditySupply), new BN(this.pool.reserveX.quotient), new BN(this.pool.reserveY.quotient), new BN(this.pool.kLast))), this.pool.reserveY.quotient));
        }
        return this._coinYAmount;
    }
    get mintAmounts() {
        if (this._mintAmounts === null) {
            this._mintAmounts = {
                amountX: new BN(this.pool.liquiditySupply).isZero()
                    ? ZERO
                    : AmmLiquidityMath.getAmountFromLiquidity(new BN(this.liquidity), new BN(this.pool.liquiditySupply).add(AmmLiquidityMath.getLiquidityFeeMintAmount(new BN(this.pool.liquiditySupply), new BN(this.pool.reserveX.quotient), new BN(this.pool.reserveY.quotient), new BN(this.pool.kLast))), this.pool.reserveX.quotient),
                amountY: new BN(this.pool.liquiditySupply).isZero()
                    ? ZERO
                    : AmmLiquidityMath.getAmountFromLiquidity(new BN(this.liquidity), new BN(this.pool.liquiditySupply).add(AmmLiquidityMath.getLiquidityFeeMintAmount(new BN(this.pool.liquiditySupply), new BN(this.pool.reserveX.quotient), new BN(this.pool.reserveY.quotient), new BN(this.pool.kLast))), this.pool.reserveY.quotient),
            };
        }
        return this._mintAmounts;
    }
    set mintAmounts(_mintAmounts) {
        this._mintAmounts = _mintAmounts;
    }
    static fromAmounts({ owner, pool, amountX, amountY, }) {
        return new AmmPosition({
            owner,
            pool,
            liquidity: AmmLiquidityMath.maxLiquidityForAmounts(new BN(pool.liquiditySupply).add(AmmLiquidityMath.getLiquidityFeeMintAmount(new BN(pool.liquiditySupply), new BN(pool.reserveX.quotient), new BN(pool.reserveY.quotient), new BN(pool.kLast))), pool.reserveX.quotient, pool.reserveY.quotient, amountX, amountY),
        });
    }
    ratiosAfterSlippage(slippageTolerance) {
        const amounts = this.mintAmounts;
        const amountX = new Fraction(amounts.amountX)
            .multiply(new Percent(1).subtract(slippageTolerance))
            .toFixed(0);
        const amountY = new Fraction(amounts.amountY)
            .multiply(new Percent(1).subtract(slippageTolerance))
            .toFixed(0);
        return {
            amountX: new BN(amountX),
            amountY: new BN(amountY),
        };
    }
    mintAmountsWithSlippage(slippageTolerance) {
        const { amountX, amountY } = this.ratiosAfterSlippage(slippageTolerance);
        const positionThatWillBeCreated = AmmPosition.fromAmounts({
            owner: this.owner,
            pool: this.pool,
            amountX,
            amountY,
        });
        return {
            amountX: positionThatWillBeCreated.amountX.quotient,
            amountY: positionThatWillBeCreated.amountY.quotient,
        };
    }
    burnAmountsWithSlippage(slippageTolerance) {
        return this.ratiosAfterSlippage(slippageTolerance);
    }
}

class AmmPositionManager extends TxBuilder {
    constructor(network = 'mainnet') {
        super(network);
        this.network = network;
        this.poolManager = new AmmPoolManager(network);
    }
    getUserPositions(owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const allCoinBalance = yield this._client.getAllBalances({
                owner: owner,
            });
            const liquidityCoins = allCoinBalance.filter((coin) => coin.coinType.startsWith(`${MAPPING_PACKAGE_ID$1[this.network]}::pair::LP`));
            const batches = chunk(liquidityCoins, MAX_OBJECTS_PER_QUERY);
            const pools = (yield Promise.all(batches.map((batch) => this.poolManager.multiGetPools(batch.map((item) => {
                const { typeParams } = parseStructTag(item.coinType);
                return {
                    coinX: new Coin(normalizeStructTag$1(typeParams[0])),
                    coinY: new Coin(normalizeStructTag$1(typeParams[1])),
                };
            }))))).flat();
            return liquidityCoins.map((liquidityCoin, idx) => new AmmPosition({
                owner: owner,
                pool: pools[idx],
                liquidity: liquidityCoin.totalBalance,
            }));
        });
    }
    increaseLiquidity(position, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { amountX, amountY, slippageTolerance, deadline } = options;
            if (new BN$1(position.pool.liquiditySupply).isZero()) {
                invariant(amountX && amountY, 'AMOUNTS');
                position.mintAmounts = {
                    amountX: new BN$1(amountX),
                    amountY: new BN$1(amountY),
                };
            }
            const minimumAmounts = position.mintAmountsWithSlippage(slippageTolerance);
            const [coinXToAdd, coinYToAdd] = [
                coinWithBalance({
                    balance: BigInt(position.mintAmounts.amountX.toString()),
                    type: position.pool.coinX.coinType,
                    useGasCoin: position.pool.coinX.coinType === SUI_TYPE_ARG,
                })(this._tx),
                coinWithBalance({
                    balance: BigInt(position.mintAmounts.amountY.toString()),
                    type: position.pool.coinY.coinType,
                    useGasCoin: position.pool.coinY.coinType === SUI_TYPE_ARG,
                })(this._tx),
            ];
            return this._tx.moveCall({
                target: `${MAPPING_PACKAGE_ID$1[this.network]}::${MODULE_ROUTER}::add_liquidity`,
                typeArguments: [
                    position.pool.coinX.coinType,
                    position.pool.coinY.coinType,
                ],
                arguments: [
                    this._tx.object(SUI_CLOCK_OBJECT_ID),
                    this._tx.object(MAPPING_CONTAINER_OBJECT_ID[this.network]),
                    coinXToAdd,
                    coinYToAdd,
                    this._tx.pure.u64(minimumAmounts.amountX.toString()),
                    this._tx.pure.u64(minimumAmounts.amountY.toString()),
                    this._tx.pure.address(position.owner),
                    this._tx.pure.u64(deadline || Number.MAX_SAFE_INTEGER),
                ],
            });
        });
    }
    decreaseLiquidity(position, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { slippageTolerance, deadline } = options;
            const minimumAmounts = position.burnAmountsWithSlippage(slippageTolerance);
            const liquidityCoinToRemove = coinWithBalance({
                type: AmmPool.getLiquidityCoinType(position.pool.coinX, position.pool.coinY, this.network),
                balance: BigInt(position.liquidity.toString()),
                useGasCoin: false,
            })(this._tx);
            return this._tx.moveCall({
                target: `${MAPPING_PACKAGE_ID$1[this.network]}::${MODULE_ROUTER}::remove_liquidity`,
                typeArguments: [
                    position.pool.coinX.coinType,
                    position.pool.coinY.coinType,
                ],
                arguments: [
                    this._tx.object(SUI_CLOCK_OBJECT_ID),
                    this._tx.object(MAPPING_CONTAINER_OBJECT_ID[this.network]),
                    liquidityCoinToRemove,
                    this._tx.pure.u64(minimumAmounts.amountX.toString()),
                    this._tx.pure.u64(minimumAmounts.amountY.toString()),
                    this._tx.pure.address(position.owner),
                    this._tx.pure.u64(deadline || Number.MAX_SAFE_INTEGER),
                ],
            });
        });
    }
}

const REWARD_PRECISION = new BN$1(1000000);
const MAPPING_POSITION_OBJECT_TYPE = {
    testnet: '0xd219d9d3345eb2ec779e8c6faed9259f75e2aa879ea52da670366072fa5a46a7::position::Position',
    mainnet: '0x943535499ac300765aa930072470e0b515cfd7eebcaa5c43762665eaad9cc6f2::position::Position',
};
const MAPPING_POOL_REGISTRY_OBJECT_ID = {
    testnet: '0x189462a405393ed2ae6499647ba206590b3bf7ea152381812c2bd33e232a3451',
    mainnet: '0x5c38d069b2f208b0894078465a31b5beb425104894f3237195c90666a82753a2',
};

class FaaSPool extends ObjectId {
    constructor({ objectId, poolIndex, tokenRewardType, flxTokenType, tokenRewardPerSec, flxRewardPerSec, accTokenRewardPerSec, accFlxRewardPerSec, lastRewardAtMs, startingTimestampMs, closingTimestampMs, creator, isEmergency, totalLiquidityCoinStaked, liquidityPool, }) {
        super(objectId);
        this.poolIndex = poolIndex;
        this.tokenRewardType = tokenRewardType;
        this.flxTokenType = flxTokenType;
        this.tokenRewardPerSec = tokenRewardPerSec;
        this.flxRewardPerSec = flxRewardPerSec;
        this.accTokenRewardPerSec = accTokenRewardPerSec;
        this.accFlxRewardPerSec = accFlxRewardPerSec;
        this.lastRewardAtMs = lastRewardAtMs;
        this.startingTimestampMs = startingTimestampMs;
        this.closingTimestampMs = closingTimestampMs;
        this.creator = creator;
        this.isEmergency = isEmergency;
        this.liquidityPool = liquidityPool;
        this._wrappedLiquidityPosition = new AmmPosition({
            owner: ADDRESS_ZERO,
            pool: liquidityPool,
            liquidity: totalLiquidityCoinStaked,
        });
    }
    get amountX() {
        return this._wrappedLiquidityPosition.amountX;
    }
    get amountY() {
        return this._wrappedLiquidityPosition.amountY;
    }
    get totalLiquidityCoinStaked() {
        return new BN(this._wrappedLiquidityPosition.liquidity.toString());
    }
    get isClosed() {
        return now() >= this.closingTimestampMs;
    }
}

class FaaSPosition extends ObjectId {
    constructor({ objectId, owner, pool, liquidity, tokenRewardDebt, flxRewardDebt, }) {
        super(objectId);
        this.owner = owner;
        this.pool = pool;
        this.liquidity = liquidity;
        this.tokenRewardDebt = tokenRewardDebt;
        this.flxRewardDebt = flxRewardDebt;
        this._wrappedLiquidityPosition = new AmmPosition({
            owner,
            pool: pool.liquidityPool,
            liquidity,
        });
    }
    get amountX() {
        return this._wrappedLiquidityPosition.amountX;
    }
    get amountY() {
        return this._wrappedLiquidityPosition.amountY;
    }
    get pendingRewards() {
        const totalLiquidityCoinStaked = this.pool.totalLiquidityCoinStaked;
        if (totalLiquidityCoinStaked.isZero()) {
            return {
                pendingToken: CoinAmount.fromRawAmount(new Coin(this.pool.tokenRewardType), ZERO),
                pendingFLX: CoinAmount.fromRawAmount(new Coin(this.pool.flxTokenType), ZERO),
            };
        }
        const multiplier = new BN(Math.max(toSeconds(Math.min(this.pool.closingTimestampMs, nowInMilliseconds()) -
            this.pool.lastRewardAtMs), 0));
        const accTokenReward = new BN(this.pool.accTokenRewardPerSec).add(multiplier
            .mul(new BN(this.pool.tokenRewardPerSec.toString()))
            .mul(REWARD_PRECISION)
            .div(totalLiquidityCoinStaked));
        const accFlxReward = new BN(this.pool.accFlxRewardPerSec).add(multiplier
            .mul(new BN(this.pool.flxRewardPerSec.toString()))
            .mul(REWARD_PRECISION)
            .div(totalLiquidityCoinStaked));
        return {
            pendingToken: CoinAmount.fromRawAmount(new Coin(this.pool.tokenRewardType), accTokenReward
                .mul(new BN(this._wrappedLiquidityPosition.liquidity.toString()))
                .div(REWARD_PRECISION)
                .sub(new BN(this.tokenRewardDebt))),
            pendingFLX: CoinAmount.fromRawAmount(new Coin(this.pool.flxTokenType), accFlxReward
                .mul(new BN(this._wrappedLiquidityPosition.liquidity.toString()))
                .div(REWARD_PRECISION)
                .sub(new BN(this.flxRewardDebt))),
        };
    }
}

const limit = pLimit(DEFAULT_CONCURRENCY);
class FaaSPoolManager extends TxBuilder {
    constructor(network) {
        super(network);
        this.liquidityPoolManager = new AmmPoolManager(network);
    }
    getLiquidityPool(coinX, coinY) {
        return __awaiter(this, void 0, void 0, function* () {
            const liquidityPoolId = AmmPool.getPoolIdentifier(coinX, coinY);
            const cached = sdkCache.get(liquidityPoolId);
            if (cached) {
                return cached;
            }
            const liquidityPool = yield this.liquidityPoolManager.getPool({
                coinX,
                coinY,
            });
            sdkCache.set(liquidityPoolId, liquidityPool, DEFAULT_CACHE_EXPIRATION_TIME_SECONDS);
            return liquidityPool;
        });
    }
    multiGetLiquidityPools(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const poolIds = uniq(params.map((param) => AmmPool.getPoolIdentifier(param.coinX, param.coinY)));
            const cached = sdkCache.mget(poolIds);
            const missingKeys = poolIds.filter((poolId) => !cached[poolId]);
            const batches = chunk(missingKeys, MAX_OBJECTS_PER_QUERY);
            const missingPools = (yield Promise.all(batches.map((batch) => limit(() => this.liquidityPoolManager.multiGetPools(batch.map((it) => {
                const [, coinX, coinY] = it.split('-');
                return {
                    coinX: new Coin(normalizeStructTag$1(coinX)),
                    coinY: new Coin(normalizeStructTag$1(coinY)),
                };
            })))))).flat();
            sdkCache.mset(missingPools.map((pool) => ({
                key: AmmPool.getPoolIdentifier(pool.coinX, pool.coinY),
                val: pool,
                ttl: DEFAULT_CACHE_EXPIRATION_TIME_SECONDS,
            })));
            return missingPools.concat(Object.values(cached).filter((it) => it));
        });
    }
    getPool(poolIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            const poolDf = yield this._client.getDynamicFieldObject({
                parentId: MAPPING_POOL_REGISTRY_OBJECT_ID[this.network],
                name: {
                    type: 'u64',
                    value: poolIndex.toString(),
                },
            });
            invariant(!poolDf.error, 'Get FAAS pool failed');
            const { typeParams } = parseStructTag((_b = (_a = poolDf.data) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b['fields'].value.type);
            const liquidityPool = yield this.getLiquidityPool(new Coin(normalizeStructTag$1(typeParams[0])), new Coin(normalizeStructTag$1(typeParams[1])));
            const { id, token_per_seconds, flx_per_seconds, acc_token_per_share, acc_flx_per_share, started_at_ms, ended_at_ms, last_reward_at_ms, creator, is_emergency, lp_custodian, flx_custodian, reward_token_custodian, } = ((_d = (_c = poolDf.data) === null || _c === void 0 ? void 0 : _c.content) === null || _d === void 0 ? void 0 : _d['fields'].value.fields) || {};
            return new FaaSPool({
                objectId: poolDf.data.objectId,
                poolIndex: poolIndex,
                tokenRewardType: normalizeStructTag$1(parseStructTag(reward_token_custodian.type).typeParams[0]),
                flxTokenType: normalizeStructTag$1(parseStructTag(flx_custodian.type).typeParams[0]),
                tokenRewardPerSec: token_per_seconds,
                flxRewardPerSec: flx_per_seconds,
                accTokenRewardPerSec: acc_token_per_share,
                accFlxRewardPerSec: acc_flx_per_share,
                startingTimestampMs: Number(started_at_ms),
                closingTimestampMs: Number(ended_at_ms),
                lastRewardAtMs: Number(last_reward_at_ms),
                creator: creator,
                isEmergency: is_emergency,
                liquidityPool,
                totalLiquidityCoinStaked: lp_custodian.fields.reserve,
            });
        });
    }
    multiGetPools(poolIndexes) {
        return __awaiter(this, void 0, void 0, function* () {
            invariant(poolIndexes.length < MAX_OBJECTS_PER_QUERY, 'Exceeded limit per query');
            return Promise.all(uniq(poolIndexes).map((poolIndex) => limit(() => this.getPool(poolIndex))));
        });
    }
    getAllPools() {
        return __awaiter(this, void 0, void 0, function* () {
            const poolDynamicFields = yield getAllDynamicFields(MAPPING_POOL_REGISTRY_OBJECT_ID[this.network], this._client);
            const poolDynamicFieldIds = poolDynamicFields.map((df) => df.objectId);
            const poolObjects = yield multiGetObjects(this._client, poolDynamicFieldIds);
            const multiGetLiquidityPoolParams = poolObjects.map((poolObject) => {
                var _a;
                const { typeParams } = parseStructTag((_a = poolObject === null || poolObject === void 0 ? void 0 : poolObject.content) === null || _a === void 0 ? void 0 : _a['fields'].value.type);
                const [coinX, coinY] = [
                    new Coin(normalizeStructTag$1(typeParams[0])),
                    new Coin(normalizeStructTag$1(typeParams[1])),
                ];
                return {
                    coinX,
                    coinY,
                };
            });
            const liquidityPools = yield this.multiGetLiquidityPools(multiGetLiquidityPoolParams);
            const mappingLiquidityPools = liquidityPools.reduce((memo, liquidityPool) => {
                memo[AmmPool.getPoolIdentifier(liquidityPool.coinX, liquidityPool.coinY)] = liquidityPool;
                return memo;
            }, {});
            const pools = poolObjects.map((poolObject) => {
                var _a, _b, _c;
                const { id, token_per_seconds, flx_per_seconds, acc_token_per_share, acc_flx_per_share, started_at_ms, ended_at_ms, last_reward_at_ms, creator, is_emergency, lp_custodian, flx_custodian, reward_token_custodian, } = ((_a = poolObject === null || poolObject === void 0 ? void 0 : poolObject.content) === null || _a === void 0 ? void 0 : _a['fields'].value.fields) || {};
                const { typeParams } = parseStructTag((_b = poolObject === null || poolObject === void 0 ? void 0 : poolObject.content) === null || _b === void 0 ? void 0 : _b['fields'].value.type);
                return new FaaSPool({
                    objectId: id.id,
                    poolIndex: Number(((_c = poolObject === null || poolObject === void 0 ? void 0 : poolObject.content) === null || _c === void 0 ? void 0 : _c['fields'].name) || 0),
                    tokenRewardType: normalizeStructTag$1(parseStructTag(reward_token_custodian.type).typeParams[0]),
                    flxTokenType: normalizeStructTag$1(parseStructTag(flx_custodian.type).typeParams[0]),
                    tokenRewardPerSec: token_per_seconds,
                    flxRewardPerSec: flx_per_seconds,
                    accTokenRewardPerSec: acc_token_per_share,
                    accFlxRewardPerSec: acc_flx_per_share,
                    startingTimestampMs: Number(started_at_ms),
                    closingTimestampMs: Number(ended_at_ms),
                    lastRewardAtMs: Number(last_reward_at_ms),
                    creator: creator,
                    isEmergency: is_emergency,
                    liquidityPool: mappingLiquidityPools[AmmPool.getPoolIdentifier(new Coin(normalizeStructTag$1(typeParams[0])), new Coin(normalizeStructTag$1(typeParams[1])))],
                    totalLiquidityCoinStaked: lp_custodian.fields.reserve,
                });
            });
            return pools.sort((a, b) => a.poolIndex - b.poolIndex);
        });
    }
}

class FaaSPositionManager extends TxBuilder {
    constructor(network = 'mainnet') {
        super(network);
        this.network = network;
        this.poolManager = new FaaSPoolManager(network);
    }
    getUserPositions(owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const ownedPositionObjects = yield getAllOwnedObjects({
                owner,
                objectType: MAPPING_POSITION_OBJECT_TYPE[this.network],
            }, this._client);
            const validPositions = ownedPositionObjects
                .map((item) => { var _a; return (Object.assign({}, (_a = item.content) === null || _a === void 0 ? void 0 : _a['fields'])); })
                .filter((item) => !new BN$1(item.amount).isZero());
            const poolIndexes = validPositions.map((pos) => Number(pos.pool_idx));
            const pools = yield this.poolManager.multiGetPools(poolIndexes);
            return validPositions.map((pos) => new FaaSPosition({
                objectId: pos.id.id,
                owner,
                liquidity: pos.amount,
                tokenRewardDebt: pos.token_reward_debt,
                flxRewardDebt: pos.flx_reward_debt,
                pool: pools.find((pool) => pool.poolIndex === Number(pos.pool_idx)),
            }));
        });
    }
}

class NoTickDataProvider {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getTick(index) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error(NoTickDataProvider.ERROR_MESSAGE);
        });
    }
}
NoTickDataProvider.ERROR_MESSAGE = 'No tick data provider was given';

class ClmmPositionReward {
    constructor({ coinsOwedReward, rewardGrowthInsideLast, }) {
        this.coinsOwedReward = new BN(coinsOwedReward);
        this.rewardGrowthInsideLast = new BN(rewardGrowthInsideLast);
    }
}

class ClmmPosition extends ObjectId {
    constructor({ objectId, owner, pool, tickLower, tickUpper, liquidity, coinsOwedX, coinsOwedY, feeGrowthInsideXLast, feeGrowthInsideYLast, rewardInfos, }) {
        invariant(tickLower < tickUpper, 'TICK_ORDER');
        invariant(tickLower >= ClmmTickMath.MIN_TICK && tickLower % pool.tickSpacing === 0, 'TICK_LOWER');
        invariant(tickUpper <= ClmmTickMath.MAX_TICK && tickUpper % pool.tickSpacing === 0, 'TICK_UPPER');
        super(objectId || ADDRESS_ZERO);
        this.feeReward = null;
        this.incentiveReward = null;
        this._coinXAmount = null;
        this._coinYAmount = null;
        this._mintAmounts = null;
        this.owner = owner;
        this.pool = pool;
        this.tickLower = tickLower;
        this.tickUpper = tickUpper;
        this.liquidity = new BN(liquidity);
        this.coinsOwedX = new BN(coinsOwedX);
        this.coinsOwedY = new BN(coinsOwedY);
        this.rewardInfos = rewardInfos.map((rewardInfo) => new ClmmPositionReward({
            coinsOwedReward: rewardInfo.coinsOwedReward,
            rewardGrowthInsideLast: rewardInfo.rewardGrowthInsideLast,
        }));
        this.feeGrowthInsideXLast = new BN(feeGrowthInsideXLast);
        this.feeGrowthInsideYLast = new BN(feeGrowthInsideYLast);
    }
    get priceLower() {
        return tickToPrice(this.pool.coins[0], this.pool.coins[1], this.tickLower);
    }
    get priceUpper() {
        return tickToPrice(this.pool.coins[0], this.pool.coins[1], this.tickUpper);
    }
    get amountX() {
        if (this._coinXAmount === null) {
            if (this.pool.tickCurrent < this.tickLower) {
                this._coinXAmount = CoinAmount.fromRawAmount(this.pool.coins[0], ClmmSqrtPriceMath.getAmountXDelta(ClmmTickMath.tickIndexToSqrtPriceX64(this.tickLower), ClmmTickMath.tickIndexToSqrtPriceX64(this.tickUpper), this.liquidity, false));
            }
            else if (this.pool.tickCurrent < this.tickUpper) {
                this._coinXAmount = CoinAmount.fromRawAmount(this.pool.coins[0], ClmmSqrtPriceMath.getAmountXDelta(new BN(this.pool.sqrtPriceX64), ClmmTickMath.tickIndexToSqrtPriceX64(this.tickUpper), this.liquidity, false));
            }
            else {
                this._coinXAmount = CoinAmount.fromRawAmount(this.pool.coins[0], ZERO);
            }
        }
        return this._coinXAmount;
    }
    /**
     * Returns the amount of token1 that this position's liquidity could be burned for at the current pool price
     */
    get amountY() {
        if (this._coinYAmount === null) {
            if (this.pool.tickCurrent < this.tickLower) {
                this._coinYAmount = CoinAmount.fromRawAmount(this.pool.coins[1], ZERO);
            }
            else if (this.pool.tickCurrent < this.tickUpper) {
                this._coinYAmount = CoinAmount.fromRawAmount(this.pool.coins[1], ClmmSqrtPriceMath.getAmountYDelta(ClmmTickMath.tickIndexToSqrtPriceX64(this.tickLower), new BN(this.pool.sqrtPriceX64), this.liquidity, false));
            }
            else {
                this._coinYAmount = CoinAmount.fromRawAmount(this.pool.coins[1], ClmmSqrtPriceMath.getAmountYDelta(ClmmTickMath.tickIndexToSqrtPriceX64(this.tickLower), ClmmTickMath.tickIndexToSqrtPriceX64(this.tickUpper), this.liquidity, false));
            }
        }
        return this._coinYAmount;
    }
    get mintAmounts() {
        if (this._mintAmounts === null) {
            if (this.pool.tickCurrent < this.tickLower) {
                return {
                    amountX: ClmmSqrtPriceMath.getAmountXDelta(ClmmTickMath.tickIndexToSqrtPriceX64(this.tickLower), ClmmTickMath.tickIndexToSqrtPriceX64(this.tickUpper), this.liquidity, true),
                    amountY: ZERO,
                };
            }
            else if (this.pool.tickCurrent < this.tickUpper) {
                return {
                    amountX: ClmmSqrtPriceMath.getAmountXDelta(new BN(this.pool.sqrtPriceX64), ClmmTickMath.tickIndexToSqrtPriceX64(this.tickUpper), this.liquidity, true),
                    amountY: ClmmSqrtPriceMath.getAmountYDelta(ClmmTickMath.tickIndexToSqrtPriceX64(this.tickLower), new BN(this.pool.sqrtPriceX64), this.liquidity, true),
                };
            }
            else {
                return {
                    amountX: ZERO,
                    amountY: ClmmSqrtPriceMath.getAmountYDelta(ClmmTickMath.tickIndexToSqrtPriceX64(this.tickLower), ClmmTickMath.tickIndexToSqrtPriceX64(this.tickUpper), this.liquidity, true),
                };
            }
        }
        return this._mintAmounts;
    }
    /**
     * Computes the maximum amount of liquidity received for a given amount of tokenX, tokenY,
     * and the prices at the tick boundaries.
     * @param objectId The object ID of the position, if it exists
     * @param owner The owner of the position
     * @param pool The pool for which the position should be created
     * @param tickLower The lower tick of the position
     * @param tickUpper The upper tick of the position
     * @param amountX tokenX amount
     * @param amountY tokenY amount
     * @param useFullPrecision If false, liquidity will be maximized according to what the router can calculate,
     * not what core can theoretically support
     * @returns The position
     */
    static fromAmounts({ objectId, owner, pool, tickLower, tickUpper, amountX, amountY, useFullPrecision, }) {
        const sqrtRatioAX64 = ClmmTickMath.tickIndexToSqrtPriceX64(tickLower);
        const sqrtRatioBX64 = ClmmTickMath.tickIndexToSqrtPriceX64(tickUpper);
        return new ClmmPosition({
            objectId,
            owner,
            pool,
            tickLower,
            tickUpper,
            liquidity: ClmmLiquidityMath.maxLiquidityForAmounts(new BN(pool.sqrtPriceX64), sqrtRatioAX64, sqrtRatioBX64, amountX, amountY, useFullPrecision),
            coinsOwedX: ZERO,
            coinsOwedY: ZERO,
            feeGrowthInsideXLast: ZERO,
            feeGrowthInsideYLast: ZERO,
            rewardInfos: [],
        });
    }
    /**
     * Computes a position with the maximum amount of liquidity received for a given amount of tokenX, assuming an unlimited amount of tokenY
     * @param objectId The object ID of the position, if it exists
     * @param owner The owner of the position
     * @param pool The pool for which the position is created
     * @param tickLower The lower tick
     * @param tickUpper The upper tick
     * @param amountX The desired amount of tokenX
     * @param useFullPrecision If true, liquidity will be maximized according to what the router can calculate,
     * not what core can theoretically support
     * @returns The position
     */
    static fromAmountX({ objectId, owner, pool, tickLower, tickUpper, amountX, useFullPrecision, }) {
        return ClmmPosition.fromAmounts({
            objectId,
            owner,
            pool,
            tickLower,
            tickUpper,
            amountX,
            amountY: MaxUint64,
            useFullPrecision,
        });
    }
    /**
     * Computes a position with the maximum amount of liquidity received for a given amount of tokenY, assuming an unlimited amount of tokenX
     * @param objectId The object ID of the position, if it exists
     * @param owner The owner of the position
     * @param pool The pool for which the position is created
     * @param tickLower The lower tick
     * @param tickUpper The upper tick
     * @param amountY The desired amount of tokenY
     * @param useFullPrecision If true, liquidity will be maximized according to what the router can calculate,
     * not what core can theoretically support
     * @returns The position
     */
    static fromAmountY({ objectId, owner, pool, tickLower, tickUpper, amountY, useFullPrecision, }) {
        return ClmmPosition.fromAmounts({
            objectId,
            owner,
            pool,
            tickLower,
            tickUpper,
            amountX: MaxUint64,
            amountY,
            useFullPrecision,
        });
    }
    /**
     * Returns the lower and upper sqrt ratios if the price 'slips' up to slippage tolerance percentage
     * @param slippageTolerance The amount by which the price can 'slip' before the transaction will revert
     * @returns The sqrt ratios after slippage
     */
    ratiosAfterSlippage(slippageTolerance) {
        const priceLower = this.pool.coinXPrice.asFraction.multiply(new Percent(1).subtract(slippageTolerance));
        const priceUpper = this.pool.coinXPrice.asFraction.multiply(slippageTolerance.add(1));
        let sqrtRatioX64Lower = encodeSqrtRatioX64(priceLower.numerator, priceLower.denominator);
        if (sqrtRatioX64Lower.lte(ClmmTickMath.MIN_SQRT_RATIO)) {
            sqrtRatioX64Lower = ClmmTickMath.MIN_SQRT_RATIO.add(ONE);
        }
        let sqrtRatioX64Upper = encodeSqrtRatioX64(priceUpper.numerator, priceUpper.denominator);
        if (sqrtRatioX64Upper.gte(ClmmTickMath.MAX_SQRT_RATIO)) {
            sqrtRatioX64Upper = ClmmTickMath.MAX_SQRT_RATIO.sub(ONE);
        }
        return {
            sqrtRatioX64Lower,
            sqrtRatioX64Upper,
        };
    }
    /**
     * Returns the minimum amounts that must be sent in order to safely mint the amount of liquidity held by the position
     * with the given slippage tolerance
     * @param slippageTolerance Tolerance of unfavorable slippage from the current price
     * @returns The amounts, with slippage
     */
    mintAmountsWithSlippage(slippageTolerance) {
        // get lower/upper prices
        const { sqrtRatioX64Upper, sqrtRatioX64Lower } = this.ratiosAfterSlippage(slippageTolerance);
        // construct counterfactual pools
        const poolLower = new ClmmPool(this.pool.id, this.pool.coins, [] /* reward infos don't matter */, this.pool.reserves, this.pool.fee, sqrtRatioX64Lower, ClmmTickMath.sqrtPriceX64ToTickIndex(sqrtRatioX64Lower), 0 /* liquidity doesn't matter */, 0 /* fee growth global doesn't matter */, 0 /* fee growth global doesn't matter */);
        const poolUpper = new ClmmPool(this.pool.id, this.pool.coins, [] /* reward infos don't matter */, this.pool.reserves, this.pool.fee, sqrtRatioX64Upper, ClmmTickMath.sqrtPriceX64ToTickIndex(sqrtRatioX64Upper), 0 /* liquidity doesn't matter */, 0 /* fee growth global doesn't matter */, 0 /* fee growth global doesn't matter */);
        // because the router is imprecise, we need to calculate the position that will be created (assuming no slippage)
        const positionThatWillBeCreated = ClmmPosition.fromAmounts(Object.assign(Object.assign({ owner: this.owner, pool: this.pool, tickLower: this.tickLower, tickUpper: this.tickUpper }, this.mintAmounts), { useFullPrecision: false }));
        // we want the smaller amounts...
        // ...which occurs at the upper price for amount0...
        const { amountX } = new ClmmPosition({
            owner: this.owner,
            pool: poolUpper,
            liquidity: positionThatWillBeCreated.liquidity,
            tickLower: this.tickLower,
            tickUpper: this.tickUpper,
            coinsOwedX: ZERO,
            coinsOwedY: ZERO,
            feeGrowthInsideXLast: ZERO,
            feeGrowthInsideYLast: ZERO,
            rewardInfos: [],
        }).mintAmounts;
        // ...and the lower for amount1
        const { amountY } = new ClmmPosition({
            owner: this.owner,
            pool: poolLower,
            liquidity: positionThatWillBeCreated.liquidity,
            tickLower: this.tickLower,
            tickUpper: this.tickUpper,
            coinsOwedX: ZERO,
            coinsOwedY: ZERO,
            feeGrowthInsideXLast: ZERO,
            feeGrowthInsideYLast: ZERO,
            rewardInfos: [],
        }).mintAmounts;
        return { amountX, amountY };
    }
    burnAmountsWithSlippage(slippageTolerance) {
        // get lower/upper prices
        const { sqrtRatioX64Upper, sqrtRatioX64Lower } = this.ratiosAfterSlippage(slippageTolerance);
        // construct counterfactual pools
        const poolLower = new ClmmPool(this.pool.id, this.pool.coins, [] /* reward infos don't matter */, this.pool.reserves, this.pool.fee, sqrtRatioX64Lower, ClmmTickMath.sqrtPriceX64ToTickIndex(sqrtRatioX64Lower), 0 /* liquidity doesn't matter */, 0 /* fee growth global doesn't matter */, 0 /* fee growth global doesn't matter */);
        const poolUpper = new ClmmPool(this.pool.id, this.pool.coins, [] /* reward infos don't matter */, this.pool.reserves, this.pool.fee, sqrtRatioX64Upper, ClmmTickMath.sqrtPriceX64ToTickIndex(sqrtRatioX64Upper), 0 /* liquidity doesn't matter */, 0 /* fee growth global doesn't matter */, 0 /* fee growth global doesn't matter */);
        // we want the smaller amounts...
        // ...which occurs at the upper price for amount0...
        const amountX = new ClmmPosition({
            owner: this.owner,
            pool: poolUpper,
            liquidity: this.liquidity,
            tickLower: this.tickLower,
            tickUpper: this.tickUpper,
            coinsOwedX: ZERO,
            coinsOwedY: ZERO,
            feeGrowthInsideXLast: this.feeGrowthInsideXLast,
            feeGrowthInsideYLast: this.feeGrowthInsideYLast,
            rewardInfos: [],
        }).amountX;
        // ...and the lower for amount1
        const amountY = new ClmmPosition({
            owner: this.owner,
            pool: poolLower,
            liquidity: this.liquidity,
            tickLower: this.tickLower,
            tickUpper: this.tickUpper,
            coinsOwedX: ZERO,
            coinsOwedY: ZERO,
            feeGrowthInsideXLast: this.feeGrowthInsideXLast,
            feeGrowthInsideYLast: this.feeGrowthInsideYLast,
            rewardInfos: [],
        }).amountY;
        return { amountX: amountX.quotient, amountY: amountY.quotient };
    }
    getFees() {
        return __awaiter(this, void 0, void 0, function* () {
            const [tickInfoLower, tickInfoUpper] = yield Promise.all([
                this.pool.tickDataProvider.getTick(this.tickLower),
                this.pool.tickDataProvider.getTick(this.tickUpper),
            ]);
            const [feeGrowthInsideX, feeGrowthInsideY] = TickLibrary.getFeeGrowthInside({
                feeGrowthOutsideX: tickInfoLower.feeGrowthOutsideX,
                feeGrowthOutsideY: tickInfoLower.feeGrowthOutsideY,
            }, {
                feeGrowthOutsideX: tickInfoUpper.feeGrowthOutsideX,
                feeGrowthOutsideY: tickInfoUpper.feeGrowthOutsideY,
            }, this.tickLower, this.tickUpper, this.pool.tickCurrent, new BN(this.pool.feeGrowthGlobalX), new BN(this.pool.feeGrowthGlobalY));
            return {
                amountX: this.coinsOwedX.add(ClmmFullMath.mulDivRoundingDown(ClmmFullMath.wrappingSubIn128(feeGrowthInsideX, this.feeGrowthInsideXLast), this.liquidity, Q64)),
                amountY: this.coinsOwedY.add(ClmmFullMath.mulDivRoundingDown(ClmmFullMath.wrappingSubIn128(feeGrowthInsideY, this.feeGrowthInsideYLast), this.liquidity, Q64)),
            };
        });
    }
    getRewards() {
        return __awaiter(this, void 0, void 0, function* () {
            const [tickInfoLower, tickInfoUpper] = yield Promise.all([
                this.pool.tickDataProvider.getTick(this.tickLower),
                this.pool.tickDataProvider.getTick(this.tickUpper),
            ]);
            const rewardsGrowthInside = TickLibrary.getRewardsGrowthInside(tickInfoLower.rewardGrowthsOutside, tickInfoUpper.rewardGrowthsOutside, this.tickLower, this.tickUpper, this.pool.tickCurrent, this.pool.poolRewards.map((rewardInfo) => {
                const elapsedSecs = Math.max(Math.min(toSeconds(nowInMilliseconds()), rewardInfo.endedAtSeconds) -
                    rewardInfo.lastUpdateTime, 0);
                const pendingRewardGrowth = new BN(rewardInfo.rewardPerSeconds)
                    .mul(new BN(elapsedSecs))
                    .div(new BN(this.pool.liquidity));
                return new BN(rewardInfo.rewardGrowthGlobal).add(pendingRewardGrowth);
            }));
            return rewardsGrowthInside.map((rewardGrowthInside, idx) => {
                var _a, _b, _c, _d;
                return ((_b = (_a = this.rewardInfos[idx]) === null || _a === void 0 ? void 0 : _a.coinsOwedReward) !== null && _b !== void 0 ? _b : ZERO).add(ClmmFullMath.mulDivRoundingDown(ClmmFullMath.wrappingSubIn128(rewardGrowthInside, (_d = (_c = this.rewardInfos[idx]) === null || _c === void 0 ? void 0 : _c.rewardGrowthInsideLast) !== null && _d !== void 0 ? _d : ZERO), this.liquidity, Q64));
            });
        });
    }
    setFeeReward(rewards) {
        this.feeReward = rewards;
    }
    setIncentiveReward(rewards) {
        this.incentiveReward = rewards;
    }
}

const NO_TICK_DATA_PROVIDER_DEFAULT = new NoTickDataProvider();
class ClmmPool extends BasePool {
    constructor(objectId, coins, poolRewards, reserves, fee, sqrtPriceX64, tickCurrent, liquidity, feeGrowthGlobalX, feeGrowthGlobalY, tickDataProvider = NO_TICK_DATA_PROVIDER_DEFAULT) {
        invariant(coins.length === 2, 'COINS_LENGTH');
        coins = coins[0].sortsBefore(coins[1])
            ? [coins[0], coins[1]]
            : [coins[1], coins[0]];
        super(objectId, coins, reserves);
        this.fee = fee;
        this.sqrtPriceX64 = sqrtPriceX64;
        this.tickCurrent = tickCurrent;
        this.liquidity = liquidity;
        this.feeGrowthGlobalX = feeGrowthGlobalX;
        this.feeGrowthGlobalY = feeGrowthGlobalY;
        this.poolRewards = poolRewards;
        this.tickDataProvider = tickDataProvider;
    }
    get coinXPrice() {
        var _a;
        return ((_a = this._coinXPrice) !== null && _a !== void 0 ? _a : (this._coinXPrice = new Price(this.coins[0], this.coins[1], Q128, new BN(this.sqrtPriceX64).mul(new BN(this.sqrtPriceX64)))));
    }
    get coinYPrice() {
        var _a;
        return ((_a = this._coinYPrice) !== null && _a !== void 0 ? _a : (this._coinYPrice = new Price(this.coins[1], this.coins[0], new BN(this.sqrtPriceX64).mul(new BN(this.sqrtPriceX64)), Q128)));
    }
    get coinX() {
        return this.coins[0];
    }
    get coinY() {
        return this.coins[1];
    }
    priceOf(coin) {
        invariant(this.involvesCoin(coin), 'COIN');
        return coin.equals(this.coins[0]) ? this.coinXPrice : this.coinYPrice;
    }
    get tickSpacing() {
        return TICK_SPACINGS[this.fee];
    }
    getRatio(tickLower, tickUpper) {
        const mintAmounts = ClmmPosition.fromAmounts({
            owner: ADDRESS_ZERO,
            pool: this,
            amountX: CoinAmount.ONE(this.coinX).quotient, // one decimal amount
            amountY: CoinAmount.ONE(this.coinY).quotient, // one decimal amount
            tickLower,
            tickUpper,
            useFullPrecision: true,
        }).mintAmounts;
        return new Fraction(mintAmounts.amountY, mintAmounts.amountX);
    }
}

class Tick {
    constructor({ index, liquidityGross, liquidityNet, feeGrowthOutsideX, feeGrowthOutsideY, rewardGrowthsOutside, }) {
        invariant(index >= ClmmTickMath.MIN_TICK && index <= ClmmTickMath.MAX_TICK, 'TICK');
        this.index = index;
        this.liquidityGross = new BN(liquidityGross);
        this.liquidityNet = new BN(liquidityNet);
        this.feeGrowthOutsideX = new BN(feeGrowthOutsideX);
        this.feeGrowthOutsideY = new BN(feeGrowthOutsideY);
        this.rewardGrowthsOutside = rewardGrowthsOutside.map((item) => new BN(item));
    }
}

/**
 * A data provider for ticks that is backed by an in-memory array of ticks.
 */
class TickListDataProvider {
    constructor(ticks, tickSpacing) {
        const ticksMapped = ticks.map((t) => t instanceof Tick ? t : new Tick(t));
        TickList.validateList(ticksMapped, tickSpacing);
        this.tickList = new TickList(ticksMapped);
    }
    getTick(tick) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.tickList.getTick(tick);
        });
    }
}

/**
 * A data provider for ticks that is backed by by onchain queries.
 */
class TickOnchainDataProvider {
    constructor({ network, tickManagerId, }) {
        this.network = network;
        this.tickManagerId = tickManagerId;
        this.client = new SuiClient({
            url: getFullnodeUrl(network),
        });
    }
    getTick(index) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const tickObject = yield this.client.getDynamicFieldObject({
                parentId: this.tickManagerId,
                name: {
                    type: `${CONFIGS$4[this.network].i32Type}`,
                    value: {
                        bits: BigInt.asUintN(I32_BITS, BigInt(index)).toString(),
                    },
                },
            });
            invariant(tickObject.data, 'tick not found');
            const rawData = (_b = (_a = tickObject.data) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b['fields'].value.fields;
            return new Tick({
                index,
                liquidityNet: BigInt.asIntN(I128_BITS, BigInt(rawData.liquidity_net.fields.bits)).toString(),
                liquidityGross: rawData.liquidity_gross,
                feeGrowthOutsideX: rawData.fee_growth_outside_x,
                feeGrowthOutsideY: rawData.fee_growth_outside_y,
                rewardGrowthsOutside: rawData.reward_growths_outside,
            });
        });
    }
}

var _FlowXPriceProvider_queue, _FlowXPriceProvider_coinProvider, _FlowXPriceProvider_pendingAggregator;
class FlowXPriceProvider {
    constructor(network) {
        _FlowXPriceProvider_queue.set(this, []);
        _FlowXPriceProvider_coinProvider.set(this, void 0);
        _FlowXPriceProvider_pendingAggregator.set(this, void 0);
        // invariant(network === 'mainnet', 'ONLY_MAINNET');
        __classPrivateFieldSet(this, _FlowXPriceProvider_coinProvider, new CoinProvider(network), "f");
    }
    getPrice(token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (__classPrivateFieldGet(this, _FlowXPriceProvider_queue, "f") == null) {
                __classPrivateFieldSet(this, _FlowXPriceProvider_queue, [], "f");
            }
            const inflightRequest = {
                request: shortedCoinType(token),
                resolve: null,
                reject: null,
            };
            const promise = new Promise((resolve, reject) => {
                inflightRequest.resolve = resolve;
                inflightRequest.reject = reject;
            });
            __classPrivateFieldGet(this, _FlowXPriceProvider_queue, "f").push(inflightRequest);
            if (!__classPrivateFieldGet(this, _FlowXPriceProvider_pendingAggregator, "f")) {
                // Schedule batch for next event loop + short duration
                __classPrivateFieldSet(this, _FlowXPriceProvider_pendingAggregator, setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                    var _a, _b;
                    // Get the current batch and clear it, so new requests
                    // go into the next batch
                    const requests = (_b = (_a = __classPrivateFieldGet(this, _FlowXPriceProvider_queue, "f")) === null || _a === void 0 ? void 0 : _a.slice()) !== null && _b !== void 0 ? _b : [];
                    __classPrivateFieldSet(this, _FlowXPriceProvider_queue, null, "f");
                    __classPrivateFieldSet(this, _FlowXPriceProvider_pendingAggregator, null, "f");
                    const prices = yield __classPrivateFieldGet(this, _FlowXPriceProvider_coinProvider, "f").multiGetPrices(requests.map((inflightRequest) => inflightRequest.request));
                    requests.forEach((inflightRequest, idx) => {
                        var _a;
                        (_a = inflightRequest.resolve) === null || _a === void 0 ? void 0 : _a.call(inflightRequest, prices[idx]);
                    });
                }), 10), "f");
            }
            return promise;
        });
    }
}
_FlowXPriceProvider_queue = new WeakMap(), _FlowXPriceProvider_coinProvider = new WeakMap(), _FlowXPriceProvider_pendingAggregator = new WeakMap();

class I32 {
    constructor(network = 'mainnet') {
        this.network = network;
    }
    create(value, tx) {
        return tx.moveCall({
            target: `${CONFIGS$4[this.network].packageId}::${MODULE_I32}::${value >= 0 ? `from` : `neg_from`}`,
            arguments: [tx.pure.u32(Math.abs(value))],
        });
    }
}

class ClmmPositionManager extends TxBuilder {
    constructor(network = 'mainnet', poolManager) {
        super(network);
        this.network = network;
        this.poolManager = poolManager;
        this.i32 = new I32(this.network);
    }
    openPosition(position) {
        const [tickLowerI32, tickUpperI32] = [
            this.i32.create(position.tickLower, this._tx),
            this.i32.create(position.tickUpper, this._tx),
        ];
        return this._tx.moveCall({
            target: `${CONFIGS$4[this.network].packageId}::${MODULE_POSITION_MANAGER}::open_position`,
            typeArguments: [
                position.amountX.coin.coinType,
                position.amountY.coin.coinType,
            ],
            arguments: [
                this._tx.object(CONFIGS$4[this.network].positionRegistryObject),
                this._tx.object(CONFIGS$4[this.network].poolRegistryObject),
                this._tx.pure.u64(position.pool.fee),
                tickLowerI32,
                tickUpperI32,
                this._tx.object(CONFIGS$4[this.network].versionObject),
            ],
        });
    }
    closePosition(position) {
        this._tx.moveCall({
            target: `${CONFIGS$4[this.network].packageId}::${MODULE_POSITION_MANAGER}::close_position`,
            arguments: [
                this._tx.object(CONFIGS$4[this.network].positionRegistryObject),
                this._tx.object(position.id),
                this._tx.object(CONFIGS$4[this.network].versionObject),
            ],
        });
    }
    increaseLiquidity(position, options) {
        var _a, _b;
        const { amountX: amountXDesired, amountY: amountYDesired } = position.mintAmounts;
        const minimumAmounts = position.mintAmountsWithSlippage(options.slippageTolerance);
        const amountXMin = minimumAmounts.amountX.toString();
        const amountYMin = minimumAmounts.amountY.toString();
        let positionObject;
        if (options.createPosition) {
            positionObject = this.openPosition(position);
        }
        else {
            positionObject = this._tx.object(position.id);
        }
        const [coinXIn, coinYIn] = [
            (_a = options.coinXIn) !== null && _a !== void 0 ? _a : coinWithBalance({
                type: position.amountX.coin.coinType,
                balance: BigInt(amountXDesired.toString()),
                useGasCoin: normalizeStructTag$1(SUI_TYPE_ARG) ===
                    normalizeStructTag$1(position.amountX.coin.coinType),
            })(this._tx),
            (_b = options.coinYIn) !== null && _b !== void 0 ? _b : coinWithBalance({
                type: position.amountY.coin.coinType,
                balance: BigInt(amountYDesired.toString()),
                useGasCoin: normalizeStructTag$1(SUI_TYPE_ARG) ===
                    normalizeStructTag$1(position.amountY.coin.coinType),
            })(this._tx),
        ];
        this._tx.moveCall({
            target: `${CONFIGS$4[this.network].packageId}::${MODULE_POSITION_MANAGER}::increase_liquidity`,
            typeArguments: [
                position.amountX.coin.coinType,
                position.amountY.coin.coinType,
            ],
            arguments: [
                this._tx.object(CONFIGS$4[this.network].poolRegistryObject),
                positionObject,
                coinXIn,
                coinYIn,
                this._tx.pure.u64(amountXMin),
                this._tx.pure.u64(amountYMin),
                this._tx.pure.u64(options.deadline),
                this._tx.object(CONFIGS$4[this.network].versionObject),
                this._tx.object(SUI_CLOCK_OBJECT_ID),
            ],
        });
        if (options.createPosition) {
            return positionObject;
        }
    }
    decreaseLiquidity(position, options) {
        const minimumAmounts = position.burnAmountsWithSlippage(options.slippageTolerance);
        const amountXMin = minimumAmounts.amountX.toString();
        const amountYMin = minimumAmounts.amountY.toString();
        this._tx.moveCall({
            target: `${CONFIGS$4[this.network].packageId}::${MODULE_POSITION_MANAGER}::decrease_liquidity`,
            typeArguments: [
                position.amountX.coin.coinType,
                position.amountY.coin.coinType,
            ],
            arguments: [
                this._tx.object(CONFIGS$4[this.network].poolRegistryObject),
                this._tx.object(position.id),
                this._tx.pure.u128(position.liquidity.toString()),
                this._tx.pure.u64(amountXMin),
                this._tx.pure.u64(amountYMin),
                this._tx.pure.u64(options.deadline),
                this._tx.object(CONFIGS$4[this.network].versionObject),
                this._tx.object(SUI_CLOCK_OBJECT_ID),
            ],
        });
        if (options.collectOptions) {
            return this.collect(position, options.collectOptions);
        }
    }
    collect(position, options) {
        invariant(!options.recipient || isValidSuiAddress(options.recipient), 'RECIPIENT');
        const result = this._tx.moveCall({
            target: `${CONFIGS$4[this.network].packageId}::${MODULE_POSITION_MANAGER}::collect`,
            typeArguments: [
                position.amountX.coin.coinType,
                position.amountY.coin.coinType,
            ],
            arguments: [
                this._tx.object(CONFIGS$4[this.network].poolRegistryObject),
                this._tx.object(position.id),
                this._tx.pure.u64(options.expectedCoinOwedX.quotient.toString()),
                this._tx.pure.u64(options.expectedCoinOwedY.quotient.toString()),
                this._tx.object(CONFIGS$4[this.network].versionObject),
                this._tx.object(SUI_CLOCK_OBJECT_ID),
            ],
        });
        if (options.recipient) {
            this._tx.transferObjects([result[0], result[1]], options.recipient);
        }
        else {
            return result;
        }
    }
    collectPoolReward(position, options) {
        invariant(!options.recipient || isValidSuiAddress(options.recipient), 'RECIPIENT');
        const result = this._tx.moveCall({
            target: `${CONFIGS$4[this.network].packageId}::${MODULE_POSITION_MANAGER}::collect_pool_reward`,
            typeArguments: [
                position.amountX.coin.coinType,
                position.amountY.coin.coinType,
                options.expectedRewardOwed.coin.coinType,
            ],
            arguments: [
                this._tx.object(CONFIGS$4[this.network].poolRegistryObject),
                this._tx.object(position.id),
                this._tx.pure.u64(options.expectedRewardOwed.quotient.toString()),
                this._tx.object(CONFIGS$4[this.network].versionObject),
                this._tx.object(SUI_CLOCK_OBJECT_ID),
            ],
        });
        if (options.recipient) {
            this._tx.transferObjects([result[0]], options.recipient);
        }
        else {
            return result;
        }
    }
    getPosition(positionId) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const positionObject = yield this._client.getObject({
                id: positionId,
                options: {
                    showContent: true,
                    showType: true,
                    showOwner: true,
                },
            });
            invariant(positionObject.data &&
                positionObject.data.type === `${CONFIGS$4[this.network].positionType}`, 'invalid position');
            const rawData = (_a = positionObject.data.content) === null || _a === void 0 ? void 0 : _a['fields'];
            const poolInfo = yield this.poolManager.getPoolDetail(rawData.pool_id);
            return new ClmmPosition({
                objectId: positionObject.data.objectId,
                owner: (_b = positionObject.data.owner) === null || _b === void 0 ? void 0 : _b['AddressOwner'],
                pool: poolInfo,
                tickLower: Number(BigInt.asIntN(32, BigInt(rawData.tick_lower_index.fields.bits))),
                tickUpper: Number(BigInt.asIntN(32, BigInt(rawData.tick_upper_index.fields.bits))),
                liquidity: rawData.liquidity,
                coinsOwedX: rawData.coins_owed_x,
                coinsOwedY: rawData.coins_owed_y,
                feeGrowthInsideXLast: rawData.fee_growth_inside_x_last,
                feeGrowthInsideYLast: rawData.fee_growth_inside_y_last,
                rewardInfos: poolInfo.poolRewards.map((_, idx) => {
                    var _a, _b;
                    return ({
                        coinsOwedReward: ((_a = rawData.reward_infos[idx]) === null || _a === void 0 ? void 0 : _a.fields.coins_owed_reward) || '0',
                        rewardGrowthInsideLast: ((_b = rawData.reward_infos[idx]) === null || _b === void 0 ? void 0 : _b.fields.reward_growth_inside_last) || '0',
                    });
                }),
            });
        });
    }
    getUserPositions(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const listPositionOnchain = yield this.getFullyOwnedObjects(address, {
                showContent: true,
            }, {
                StructType: CONFIGS$4[this.network].positionType,
            });
            const poolIds = listPositionOnchain
                .map((item) => { var _a, _b; return ((_b = (_a = item.data) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b['fields']).pool_id; })
                .filter((poolId) => !!poolId);
            const poolInfos = yield this.poolManager.getPoolDetails(poolIds);
            //INIT POSITION
            return listPositionOnchain.map((item) => {
                var _a;
                invariant(item.data, 'invalid position');
                const rawData = (_a = item.data.content) === null || _a === void 0 ? void 0 : _a['fields'];
                const pool = poolInfos.find((poolInfo) => poolInfo.id == rawData.pool_id);
                invariant(pool, 'pool not found');
                return new ClmmPosition({
                    objectId: item.data.objectId,
                    owner: address,
                    pool: pool,
                    tickLower: Number(BigInt.asIntN(32, BigInt(rawData.tick_lower_index.fields.bits))),
                    tickUpper: Number(BigInt.asIntN(32, BigInt(rawData.tick_upper_index.fields.bits))),
                    liquidity: rawData.liquidity,
                    coinsOwedX: rawData.coins_owed_x,
                    coinsOwedY: rawData.coins_owed_y,
                    feeGrowthInsideXLast: rawData.fee_growth_inside_x_last,
                    feeGrowthInsideYLast: rawData.fee_growth_inside_y_last,
                    rewardInfos: pool.poolRewards.map((_, idx) => {
                        var _a, _b;
                        return ({
                            coinsOwedReward: ((_a = rawData.reward_infos[idx]) === null || _a === void 0 ? void 0 : _a.fields.coins_owed_reward) || '0',
                            rewardGrowthInsideLast: ((_b = rawData.reward_infos[idx]) === null || _b === void 0 ? void 0 : _b.fields.reward_growth_inside_last) || '0',
                        });
                    }),
                });
            });
        });
    }
    getPositionReward(positions_1) {
        return __awaiter(this, arguments, void 0, function* (positions, maxQuery = 10) {
            var _a;
            //GET POSITION REWARD
            let positionOnchainResult = [];
            const batches = chunk(positions, maxQuery);
            for (const positions of batches) {
                this.tx(new Transaction());
                for (const position of positions) {
                    this.collect(position, {
                        expectedCoinOwedX: CoinAmount.fromRawAmount(position.pool.coins[0], MaxUint64),
                        expectedCoinOwedY: CoinAmount.fromRawAmount(position.pool.coins[1], MaxUint64),
                    });
                    (_a = position.pool.poolRewards) === null || _a === void 0 ? void 0 : _a.map((it) => {
                        this.collectPoolReward(position, {
                            expectedRewardOwed: CoinAmount.fromRawAmount(it.coin, MaxUint64),
                        });
                    });
                }
                positionOnchainResult.push(yield this._client.devInspectTransactionBlock({
                    transactionBlock: this.getTx(),
                    sender: positions[0].owner,
                }));
            }
            positionOnchainResult = positionOnchainResult
                .map((it) => it.events)
                .flat();
            for (let i = 0; i < positions.length; i++) {
                const position = positions[i];
                position.setFeeReward(positionOnchainResult
                    .filter((it) => it.parsedJson.position_id == position.id &&
                    it.type == CONFIGS$4[this.network].poolFeeCollectEventType)
                    .map((it) => [
                    CoinAmount.fromRawAmount(position.amountX.coin, it.parsedJson.amount_x),
                    CoinAmount.fromRawAmount(position.amountY.coin, it.parsedJson.amount_y),
                ])
                    .flat());
                position.setIncentiveReward(positionOnchainResult
                    .filter((it) => it.parsedJson.position_id == position.id &&
                    it.type == CONFIGS$4[this.network].poolRewardCollectEventType)
                    .map((it) => CoinAmount.fromRawAmount(new Coin(it.parsedJson.reward_coin_type.name), it.parsedJson.amount))
                    .flat());
            }
            return positions;
        });
    }
}

class ClmmPoolReward {
    constructor(coin, endedAtSeconds, rewardPerSeconds, totalReward, lastUpdateTime, rewardGrowthGlobal) {
        this.coin = coin;
        this.endedAtSeconds = endedAtSeconds;
        this.rewardPerSeconds = rewardPerSeconds;
        this.totalReward = totalReward;
        this.lastUpdateTime = lastUpdateTime;
        this.rewardGrowthGlobal = rewardGrowthGlobal;
        //
    }
}

class ClmmPoolManager extends TxBuilder {
    constructor(network = 'mainnet') {
        super(network);
        this.network = network;
    }
    createPool(pool) {
        const tx = this._tx;
        tx.moveCall({
            target: `${CONFIGS$4[this.network].packageId}::${MODULE_POOL_MANAGER}::create_and_initialize_pool`,
            typeArguments: [pool.coinX.coinType, pool.coinY.coinType],
            arguments: [
                tx.object(CONFIGS$4[this.network].poolRegistryObject),
                tx.pure.u64(pool.fee),
                tx.pure.u128(pool.sqrtPriceX64.toString()),
                tx.object(CONFIGS$4[this.network].versionObject),
                tx.object(SUI_CLOCK_OBJECT_ID),
            ],
        });
    }
    createPoolV2(pool) {
        return __awaiter(this, void 0, void 0, function* () {
            const [metadataX, metadataY] = yield Promise.all([
                this._client
                    .getCoinMetadata({
                    coinType: pool.coinX.coinType,
                })
                    .catch(() => null),
                this._client
                    .getCoinMetadata({
                    coinType: pool.coinY.coinType,
                })
                    .catch(() => null),
            ]);
            invariant(metadataX && metadataY && metadataX.id && metadataY.id, 'Failed to fetch coin metadata for pool coins');
            const tx = this._tx;
            tx.moveCall({
                target: `${CONFIGS$4[this.network].packageId}::${MODULE_POOL_MANAGER}::create_and_initialize_pool_v2`,
                typeArguments: [pool.coinX.coinType, pool.coinY.coinType],
                arguments: [
                    tx.object(CONFIGS$4[this.network].poolRegistryObject),
                    tx.pure.u64(pool.fee),
                    tx.pure.u128(pool.sqrtPriceX64.toString()),
                    tx.object(metadataX.id),
                    tx.object(metadataY.id),
                    tx.object(CONFIGS$4[this.network].versionObject),
                    tx.object(SUI_CLOCK_OBJECT_ID),
                ],
            });
        });
    }
    createPoolV3(pool) {
        const tx = this._tx;
        tx.moveCall({
            target: `${CONFIGS$4[this.network].packageId}::${MODULE_POOL_MANAGER}::create_and_initialize_pool_v3`,
            typeArguments: [pool.coinX.coinType, pool.coinY.coinType],
            arguments: [
                tx.object(CONFIGS$4[this.network].poolRegistryObject),
                tx.pure.u64(pool.fee),
                tx.pure.u128(pool.sqrtPriceX64.toString()),
                tx.object(CONFIGS$4[this.network].versionObject),
                tx.object(SUI_CLOCK_OBJECT_ID),
            ],
        });
    }
    getPoolDetail(poolId) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const poolObject = yield this._client.getObject({
                id: poolId,
                options: {
                    showContent: true,
                    showType: true,
                },
            });
            invariant(poolObject.data &&
                ((_a = poolObject.data.type) === null || _a === void 0 ? void 0 : _a.startsWith(`${CONFIGS$4[this.network].poolType}`)), 'invalid position');
            const rawData = (_b = poolObject.data.content) === null || _b === void 0 ? void 0 : _b['fields'];
            const poolRewards = rawData.reward_infos.map((reward) => new ClmmPoolReward(new Coin(reward.fields.reward_coin_type.fields.name), Number(reward.fields.ended_at_seconds), reward.fields.reward_per_seconds, reward.fields.total_reward, Number(reward.fields.last_update_time), reward.fields.reward_growth_global));
            const poolCoins = yield Promise.all([
                fetchCoin(normalizeStructTag$1(rawData.coin_type_x.fields.name))(this._client),
                fetchCoin(normalizeStructTag$1(rawData.coin_type_y.fields.name))(this._client),
            ]);
            return new ClmmPool(poolObject.data.objectId, poolCoins, poolRewards, [rawData.reserve_x, rawData.reserve_y], parseInt(rawData.swap_fee_rate), rawData.sqrt_price, Number(BigInt.asIntN(32, BigInt(rawData.tick_index.fields.bits))), rawData.liquidity, rawData.fee_growth_global_x, rawData.fee_growth_global_y, new TickOnchainDataProvider({
                network: this.network,
                tickManagerId: rawData.ticks.fields.id.id,
            }));
        });
    }
    getPoolDetails(poolIds) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.getMultipleIds(_.uniq(poolIds))).map((pool) => {
                const poolCoins = [
                    new Coin(normalizeStructTag$1(pool.data.content.fields.coin_type_x.fields.name)),
                    new Coin(normalizeStructTag$1(pool.data.content.fields.coin_type_y.fields.name)),
                ];
                const poolRewards = pool.data.content.fields.reward_infos.map((reward) => new ClmmPoolReward(new Coin(reward.fields.reward_coin_type.fields.name), Number(reward.fields.ended_at_seconds), reward.fields.reward_per_seconds, reward.fields.total_reward, Number(reward.fields.last_update_time), reward.fields.reward_growth_global));
                return new ClmmPool(pool.data.objectId, poolCoins, poolRewards, [
                    pool.data.content.fields.reserve_x,
                    pool.data.content.fields.reserve_y,
                ], parseInt(pool.data.content.fields.swap_fee_rate), pool.data.content.fields.sqrt_price, Number(BigInt.asIntN(32, pool.data.content.fields.tick_index.fields.bits.toString())), pool.data.content.fields.liquidity, pool.data.content.fields.fee_growth_global_x, pool.data.content.fields.fee_growth_global_y, new TickOnchainDataProvider({
                    network: this.network,
                    tickManagerId: pool.data.content.fields.ticks.fields.id.id,
                }));
            });
        });
    }
    getPools() {
        return __awaiter(this, void 0, void 0, function* () {
            const dynamicFields = yield this.getFullyDynamicFields(CONFIGS$4[this.network].poolRegistryObject);
            const poolObjectIds = dynamicFields
                .filter((df) => df.objectType.startsWith(`${CONFIGS$4[this.network].poolType}`))
                .map((it) => it.objectId);
            return this.getPoolDetails(poolObjectIds);
        });
    }
}

class Rebalancer {
    constructor(options) {
        this.decreaseLiquidityAndCollect = (position, { slippageTolerance }) => (tx) => {
            var _a;
            this.positionManager.tx(tx);
            this.positionManager.decreaseLiquidity(position, {
                slippageTolerance: slippageTolerance,
                deadline: Number.MAX_SAFE_INTEGER,
            });
            const collectResult = this.positionManager.collect(position, {
                expectedCoinOwedX: CoinAmount.fromRawAmount(position.amountX.coin, MaxUint64),
                expectedCoinOwedY: CoinAmount.fromRawAmount(position.amountY.coin, MaxUint64),
            });
            (_a = position.pool.poolRewards) === null || _a === void 0 ? void 0 : _a.map((poolReward) => {
                this.positionManager.collectPoolReward(position, {
                    expectedRewardOwed: CoinAmount.fromRawAmount(poolReward.coin, MaxUint64),
                    recipient: position.owner,
                });
            });
            this.positionManager.closePosition(position);
            return collectResult;
        };
        this.rebalance = (position, tickLower, tickUpper, options) => (tx) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            const client = (options === null || options === void 0 ? void 0 : options.client) ||
                new SuiClient({
                    url: getFullnodeUrl(this.network),
                });
            const priceProvider = (options === null || options === void 0 ? void 0 : options.priceProvider) || new FlowXPriceProvider(this.network);
            const minZapAmounts = (options === null || options === void 0 ? void 0 : options.minZapAmounts) || {
                amountX: CoinAmount.ONE(position.pool.coinX).quotient,
                amountY: CoinAmount.ONE(position.pool.coinY).quotient,
            };
            const slippageTolerance = new Percent((_a = options === null || options === void 0 ? void 0 : options.slippageTolerance) !== null && _a !== void 0 ? _a : BPS$2, BPS$2);
            const feeAmounts = yield position.getFees();
            const burnAmounts = {
                amountX: position.mintAmounts.amountX.add(feeAmounts.amountX),
                amountY: position.mintAmounts.amountY.add(feeAmounts.amountY),
            };
            let positionThatWillBeCreated = ClmmPosition.fromAmounts({
                owner: position.owner,
                pool: position.pool,
                tickLower,
                tickUpper,
                amountX: burnAmounts.amountX,
                amountY: burnAmounts.amountY,
                useFullPrecision: false,
            });
            const expectedMintAmounts = {
                amountX: burnAmounts.amountX.clone(),
                amountY: burnAmounts.amountY.clone(),
            };
            const remainingX = burnAmounts.amountX.sub(positionThatWillBeCreated.mintAmounts.amountX);
            const remainingY = burnAmounts.amountY.sub(positionThatWillBeCreated.mintAmounts.amountY);
            const [coinXType, coinYType] = [
                position.pool.coins[0].coinType,
                position.pool.coins[1].coinType,
            ];
            const [collectedX, collectedY] = this.decreaseLiquidityAndCollect(position, {
                slippageTolerance,
            })(tx);
            //Only one of the two assets, X or Y, is redundant when liquidity is added.
            if (remainingX.gt(new BN(minZapAmounts.amountX))) {
                const commission = (options === null || options === void 0 ? void 0 : options.commission) ? new Commission(options.commission.address, new Coin(coinYType), CommissionType.PERCENTAGE, options.commission.fee, false) : undefined;
                const zapAmount = yield ZapCalculator.zapAmount({
                    pool: position.pool,
                    tickLower,
                    tickUpper,
                    amount: remainingX,
                    isCoinX: true,
                    priceProvider,
                });
                const quote = yield this.quoter.getRoutes({
                    tokenIn: coinXType,
                    tokenOut: coinYType,
                    amountIn: zapAmount.toString(),
                    includeSources: options === null || options === void 0 ? void 0 : options.includeSources,
                    excludeSources: (options === null || options === void 0 ? void 0 : options.excludeSources) || [],
                    excludePools: [position.pool.id],
                    commission
                });
                this.checkPriceImpact(quote);
                expectedMintAmounts.amountX =
                    expectedMintAmounts.amountX.sub(zapAmount);
                expectedMintAmounts.amountY = expectedMintAmounts.amountY.add(new BN(quote.amountOut));
                const [zapCoin] = tx.splitCoins(collectedX, [zapAmount.toString()]);
                const tradeBuilder = new TradeBuilder(this.network, quote.routes)
                    .slippage(slippageTolerance.numerator.toNumber());
                if (commission) {
                    tradeBuilder.commission(commission);
                }
                const trade = tradeBuilder.build();
                const coinYOut = (yield trade.swap({
                    tx,
                    coinIn: zapCoin,
                    client: client,
                }));
                tx.mergeCoins(collectedY, [coinYOut]);
            }
            else if (remainingY.gt(new BN(minZapAmounts.amountY))) {
                const commission = (options === null || options === void 0 ? void 0 : options.commission) ? new Commission(options.commission.address, new Coin(coinXType), CommissionType.PERCENTAGE, options.commission.fee, false) : undefined;
                const zapAmount = yield ZapCalculator.zapAmount({
                    pool: position.pool,
                    tickLower,
                    tickUpper,
                    amount: remainingY,
                    isCoinX: false,
                    priceProvider,
                });
                const quote = yield this.quoter.getRoutes({
                    tokenIn: coinYType,
                    tokenOut: coinXType,
                    amountIn: zapAmount.toString(),
                    includeSources: options === null || options === void 0 ? void 0 : options.includeSources,
                    excludeSources: (options === null || options === void 0 ? void 0 : options.excludeSources) || [],
                    excludePools: [position.pool.id],
                    commission
                });
                this.checkPriceImpact(quote);
                expectedMintAmounts.amountY =
                    expectedMintAmounts.amountY.sub(zapAmount);
                expectedMintAmounts.amountX = expectedMintAmounts.amountX.add(new BN(quote.amountOut));
                const [zapCoin] = tx.splitCoins(collectedY, [zapAmount.toString()]);
                const tradeBuilder = new TradeBuilder(this.network, quote.routes)
                    .slippage(slippageTolerance.numerator.toNumber());
                if (commission) {
                    tradeBuilder.commission(commission);
                }
                const trade = tradeBuilder.build();
                const coinXOut = (yield trade.swap({
                    tx,
                    coinIn: zapCoin,
                    client: client,
                }));
                tx.mergeCoins(collectedX, [coinXOut]);
            }
            positionThatWillBeCreated = ClmmPosition.fromAmounts({
                owner: position.owner,
                pool: position.pool,
                tickLower,
                tickUpper,
                amountX: expectedMintAmounts.amountX,
                amountY: expectedMintAmounts.amountY,
                useFullPrecision: false,
            });
            const newPositionObject = this.positionManager.increaseLiquidity(positionThatWillBeCreated, {
                coinXIn: collectedX,
                coinYIn: collectedY,
                slippageTolerance,
                deadline: Number.MAX_SAFE_INTEGER,
                createPosition: true,
            });
            return newPositionObject;
        });
        this.network = options.network;
        this.quoter = new AggregatorQuoter(options.network);
        this.positionManager = new ClmmPositionManager(options.network, new ClmmPoolManager(options.network));
    }
    checkPriceImpact(quote, priceImpactPercentThreshold) {
        invariant(!priceImpactPercentThreshold ||
            quote.priceImpact.gt(priceImpactPercentThreshold), 'exceeded price impact threshold');
    }
}

const CONFIGS$3 = {
    mainnet: {
        packageId: '0xafd06ed69a706eabb66f2a1f9305afc0a317ae95e5bfe8ae9868b23b17f7887b',
        orderbookObject: '0x9a1b06515073196282145f1c4964267bc560f33ec61c3e656a126df873238d0e',
        adminCapObject: '0x763998260d9b8ed6120fd53d8e13c462f211bc2172fd0a5b83b02aa70e14e40c',
    },
    testnet: {
        packageId: '0x1aaf24390e4249783bee3f4f8d6c14b3b3f34edc7008d29f45bc3badfcbd4f83',
        orderbookObject: '0x690c540ed129dc02471a166353f07f850972a1e5ec2a7007d514d25b4c274c03',
        adminCapObject: '0xa9d655a3fa1b0abb20342ba3f48bebda6398a42c7ff2a3b7cd14ab943ffbae16',
    },
};

class LimitOrderBuilder extends TxBuilder {
    constructor(network) {
        super(network);
    }
    coinMaker(coin) {
        this._coinMaker = coin;
        return this;
    }
    coinTaker(coin) {
        this._coinTaker = coin;
        return this;
    }
    placeOrder(args) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (args.allowedPartialFills === undefined ||
                args.allowedPartialFills === null) {
                args.allowedPartialFills = true;
            }
            invariant(this._coinMaker, 'COIN_MAKER_NOT_FOUND');
            invariant(this._coinTaker, 'COIN_TAKER_NOT_FOUND');
            invariant(!new BigNumber(args.amountOutExpected.toString()).eq(0), 'INVALID_EXPECTED_AMOUNT');
            invariant(args.expiredTimestamp == 0 ||
                (args.expiredTimestamp != 0 && args.expiredTimestamp > Date.now()), 'INVALID_EXPIRED_TIMESTAMP');
            invariant(!this._coinIn && !new BigNumber(((_a = args.amountIn) !== null && _a !== void 0 ? _a : '0').toString()).eq(0), 'INVALID_INPUT_AMOUNT');
            invariant(!this._coinIn && this._sender, 'SENDER_NOT_FOUND');
            const tx = this._tx;
            //take coin in from wallet if not input
            if (!this._coinIn && args.amountIn) {
                this._coinIn = yield this._coinMaker.take({
                    amount: args.amountIn,
                    owner: this._sender,
                    client: this._client,
                    tx: tx,
                });
            }
            const addressOpts = tx.moveCall({
                target: `0x1::option::none`,
                typeArguments: ['address'],
                arguments: [],
            });
            const addressOpts2 = tx.moveCall({
                target: `0x1::option::none`,
                typeArguments: ['address'],
                arguments: [],
            });
            return tx.moveCall({
                target: `${CONFIGS$3[this.network].packageId}::orderbook::place_order`,
                typeArguments: [this._coinMaker.coinType, this._coinTaker.coinType],
                arguments: [
                    tx.object(CONFIGS$3[this.network].orderbookObject),
                    tx.pure.u64(Math.floor(Math.random() * BPS$2.toNumber())),
                    addressOpts,
                    addressOpts2,
                    tx.pure.u64(args.amountOutExpected.toString()),
                    tx.pure.u64(args.expiredTimestamp),
                    tx.pure.bool(args.allowedPartialFills),
                    this._coinIn,
                    tx.object(SUI_CLOCK_OBJECT_ID$1),
                ],
            });
        });
    }
    cancelOrder(args) {
        return __awaiter(this, void 0, void 0, function* () {
            invariant(this._coinMaker, 'COIN_MAKER_NOT_FOUND');
            invariant(args.orderId, 'INVALID_ORDER_ID');
            const tx = this._tx;
            return tx.moveCall({
                target: `${CONFIGS$3[this.network].packageId}::orderbook::cancel_order`,
                typeArguments: [this._coinMaker.coinType],
                arguments: [
                    tx.object(CONFIGS$3[this.network].orderbookObject),
                    tx.pure.u64(args.orderId.toString()),
                ],
            });
        });
    }
    takeOrder(args) {
        return __awaiter(this, void 0, void 0, function* () {
            invariant(this._coinMaker, 'COIN_MAKER_NOT_FOUND');
            invariant(this._coinTaker, 'COIN_TAKER_NOT_FOUND');
            invariant(args.orderId, 'INVALID_ORDER_ID');
            const tx = this._tx;
            return tx.moveCall({
                target: `${CONFIGS$3[this.network].packageId}::orderbook::take_order`,
                typeArguments: [this._coinMaker.coinType],
                arguments: [
                    tx.object(CONFIGS$3[this.network].orderbookObject),
                    tx.pure.u64(args.orderId.toString()),
                    tx.pure.u64(args.amount.toString()),
                    tx.object(SUI_CLOCK_OBJECT_ID$1),
                ],
            });
        });
    }
    fillOrder(args) {
        return __awaiter(this, void 0, void 0, function* () {
            invariant(this._coinTaker, 'COIN_TAKER_NOT_FOUND');
            const tx = this._tx;
            return tx.moveCall({
                target: `${CONFIGS$3[this.network].packageId}::orderbook::fill_order`,
                typeArguments: [this._coinTaker.coinType],
                arguments: [
                    tx.object(CONFIGS$3[this.network].orderbookObject),
                    args.receipt,
                    args.filled,
                ],
            });
        });
    }
    getOrders(args) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const tx = this._tx;
            const limit = tx.moveCall({
                target: `0x1::option::some`,
                typeArguments: ['u64'],
                arguments: [tx.pure.u64(args.limit)],
            });
            let cursor;
            if (args.cursor) {
                cursor = tx.moveCall({
                    target: `0x1::option::some`,
                    typeArguments: ['u64'],
                    arguments: [tx.pure.u64(args.cursor)],
                });
            }
            else {
                cursor = tx.moveCall({
                    target: `0x1::option::none`,
                    typeArguments: ['u64'],
                    arguments: [],
                });
            }
            const desc = tx.moveCall({
                target: `0x1::option::some`,
                typeArguments: ['bool'],
                arguments: [tx.pure.bool((_a = args.desc) !== null && _a !== void 0 ? _a : false)],
            });
            return tx.moveCall({
                target: `${CONFIGS$3[this.network].packageId}::order_query::query_orders`,
                typeArguments: [],
                arguments: [
                    tx.object(CONFIGS$3[this.network].orderbookObject),
                    tx.pure.address(args.owner),
                    cursor,
                    limit,
                    desc,
                ],
            });
        });
    }
    getOrder(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = this._tx;
            return tx.moveCall({
                target: `${CONFIGS$3[this.network].packageId}::orderbook::get_order`,
                typeArguments: [],
                arguments: [
                    tx.object(CONFIGS$3[this.network].orderbookObject),
                    tx.pure.u64(args.orderId.toString()),
                ],
            });
        });
    }
    orderExists(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = this._tx;
            return tx.moveCall({
                target: `${CONFIGS$3[this.network].packageId}::orderbook::order_exists`,
                typeArguments: [],
                arguments: [
                    tx.object(CONFIGS$3[this.network].orderbookObject),
                    tx.pure.u64(args.orderId.toString()),
                ],
            });
        });
    }
}

const TypeNameBCS$1 = bcs.struct('TypeName', {
    name: bcs.String,
});
const OrderBCS = bcs.struct('Order', {
    order_id: bcs.U64,
    client_order_id: bcs.U64,
    maker_asset: TypeNameBCS$1,
    taker_asset: TypeNameBCS$1,
    maker: bcs.Address,
    recipient: bcs.Address,
    allowed_taker: bcs.option(bcs.Address),
    making_amount: bcs.U64,
    remaining_amount: bcs.U64,
    taking_amount: bcs.U64,
    expires_timestamp: bcs.U64,
    allowed_partial_fills: bcs.Bool,
});
const QueryResultBCS$1 = bcs.struct('QueryResult', {
    orders: bcs.vector(OrderBCS),
    cursor: bcs.option(bcs.U64),
    total: bcs.U64,
});

class Plan {
    constructor(info) {
        this.info = info;
    }
}

var PlanStatus;
(function (PlanStatus) {
    PlanStatus["ONGOING"] = "ONGOING";
    PlanStatus["PAUSED"] = "PAUSED";
    PlanStatus["COMPLETED"] = "COMPLETED";
    PlanStatus["REMOVED"] = "REMOVED";
})(PlanStatus || (PlanStatus = {}));
var SubscriptionCycle;
(function (SubscriptionCycle) {
    SubscriptionCycle["MINUTE"] = "MINUTE";
    SubscriptionCycle["HOUR"] = "HOUR";
    SubscriptionCycle["DAY"] = "DAY";
    SubscriptionCycle["WEEK"] = "WEEK";
    SubscriptionCycle["MONTH"] = "MONTH";
})(SubscriptionCycle || (SubscriptionCycle = {}));

/// timestamp
const ONE_MINUTE = 1 * 60 * 1000;
const ONE_HOUR = 1 * 60 * ONE_MINUTE;
const ONE_DAY = 24 * ONE_HOUR;
const ONE_WEEK = 7 * ONE_DAY;
const ONE_MONTH = 30 * ONE_DAY;
const MODULE_AUTO_INVEST = 'auto_invest';
const MODULE_PLAN_QUERY = 'plan_query';
const MAPPING_PACKAGE_ID = {
    testnet: '0xea7df56576fda00ae3c430fa83c62b7f95927e0c2e4616d011b869671a58877f',
    mainnet: '0xf28367fb390c9bec321e3e4179073aeb166d8173eb604346ccbc86faa28820f2',
};
const MAPPING_INVESTMENT_OBJECT_ID = {
    testnet: '0xa01d5130ce9479dfb57a0e3b9cca21200c068b8f28d394f1f6f03aae0a817a51',
    mainnet: '0x4f617352b62446d0c866dd31ec27f87685295e21204df54d5cecfe941578fff0',
};
const FLOAT_SCALING = 1000000000;

class MissingImplementation extends Error {
    constructor(key) {
        super(`Missing implementation for ${key}`);
        Object.setPrototypeOf(this, MissingImplementation.prototype);
    }
}
class MissingConfiguration extends Error {
    constructor(key, value) {
        super(`Missing configuration for ${key}: ${value}`);
        Object.setPrototypeOf(this, MissingConfiguration.prototype);
    }
}

const calculateSubscriptionInterval = (cycle, quantityBig) => {
    const quantity = Number(quantityBig);
    switch (cycle) {
        case SubscriptionCycle.MINUTE:
            return quantity * ONE_MINUTE;
        case SubscriptionCycle.HOUR:
            return quantity * ONE_HOUR;
        case SubscriptionCycle.DAY:
            return quantity * ONE_DAY;
        case SubscriptionCycle.WEEK:
            return quantity * ONE_WEEK;
        case SubscriptionCycle.MONTH:
            return quantity * ONE_MONTH;
        default:
            throw new MissingImplementation(cycle);
    }
};
const calculateExecutionPrice = (investedAmount, purchasedAmount) => {
    const BN = BigNumber.clone();
    BN.set({
        ROUNDING_MODE: BigNumber.ROUND_FLOOR,
    });
    return new BN(purchasedAmount)
        .multipliedBy(FLOAT_SCALING)
        .div(investedAmount)
        .toFixed();
};

class PlanBuilder {
    constructor() {
        this.info = {};
    }
    setPlanId(planId) {
        this.info.planId = planId;
        return this;
    }
    setSubscriptionAmount(subscriptionAmount) {
        this.info.subscriptionAmount = subscriptionAmount;
        return this;
    }
    setSubscriptionStartTime(subscriptionStartTime) {
        this.info.subscriptionStartTime = subscriptionStartTime;
        return this;
    }
    setSubscriptionCycle(cycle, quantity) {
        this.info.subscriptionInterval = calculateSubscriptionInterval(cycle, quantity);
        return this;
    }
    setExecutionCount(count) {
        this.info.executionCount = count;
        return this;
    }
    setExecutionLimit(limit) {
        this.info.executionLimit = limit;
        return this;
    }
    setAveragePrice(avgPrice) {
        this.info.averagePrice = avgPrice;
        return this;
    }
    setTotalPurchasedAmount(totalPurchasedAmount) {
        this.info.totalPurchasedAmount = totalPurchasedAmount;
        return this;
    }
    setOwner(owner) {
        this.info.owner = owner;
        return this;
    }
    setReceiver(receiver) {
        this.info.receiver = receiver;
        return this;
    }
    setSourceAsset(sourceAsset) {
        this.info.sourceAsset = sourceAsset;
        return this;
    }
    setTargetAsset(targetAsset) {
        this.info.targetAsset = targetAsset;
        return this;
    }
    setCreationTime(creationTime) {
        this.info.creationTime = creationTime;
        return this;
    }
    setStatus(status) {
        this.info.status = status;
        return this;
    }
    build() {
        var _a, _b, _c, _d;
        invariant(this.info.subscriptionAmount != undefined, 'subscriptionAmount not set');
        invariant(this.info.subscriptionInterval != undefined, 'subscriptionInterval not set');
        invariant(this.info.sourceAsset != undefined, 'sourceAsset not set');
        invariant(this.info.targetAsset != undefined, 'targetAsset not set');
        invariant(isNil(this.info.owner) || isValidSuiAddress(this.info.owner), 'invalid owner');
        invariant(isNil(this.info.receiver) || isValidSuiAddress(this.info.receiver), 'invalid receiver');
        parseStructTag(this.info.sourceAsset);
        parseStructTag(this.info.targetAsset);
        return new Plan({
            planId: (_a = this.info.planId) !== null && _a !== void 0 ? _a : '1',
            subscriptionAmount: this.info.subscriptionAmount,
            subscriptionStartTime: this.info.subscriptionStartTime,
            subscriptionInterval: this.info.subscriptionInterval,
            executionCount: (_b = this.info.executionCount) !== null && _b !== void 0 ? _b : 0,
            executionLimit: this.info.executionLimit,
            averagePrice: this.info.averagePrice,
            totalPurchasedAmount: this.info.totalPurchasedAmount,
            owner: this.info.owner,
            receiver: this.info.receiver,
            sourceAsset: this.info.sourceAsset,
            targetAsset: this.info.targetAsset,
            creationTime: (_c = this.info.creationTime) !== null && _c !== void 0 ? _c : 0,
            status: (_d = this.info.status) !== null && _d !== void 0 ? _d : PlanStatus.ONGOING,
        });
    }
}

const TypeNameBCS = bcs.struct('TypeName', {
    name: bcs.String,
});
const PlanBCS = bcs.struct('Plan', {
    plan_id: bcs.U64,
    subscription_amount: bcs.U64,
    subscription_interval: bcs.U64,
    next_execution_time: bcs.U64,
    execution_count: bcs.U64,
    execution_limit: bcs.U64,
    average_price: bcs.U64,
    total_purchased_amount: bcs.U64,
    creation_time: bcs.U64,
    owner: bcs.Address,
    receiver: bcs.Address,
    source_asset: TypeNameBCS,
    target_asset: TypeNameBCS,
    paused: bcs.Bool,
});
const QueryResultBCS = bcs.struct('QueryResult', {
    plans: bcs.vector(PlanBCS),
    cursor: bcs.option(bcs.U64),
    has_nex_page: bcs.Bool,
    total: bcs.U64,
});

class AutoInvest extends TxBuilder {
    constructor(network) {
        super(network);
        if (MAPPING_PACKAGE_ID[network] == undefined) {
            throw new MissingConfiguration('packageId', network);
        }
        this.packageId = MAPPING_PACKAGE_ID[network];
        if (MAPPING_INVESTMENT_OBJECT_ID[network] == undefined) {
            throw new MissingConfiguration('investmentObjectId', network);
        }
        this.investmentObjectId = MAPPING_INVESTMENT_OBJECT_ID[network];
    }
    deposit(coin) {
        const tx = this.getTx();
        tx.moveCall({
            target: `${this.packageId}::${MODULE_AUTO_INVEST}::deposit`,
            typeArguments: [coin.type],
            arguments: [
                tx.object(this.investmentObjectId),
                typeof coin.object === 'string' ? tx.object(coin.object) : coin.object,
            ],
        });
    }
    withdraw(coinAmount) {
        const tx = this.getTx();
        const withdrawn = tx.moveCall({
            target: `${this.packageId}::${MODULE_AUTO_INVEST}::withdraw`,
            typeArguments: [coinAmount.type],
            arguments: [
                tx.object(this.investmentObjectId),
                tx.pure.u64(coinAmount.amount.toString()),
            ],
        });
        return {
            withdrawn,
        };
    }
    createPlan(plan) {
        var _a, _b, _c;
        const tx = this.getTx();
        const subscriptionStartTimeOpt = this.createU64Option((_a = plan.info.subscriptionStartTime) === null || _a === void 0 ? void 0 : _a.toString());
        const executionLimitOpt = this.createU64Option((_b = plan.info.executionLimit) === null || _b === void 0 ? void 0 : _b.toString());
        const receiverOpt = this.createAddressOption((_c = plan.info.receiver) === null || _c === void 0 ? void 0 : _c.toString());
        tx.moveCall({
            target: `${this.packageId}::${MODULE_AUTO_INVEST}::create_plan`,
            typeArguments: [plan.info.sourceAsset, plan.info.targetAsset],
            arguments: [
                tx.object(this.investmentObjectId),
                tx.pure.u64(plan.info.subscriptionAmount.toString()),
                tx.pure.u64(plan.info.subscriptionInterval),
                subscriptionStartTimeOpt,
                executionLimitOpt,
                receiverOpt,
                tx.object(SUI_CLOCK_OBJECT_ID),
            ],
        });
    }
    takePlan(plan) {
        const tx = this.getTx();
        const [sourceCoin, receipt] = tx.moveCall({
            target: `${this.packageId}::${MODULE_AUTO_INVEST}::take_plan`,
            typeArguments: [plan.info.sourceAsset],
            arguments: [
                tx.object(this.investmentObjectId),
                tx.pure.u64(plan.info.planId),
                tx.object(SUI_CLOCK_OBJECT_ID),
            ],
        });
        return {
            sourceCoin,
            receipt,
        };
    }
    executePlan(plan, executionReceipt, purchasedCoin) {
        const tx = this.getTx();
        tx.moveCall({
            target: `${this.packageId}::${MODULE_AUTO_INVEST}::execute_plan`,
            typeArguments: [plan.info.targetAsset],
            arguments: [
                tx.object(this.investmentObjectId),
                executionReceipt,
                purchasedCoin,
            ],
        });
    }
    removePlan(identifier) {
        const tx = this.getTx();
        tx.moveCall({
            target: `${this.packageId}::${MODULE_AUTO_INVEST}::remove_plan`,
            typeArguments: [],
            arguments: [
                tx.object(this.investmentObjectId),
                tx.pure.u64(identifier.planId),
            ],
        });
    }
    removePlanAndWithdraw(identifier, coinType) {
        const tx = this.getTx();
        return tx.moveCall({
            target: `${this.packageId}::${MODULE_AUTO_INVEST}::remove_plan_and_withdraw`,
            typeArguments: [coinType],
            arguments: [
                tx.object(this.investmentObjectId),
                tx.pure.u64(identifier.planId),
            ],
        });
    }
    pausePlan(identifier) {
        const tx = this.getTx();
        tx.moveCall({
            target: `${this.packageId}::${MODULE_AUTO_INVEST}::pause_plan`,
            typeArguments: [],
            arguments: [
                tx.object(this.investmentObjectId),
                tx.pure.u64(identifier.planId),
            ],
        });
    }
    unpausePlan(identifier) {
        const tx = this.getTx();
        tx.moveCall({
            target: `${this.packageId}::${MODULE_AUTO_INVEST}::unpause_plan`,
            typeArguments: [],
            arguments: [
                tx.object(this.investmentObjectId),
                tx.pure.u64(identifier.planId),
            ],
        });
    }
    planExists(planIds) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const tx = new Transaction();
            this.tx(tx);
            for (const planId of planIds) {
                tx.moveCall({
                    target: `${this.packageId}::${MODULE_AUTO_INVEST}::plan_exists`,
                    arguments: [tx.object(this.investmentObjectId), tx.pure.u64(planId)],
                });
            }
            const resp = yield this._client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ADDRESS_ZERO,
            });
            return ((_b = (_a = resp.results) === null || _a === void 0 ? void 0 : _a.map((result) => { var _a, _b, _c; return bcs.Bool.parse(new Uint8Array((_c = (_b = (_a = result.returnValues) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b[0]) !== null && _c !== void 0 ? _c : [])); })) !== null && _b !== void 0 ? _b : []);
        });
    }
    queryPlans(filters) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e;
            const tx = new Transaction();
            this.tx(tx);
            const cursorOpt = this.createU64Option(filters.cursor);
            const limitOpt = this.createU64Option((_a = filters.limit) === null || _a === void 0 ? void 0 : _a.toString());
            const descOpt = this.createBooleanOption(filters.desc);
            tx.moveCall({
                target: `${this.packageId}::${MODULE_PLAN_QUERY}::query_plans`,
                arguments: [
                    tx.object(this.investmentObjectId),
                    tx.pure.address(filters.owner),
                    cursorOpt,
                    limitOpt,
                    descOpt,
                ],
            });
            const results = (yield this._client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ADDRESS_ZERO,
            })).results;
            if (!results) {
                return {
                    plans: [],
                    cursor: null,
                    hasNextPage: false,
                    total: 0,
                };
            }
            const queryResult = QueryResultBCS.parse(new Uint8Array((_e = (_d = (_c = (_b = results === null || results === void 0 ? void 0 : results[results ? results.length - 1 : 0]) === null || _b === void 0 ? void 0 : _b.returnValues) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d[0]) !== null && _e !== void 0 ? _e : []));
            const BN = BigNumber.clone();
            BN.set({
                ROUNDING_MODE: BN.ROUND_FLOOR,
            });
            return {
                plans: queryResult.plans.map((plan) => new Plan({
                    planId: plan.plan_id,
                    subscriptionAmount: plan.subscription_amount,
                    subscriptionInterval: Number(plan.subscription_interval),
                    firstExecutionTime: Number(plan.next_execution_time) -
                        Number(plan.subscription_interval) * Number(plan.execution_count),
                    nextExecutionTime: Number(plan.next_execution_time),
                    executionCount: Number(plan.execution_count),
                    executionLimit: Number(plan.execution_limit),
                    averagePrice: new BN(plan.average_price)
                        .div(FLOAT_SCALING)
                        .toString(),
                    totalPurchasedAmount: plan.total_purchased_amount,
                    owner: plan.owner,
                    receiver: plan.receiver,
                    sourceAsset: normalizeStructTag$1(plan.source_asset.name),
                    targetAsset: normalizeStructTag$1(plan.target_asset.name),
                    creationTime: Number(plan.creation_time),
                    status: plan.paused ? PlanStatus.PAUSED : PlanStatus.ONGOING,
                })),
                cursor: queryResult.cursor,
                hasNextPage: queryResult.has_nex_page,
                total: Number(queryResult.total),
            };
        });
    }
    getAccountBalance(coinType, account) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            const tx = new Transaction();
            tx.moveCall({
                target: `${this.packageId}::${MODULE_AUTO_INVEST}::get_account_balance`,
                typeArguments: [coinType],
                arguments: [tx.object(this.investmentObjectId), tx.pure.address(account)],
            });
            const results = (yield this._client.devInspectTransactionBlock({
                transactionBlock: tx,
                sender: ADDRESS_ZERO,
            })).results;
            return results
                ? bcs.U64.parse(new Uint8Array((_d = (_c = (_b = (_a = results[0]) === null || _a === void 0 ? void 0 : _a.returnValues) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c[0]) !== null && _d !== void 0 ? _d : []))
                : '0';
        });
    }
}

const CONFIGS$2 = {
    mainnet: {
        packageId: '0x83a28e9da468eab67ac954aed1e801905b537418eeeb58ba69237699ea0558c9',
    },
    testnet: {
        packageId: '',
    },
};

class PricePredict extends TxBuilder {
    constructor(network) {
        super(network);
        this.modulePool = 'pool';
        const configs = CONFIGS$2[network];
        if (configs.packageId == undefined) {
            throw new MissingConfiguration('packageId', network);
        }
        this.packageId = configs.packageId;
    }
    bet(pool, predictedPrice, coin_in) {
        const tx = this.getTx();
        tx.moveCall({
            target: `${this.packageId}::${this.modulePool}::bet`,
            typeArguments: [pool.marketCoinType, pool.bettingCoinType],
            arguments: [
                tx.object(pool.id),
                tx.object(SUI_CLOCK_OBJECT_ID),
                tx.pure.u64(predictedPrice),
                typeof coin_in.object === 'string'
                    ? tx.object(coin_in.object)
                    : coin_in.object,
            ],
        });
        return tx;
    }
    claim(pool, betIndex) {
        const tx = this.getTx();
        tx.moveCall({
            target: `${this.packageId}::${this.modulePool}::claim`,
            typeArguments: [pool.marketCoinType, pool.bettingCoinType],
            arguments: [tx.object(pool.id), tx.pure.u64(betIndex)],
        });
        return tx;
    }
}

const version$1 = '1.0.8';

let BaseError$1 = class BaseError extends Error {
    constructor(shortMessage, args = {}) {
        const details = args.cause instanceof BaseError
            ? args.cause.details
            : args.cause?.message
                ? args.cause.message
                : args.details;
        const docsPath = args.cause instanceof BaseError
            ? args.cause.docsPath || args.docsPath
            : args.docsPath;
        const message = [
            shortMessage || 'An error occurred.',
            '',
            ...(args.metaMessages ? [...args.metaMessages, ''] : []),
            ...(docsPath ? [`Docs: https://abitype.dev${docsPath}`] : []),
            ...(details ? [`Details: ${details}`] : []),
            `Version: abitype@${version$1}`,
        ].join('\n');
        super(message);
        Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiTypeError'
        });
        if (args.cause)
            this.cause = args.cause;
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        this.shortMessage = shortMessage;
    }
};

// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.
// https://twitter.com/GabrielVergnaud/status/1622906834343366657
function execTyped(regex, string) {
    const match = regex.exec(string);
    return match?.groups;
}
// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`
// https://regexr.com/6va55
const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`
// https://regexr.com/6v8hp
const integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
const isTupleRegex = /^\(.+?\).*?$/;

// https://regexr.com/7gmok
const errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isErrorSignature(signature) {
    return errorSignatureRegex.test(signature);
}
function execErrorSignature(signature) {
    return execTyped(errorSignatureRegex, signature);
}
// https://regexr.com/7gmoq
const eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isEventSignature(signature) {
    return eventSignatureRegex.test(signature);
}
function execEventSignature(signature) {
    return execTyped(eventSignatureRegex, signature);
}
// https://regexr.com/7gmot
const functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
function isFunctionSignature(signature) {
    return functionSignatureRegex.test(signature);
}
function execFunctionSignature(signature) {
    return execTyped(functionSignatureRegex, signature);
}
// https://regexr.com/7gmp3
const structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
function isStructSignature(signature) {
    return structSignatureRegex.test(signature);
}
function execStructSignature(signature) {
    return execTyped(structSignatureRegex, signature);
}
// https://regexr.com/78u01
const constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
function isConstructorSignature(signature) {
    return constructorSignatureRegex.test(signature);
}
function execConstructorSignature(signature) {
    return execTyped(constructorSignatureRegex, signature);
}
// https://regexr.com/7srtn
const fallbackSignatureRegex = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
function isFallbackSignature(signature) {
    return fallbackSignatureRegex.test(signature);
}
function execFallbackSignature(signature) {
    return execTyped(fallbackSignatureRegex, signature);
}
// https://regexr.com/78u1k
const receiveSignatureRegex = /^receive\(\) external payable$/;
function isReceiveSignature(signature) {
    return receiveSignatureRegex.test(signature);
}
const eventModifiers = new Set(['indexed']);
const functionModifiers = new Set([
    'calldata',
    'memory',
    'storage',
]);

class UnknownTypeError extends BaseError$1 {
    constructor({ type }) {
        super('Unknown type.', {
            metaMessages: [
                `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`,
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'UnknownTypeError'
        });
    }
}
class UnknownSolidityTypeError extends BaseError$1 {
    constructor({ type }) {
        super('Unknown type.', {
            metaMessages: [`Type "${type}" is not a valid ABI type.`],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'UnknownSolidityTypeError'
        });
    }
}

class InvalidParameterError extends BaseError$1 {
    constructor({ param }) {
        super('Invalid ABI parameter.', {
            details: param,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidParameterError'
        });
    }
}
class SolidityProtectedKeywordError extends BaseError$1 {
    constructor({ param, name }) {
        super('Invalid ABI parameter.', {
            details: param,
            metaMessages: [
                `"${name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`,
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'SolidityProtectedKeywordError'
        });
    }
}
class InvalidModifierError extends BaseError$1 {
    constructor({ param, type, modifier, }) {
        super('Invalid ABI parameter.', {
            details: param,
            metaMessages: [
                `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ''}.`,
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidModifierError'
        });
    }
}
class InvalidFunctionModifierError extends BaseError$1 {
    constructor({ param, type, modifier, }) {
        super('Invalid ABI parameter.', {
            details: param,
            metaMessages: [
                `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ''}.`,
                `Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`,
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidFunctionModifierError'
        });
    }
}
class InvalidAbiTypeParameterError extends BaseError$1 {
    constructor({ abiParameter, }) {
        super('Invalid ABI parameter.', {
            details: JSON.stringify(abiParameter, null, 2),
            metaMessages: ['ABI parameter type is invalid.'],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidAbiTypeParameterError'
        });
    }
}

class InvalidSignatureError extends BaseError$1 {
    constructor({ signature, type, }) {
        super(`Invalid ${type} signature.`, {
            details: signature,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidSignatureError'
        });
    }
}
class UnknownSignatureError extends BaseError$1 {
    constructor({ signature }) {
        super('Unknown signature.', {
            details: signature,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'UnknownSignatureError'
        });
    }
}
class InvalidStructSignatureError extends BaseError$1 {
    constructor({ signature }) {
        super('Invalid struct signature.', {
            details: signature,
            metaMessages: ['No properties exist.'],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidStructSignatureError'
        });
    }
}

class CircularReferenceError extends BaseError$1 {
    constructor({ type }) {
        super('Circular reference detected.', {
            metaMessages: [`Struct "${type}" is a circular reference.`],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'CircularReferenceError'
        });
    }
}

class InvalidParenthesisError extends BaseError$1 {
    constructor({ current, depth }) {
        super('Unbalanced parentheses.', {
            metaMessages: [
                `"${current.trim()}" has too many ${depth > 0 ? 'opening' : 'closing'} parentheses.`,
            ],
            details: `Depth "${depth}"`,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidParenthesisError'
        });
    }
}

/**
 * Gets {@link parameterCache} cache key namespaced by {@link type}. This prevents parameters from being accessible to types that don't allow them (e.g. `string indexed foo` not allowed outside of `type: 'event'`).
 * @param param ABI parameter string
 * @param type ABI parameter type
 * @returns Cache key for {@link parameterCache}
 */
function getParameterCacheKey(param, type, structs) {
    let structKey = '';
    if (structs)
        for (const struct of Object.entries(structs)) {
            if (!struct)
                continue;
            let propertyKey = '';
            for (const property of struct[1]) {
                propertyKey += `[${property.type}${property.name ? `:${property.name}` : ''}]`;
            }
            structKey += `(${struct[0]}{${propertyKey}})`;
        }
    if (type)
        return `${type}:${param}${structKey}`;
    return param;
}
/**
 * Basic cache seeded with common ABI parameter strings.
 *
 * **Note: When seeding more parameters, make sure you benchmark performance. The current number is the ideal balance between performance and having an already existing cache.**
 */
const parameterCache = new Map([
    // Unnamed
    ['address', { type: 'address' }],
    ['bool', { type: 'bool' }],
    ['bytes', { type: 'bytes' }],
    ['bytes32', { type: 'bytes32' }],
    ['int', { type: 'int256' }],
    ['int256', { type: 'int256' }],
    ['string', { type: 'string' }],
    ['uint', { type: 'uint256' }],
    ['uint8', { type: 'uint8' }],
    ['uint16', { type: 'uint16' }],
    ['uint24', { type: 'uint24' }],
    ['uint32', { type: 'uint32' }],
    ['uint64', { type: 'uint64' }],
    ['uint96', { type: 'uint96' }],
    ['uint112', { type: 'uint112' }],
    ['uint160', { type: 'uint160' }],
    ['uint192', { type: 'uint192' }],
    ['uint256', { type: 'uint256' }],
    // Named
    ['address owner', { type: 'address', name: 'owner' }],
    ['address to', { type: 'address', name: 'to' }],
    ['bool approved', { type: 'bool', name: 'approved' }],
    ['bytes _data', { type: 'bytes', name: '_data' }],
    ['bytes data', { type: 'bytes', name: 'data' }],
    ['bytes signature', { type: 'bytes', name: 'signature' }],
    ['bytes32 hash', { type: 'bytes32', name: 'hash' }],
    ['bytes32 r', { type: 'bytes32', name: 'r' }],
    ['bytes32 root', { type: 'bytes32', name: 'root' }],
    ['bytes32 s', { type: 'bytes32', name: 's' }],
    ['string name', { type: 'string', name: 'name' }],
    ['string symbol', { type: 'string', name: 'symbol' }],
    ['string tokenURI', { type: 'string', name: 'tokenURI' }],
    ['uint tokenId', { type: 'uint256', name: 'tokenId' }],
    ['uint8 v', { type: 'uint8', name: 'v' }],
    ['uint256 balance', { type: 'uint256', name: 'balance' }],
    ['uint256 tokenId', { type: 'uint256', name: 'tokenId' }],
    ['uint256 value', { type: 'uint256', name: 'value' }],
    // Indexed
    [
        'event:address indexed from',
        { type: 'address', name: 'from', indexed: true },
    ],
    ['event:address indexed to', { type: 'address', name: 'to', indexed: true }],
    [
        'event:uint indexed tokenId',
        { type: 'uint256', name: 'tokenId', indexed: true },
    ],
    [
        'event:uint256 indexed tokenId',
        { type: 'uint256', name: 'tokenId', indexed: true },
    ],
]);

function parseSignature$1(signature, structs = {}) {
    if (isFunctionSignature(signature))
        return parseFunctionSignature(signature, structs);
    if (isEventSignature(signature))
        return parseEventSignature(signature, structs);
    if (isErrorSignature(signature))
        return parseErrorSignature(signature, structs);
    if (isConstructorSignature(signature))
        return parseConstructorSignature(signature, structs);
    if (isFallbackSignature(signature))
        return parseFallbackSignature(signature);
    if (isReceiveSignature(signature))
        return {
            type: 'receive',
            stateMutability: 'payable',
        };
    throw new UnknownSignatureError({ signature });
}
function parseFunctionSignature(signature, structs = {}) {
    const match = execFunctionSignature(signature);
    if (!match)
        throw new InvalidSignatureError({ signature, type: 'function' });
    const inputParams = splitParameters(match.parameters);
    const inputs = [];
    const inputLength = inputParams.length;
    for (let i = 0; i < inputLength; i++) {
        inputs.push(parseAbiParameter(inputParams[i], {
            modifiers: functionModifiers,
            structs,
            type: 'function',
        }));
    }
    const outputs = [];
    if (match.returns) {
        const outputParams = splitParameters(match.returns);
        const outputLength = outputParams.length;
        for (let i = 0; i < outputLength; i++) {
            outputs.push(parseAbiParameter(outputParams[i], {
                modifiers: functionModifiers,
                structs,
                type: 'function',
            }));
        }
    }
    return {
        name: match.name,
        type: 'function',
        stateMutability: match.stateMutability ?? 'nonpayable',
        inputs,
        outputs,
    };
}
function parseEventSignature(signature, structs = {}) {
    const match = execEventSignature(signature);
    if (!match)
        throw new InvalidSignatureError({ signature, type: 'event' });
    const params = splitParameters(match.parameters);
    const abiParameters = [];
    const length = params.length;
    for (let i = 0; i < length; i++)
        abiParameters.push(parseAbiParameter(params[i], {
            modifiers: eventModifiers,
            structs,
            type: 'event',
        }));
    return { name: match.name, type: 'event', inputs: abiParameters };
}
function parseErrorSignature(signature, structs = {}) {
    const match = execErrorSignature(signature);
    if (!match)
        throw new InvalidSignatureError({ signature, type: 'error' });
    const params = splitParameters(match.parameters);
    const abiParameters = [];
    const length = params.length;
    for (let i = 0; i < length; i++)
        abiParameters.push(parseAbiParameter(params[i], { structs, type: 'error' }));
    return { name: match.name, type: 'error', inputs: abiParameters };
}
function parseConstructorSignature(signature, structs = {}) {
    const match = execConstructorSignature(signature);
    if (!match)
        throw new InvalidSignatureError({ signature, type: 'constructor' });
    const params = splitParameters(match.parameters);
    const abiParameters = [];
    const length = params.length;
    for (let i = 0; i < length; i++)
        abiParameters.push(parseAbiParameter(params[i], { structs, type: 'constructor' }));
    return {
        type: 'constructor',
        stateMutability: match.stateMutability ?? 'nonpayable',
        inputs: abiParameters,
    };
}
function parseFallbackSignature(signature) {
    const match = execFallbackSignature(signature);
    if (!match)
        throw new InvalidSignatureError({ signature, type: 'fallback' });
    return {
        type: 'fallback',
        stateMutability: match.stateMutability ?? 'nonpayable',
    };
}
const abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
const abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
const dynamicIntegerRegex = /^u?int$/;
function parseAbiParameter(param, options) {
    // optional namespace cache by `type`
    const parameterCacheKey = getParameterCacheKey(param, options?.type, options?.structs);
    if (parameterCache.has(parameterCacheKey))
        return parameterCache.get(parameterCacheKey);
    const isTuple = isTupleRegex.test(param);
    const match = execTyped(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
    if (!match)
        throw new InvalidParameterError({ param });
    if (match.name && isSolidityKeyword(match.name))
        throw new SolidityProtectedKeywordError({ param, name: match.name });
    const name = match.name ? { name: match.name } : {};
    const indexed = match.modifier === 'indexed' ? { indexed: true } : {};
    const structs = options?.structs ?? {};
    let type;
    let components = {};
    if (isTuple) {
        type = 'tuple';
        const params = splitParameters(match.type);
        const components_ = [];
        const length = params.length;
        for (let i = 0; i < length; i++) {
            // remove `modifiers` from `options` to prevent from being added to tuple components
            components_.push(parseAbiParameter(params[i], { structs }));
        }
        components = { components: components_ };
    }
    else if (match.type in structs) {
        type = 'tuple';
        components = { components: structs[match.type] };
    }
    else if (dynamicIntegerRegex.test(match.type)) {
        type = `${match.type}256`;
    }
    else {
        type = match.type;
        if (!(options?.type === 'struct') && !isSolidityType(type))
            throw new UnknownSolidityTypeError({ type });
    }
    if (match.modifier) {
        // Check if modifier exists, but is not allowed (e.g. `indexed` in `functionModifiers`)
        if (!options?.modifiers?.has?.(match.modifier))
            throw new InvalidModifierError({
                param,
                type: options?.type,
                modifier: match.modifier,
            });
        // Check if resolved `type` is valid if there is a function modifier
        if (functionModifiers.has(match.modifier) &&
            !isValidDataLocation(type, !!match.array))
            throw new InvalidFunctionModifierError({
                param,
                type: options?.type,
                modifier: match.modifier,
            });
    }
    const abiParameter = {
        type: `${type}${match.array ?? ''}`,
        ...name,
        ...indexed,
        ...components,
    };
    parameterCache.set(parameterCacheKey, abiParameter);
    return abiParameter;
}
// s/o latika for this
function splitParameters(params, result = [], current = '', depth = 0) {
    const length = params.trim().length;
    // biome-ignore lint/correctness/noUnreachable: recursive
    for (let i = 0; i < length; i++) {
        const char = params[i];
        const tail = params.slice(i + 1);
        switch (char) {
            case ',':
                return depth === 0
                    ? splitParameters(tail, [...result, current.trim()])
                    : splitParameters(tail, result, `${current}${char}`, depth);
            case '(':
                return splitParameters(tail, result, `${current}${char}`, depth + 1);
            case ')':
                return splitParameters(tail, result, `${current}${char}`, depth - 1);
            default:
                return splitParameters(tail, result, `${current}${char}`, depth);
        }
    }
    if (current === '')
        return result;
    if (depth !== 0)
        throw new InvalidParenthesisError({ current, depth });
    result.push(current.trim());
    return result;
}
function isSolidityType(type) {
    return (type === 'address' ||
        type === 'bool' ||
        type === 'function' ||
        type === 'string' ||
        bytesRegex.test(type) ||
        integerRegex.test(type));
}
const protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
/** @internal */
function isSolidityKeyword(name) {
    return (name === 'address' ||
        name === 'bool' ||
        name === 'function' ||
        name === 'string' ||
        name === 'tuple' ||
        bytesRegex.test(name) ||
        integerRegex.test(name) ||
        protectedKeywordsRegex.test(name));
}
/** @internal */
function isValidDataLocation(type, isArray) {
    return isArray || type === 'bytes' || type === 'string' || type === 'tuple';
}

function parseStructs(signatures) {
    // Create "shallow" version of each struct (and filter out non-structs or invalid structs)
    const shallowStructs = {};
    const signaturesLength = signatures.length;
    for (let i = 0; i < signaturesLength; i++) {
        const signature = signatures[i];
        if (!isStructSignature(signature))
            continue;
        const match = execStructSignature(signature);
        if (!match)
            throw new InvalidSignatureError({ signature, type: 'struct' });
        const properties = match.properties.split(';');
        const components = [];
        const propertiesLength = properties.length;
        for (let k = 0; k < propertiesLength; k++) {
            const property = properties[k];
            const trimmed = property.trim();
            if (!trimmed)
                continue;
            const abiParameter = parseAbiParameter(trimmed, {
                type: 'struct',
            });
            components.push(abiParameter);
        }
        if (!components.length)
            throw new InvalidStructSignatureError({ signature });
        shallowStructs[match.name] = components;
    }
    // Resolve nested structs inside each parameter
    const resolvedStructs = {};
    const entries = Object.entries(shallowStructs);
    const entriesLength = entries.length;
    for (let i = 0; i < entriesLength; i++) {
        const [name, parameters] = entries[i];
        resolvedStructs[name] = resolveStructs(parameters, shallowStructs);
    }
    return resolvedStructs;
}
const typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
function resolveStructs(abiParameters, structs, ancestors = new Set()) {
    const components = [];
    const length = abiParameters.length;
    for (let i = 0; i < length; i++) {
        const abiParameter = abiParameters[i];
        const isTuple = isTupleRegex.test(abiParameter.type);
        if (isTuple)
            components.push(abiParameter);
        else {
            const match = execTyped(typeWithoutTupleRegex, abiParameter.type);
            if (!match?.type)
                throw new InvalidAbiTypeParameterError({ abiParameter });
            const { array, type } = match;
            if (type in structs) {
                if (ancestors.has(type))
                    throw new CircularReferenceError({ type });
                components.push({
                    ...abiParameter,
                    type: `tuple${array ?? ''}`,
                    components: resolveStructs(structs[type] ?? [], structs, new Set([...ancestors, type])),
                });
            }
            else {
                if (isSolidityType(type))
                    components.push(abiParameter);
                else
                    throw new UnknownTypeError({ type });
            }
        }
    }
    return components;
}

/**
 * Parses human-readable ABI into JSON {@link Abi}
 *
 * @param signatures - Human-Readable ABI
 * @returns Parsed {@link Abi}
 *
 * @example
 * const abi = parseAbi([
 *   //  ^? const abi: readonly [{ name: "balanceOf"; type: "function"; stateMutability:...
 *   'function balanceOf(address owner) view returns (uint256)',
 *   'event Transfer(address indexed from, address indexed to, uint256 amount)',
 * ])
 */
function parseAbi(signatures) {
    const structs = parseStructs(signatures);
    const abi = [];
    const length = signatures.length;
    for (let i = 0; i < length; i++) {
        const signature = signatures[i];
        if (isStructSignature(signature))
            continue;
        abi.push(parseSignature$1(signature, structs));
    }
    return abi;
}

const version = '2.36.0';

let errorConfig = {
    getDocsUrl: ({ docsBaseUrl, docsPath = '', docsSlug, }) => docsPath
        ? `${docsBaseUrl ?? 'https://viem.sh'}${docsPath}${docsSlug ? `#${docsSlug}` : ''}`
        : undefined,
    version: `viem@${version}`,
};
class BaseError extends Error {
    constructor(shortMessage, args = {}) {
        const details = (() => {
            if (args.cause instanceof BaseError)
                return args.cause.details;
            if (args.cause?.message)
                return args.cause.message;
            return args.details;
        })();
        const docsPath = (() => {
            if (args.cause instanceof BaseError)
                return args.cause.docsPath || args.docsPath;
            return args.docsPath;
        })();
        const docsUrl = errorConfig.getDocsUrl?.({ ...args, docsPath });
        const message = [
            shortMessage || 'An error occurred.',
            '',
            ...(args.metaMessages ? [...args.metaMessages, ''] : []),
            ...(docsUrl ? [`Docs: ${docsUrl}`] : []),
            ...(details ? [`Details: ${details}`] : []),
            ...(errorConfig.version ? [`Version: ${errorConfig.version}`] : []),
        ].join('\n');
        super(message, args.cause ? { cause: args.cause } : undefined);
        Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'BaseError'
        });
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        this.name = args.name ?? this.name;
        this.shortMessage = shortMessage;
        this.version = version;
    }
    walk(fn) {
        return walk(this, fn);
    }
}
function walk(err, fn) {
    if (fn?.(err))
        return err;
    if (err &&
        typeof err === 'object' &&
        'cause' in err &&
        err.cause !== undefined)
        return walk(err.cause, fn);
    return fn ? null : err;
}

class SizeExceedsPaddingSizeError extends BaseError {
    constructor({ size, targetSize, type, }) {
        super(`${type.charAt(0).toUpperCase()}${type
            .slice(1)
            .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`, { name: 'SizeExceedsPaddingSizeError' });
    }
}

function pad(hexOrBytes, { dir, size = 32 } = {}) {
    if (typeof hexOrBytes === 'string')
        return padHex(hexOrBytes, { dir, size });
    return padBytes(hexOrBytes, { dir, size });
}
function padHex(hex_, { dir, size = 32 } = {}) {
    if (size === null)
        return hex_;
    const hex = hex_.replace('0x', '');
    if (hex.length > size * 2)
        throw new SizeExceedsPaddingSizeError({
            size: Math.ceil(hex.length / 2),
            targetSize: size,
            type: 'hex',
        });
    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;
}
function padBytes(bytes, { dir, size = 32 } = {}) {
    if (size === null)
        return bytes;
    if (bytes.length > size)
        throw new SizeExceedsPaddingSizeError({
            size: bytes.length,
            targetSize: size,
            type: 'bytes',
        });
    const paddedBytes = new Uint8Array(size);
    for (let i = 0; i < size; i++) {
        const padEnd = dir === 'right';
        paddedBytes[padEnd ? i : size - i - 1] =
            bytes[padEnd ? i : bytes.length - i - 1];
    }
    return paddedBytes;
}

class IntegerOutOfRangeError extends BaseError {
    constructor({ max, min, signed, size, value, }) {
        super(`Number "${value}" is not in safe ${size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`, { name: 'IntegerOutOfRangeError' });
    }
}

/**
 * Encodes a number or bigint into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex#numbertohex
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { numberToHex } from 'viem'
 * const data = numberToHex(420)
 * // '0x1a4'
 *
 * @example
 * import { numberToHex } from 'viem'
 * const data = numberToHex(420, { size: 32 })
 * // '0x00000000000000000000000000000000000000000000000000000000000001a4'
 */
function numberToHex(value_, opts = {}) {
    const { signed, size } = opts;
    const value = BigInt(value_);
    let maxValue;
    if (size) {
        if (signed)
            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;
        else
            maxValue = 2n ** (BigInt(size) * 8n) - 1n;
    }
    else if (typeof value_ === 'number') {
        maxValue = BigInt(Number.MAX_SAFE_INTEGER);
    }
    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;
    if ((maxValue && value > maxValue) || value < minValue) {
        const suffix = typeof value_ === 'bigint' ? 'n' : '';
        throw new IntegerOutOfRangeError({
            max: maxValue ? `${maxValue}${suffix}` : undefined,
            min: `${minValue}${suffix}`,
            signed,
            size,
            value: `${value_}${suffix}`,
        });
    }
    const hex = `0x${(signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value).toString(16)}`;
    if (size)
        return pad(hex, { size });
    return hex;
}

const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;

/**
 * Utilities for hex, bytes, CSPRNG.
 * @module
 */
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */
function isBytes(a) {
    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
}
/** Asserts something is positive integer. */
function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error('positive integer expected, got ' + n);
}
/** Asserts something is Uint8Array. */
function abytes(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
/** Asserts something is hash */
function ahash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function')
        throw new Error('Hash should be wrapped by utils.createHasher');
    anumber(h.outputLen);
    anumber(h.blockLen);
}
/** Asserts a hash instance has not been destroyed / finished */
function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
/** Asserts output is properly-sized byte array */
function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error('digestInto() expects output buffer of length at least ' + min);
    }
}
/** Zeroize a byte array. Warning: JS provides no guarantees. */
function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
    }
}
/** Create DataView of an array for easy byte-level manipulation. */
function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** The rotate right (circular right shift) operation for uint32 */
function rotr(word, shift) {
    return (word << (32 - shift)) | (word >>> shift);
}
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
const hasHexBuiltin = /* @__PURE__ */ (() => 
// @ts-ignore
typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * Convert byte array to hex string. Uses built-in function, when available.
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    abytes(bytes);
    // @ts-ignore
    if (hasHexBuiltin)
        return bytes.toHex();
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0; // '2' => 50-48
    if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10); // 'B' => 66-(65-10)
    if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10); // 'b' => 98-(97-10)
    return;
}
/**
 * Convert hex string to byte array. Uses built-in function, when available.
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    // @ts-ignore
    if (hasHexBuiltin)
        return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
        throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
    }
    return array;
}
/**
 * Converts string to bytes using UTF8 encoding.
 * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error('string expected');
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/** Copies several Uint8Arrays into one. */
function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
/** For runtime check if class implements interface */
class Hash {
}
/** Wraps hash function, creating an interface on top of it */
function createHasher(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}
/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */
function randomBytes(bytesLength = 32) {
    if (crypto && typeof crypto.getRandomValues === 'function') {
        return crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    // Legacy Node.js compatibility
    if (crypto && typeof crypto.randomBytes === 'function') {
        return Uint8Array.from(crypto.randomBytes(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
}

const maxUint64 = 2n ** 64n - 1n;

/**
 * Internal Merkle-Damgard hash utils.
 * @module
 */
/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
/** Choice: a ? b : c */
function Chi(a, b, c) {
    return (a & b) ^ (~a & c);
}
/** Majority function, true if any two inputs is true. */
function Maj(a, b, c) {
    return (a & b) ^ (a & c) ^ (b & c);
}
/**
 * Merkle-Damgard hash construction base class.
 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
 */
class HashMD extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = createView(this.buffer);
    }
    update(data) {
        aexists(this);
        data = toBytes(data);
        abytes(data);
        const { view, buffer, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = createView(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        aexists(this);
        aoutput(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        clean(this.buffer.subarray(pos));
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = createView(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
}
/**
 * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.
 * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.
 */
/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */
const SHA256_IV = /* @__PURE__ */ Uint32Array.from([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
]);

/**
 * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.
 * SHA256 is the fastest hash implementable in JS, even faster than Blake3.
 * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and
 * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
 * @module
 */
/**
 * Round constants:
 * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)
 */
// prettier-ignore
const SHA256_K = /* @__PURE__ */ Uint32Array.from([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
/** Reusable temporary buffer. "W" comes straight from spec. */
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends HashMD {
    constructor(outputLen = 32) {
        super(64, outputLen, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);
            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
            const T2 = (sigma0 + Maj(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        clean(SHA256_W);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        clean(this.buffer);
    }
}
/**
 * SHA2-256 hash function from RFC 4634.
 *
 * It is the fastest JS hash, even faster than Blake3.
 * To break sha256 using birthday attack, attackers need to try 2^128 hashes.
 * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.
 */
const sha256 = /* @__PURE__ */ createHasher(() => new SHA256());

/* [Multicall3](https://github.com/mds1/multicall) */
/** [ERC-20 Token Standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20) */
const erc20Abi = [
    {
        type: 'event',
        name: 'Approval',
        inputs: [
            {
                indexed: true,
                name: 'owner',
                type: 'address',
            },
            {
                indexed: true,
                name: 'spender',
                type: 'address',
            },
            {
                indexed: false,
                name: 'value',
                type: 'uint256',
            },
        ],
    },
    {
        type: 'event',
        name: 'Transfer',
        inputs: [
            {
                indexed: true,
                name: 'from',
                type: 'address',
            },
            {
                indexed: true,
                name: 'to',
                type: 'address',
            },
            {
                indexed: false,
                name: 'value',
                type: 'uint256',
            },
        ],
    },
    {
        type: 'function',
        name: 'allowance',
        stateMutability: 'view',
        inputs: [
            {
                name: 'owner',
                type: 'address',
            },
            {
                name: 'spender',
                type: 'address',
            },
        ],
        outputs: [
            {
                type: 'uint256',
            },
        ],
    },
    {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
            {
                name: 'spender',
                type: 'address',
            },
            {
                name: 'amount',
                type: 'uint256',
            },
        ],
        outputs: [
            {
                type: 'bool',
            },
        ],
    },
    {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [
            {
                name: 'account',
                type: 'address',
            },
        ],
        outputs: [
            {
                type: 'uint256',
            },
        ],
    },
    {
        type: 'function',
        name: 'decimals',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'uint8',
            },
        ],
    },
    {
        type: 'function',
        name: 'name',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'string',
            },
        ],
    },
    {
        type: 'function',
        name: 'symbol',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'string',
            },
        ],
    },
    {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'uint256',
            },
        ],
    },
    {
        type: 'function',
        name: 'transfer',
        stateMutability: 'nonpayable',
        inputs: [
            {
                name: 'recipient',
                type: 'address',
            },
            {
                name: 'amount',
                type: 'uint256',
            },
        ],
        outputs: [
            {
                type: 'bool',
            },
        ],
    },
    {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
            {
                name: 'sender',
                type: 'address',
            },
            {
                name: 'recipient',
                type: 'address',
            },
            {
                name: 'amount',
                type: 'uint256',
            },
        ],
        outputs: [
            {
                type: 'bool',
            },
        ],
    },
];

/**
 * HMAC: RFC2104 message authentication code.
 * @module
 */
class HMAC extends Hash {
    constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        ahash(hash);
        const key = toBytes(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function')
            throw new Error('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        clean(pad);
    }
    update(buf) {
        aexists(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        aexists(this);
        abytes(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 * @example
 * import { hmac } from '@noble/hashes/hmac';
 * import { sha256 } from '@noble/hashes/sha2';
 * const mac1 = hmac(sha256, 'key', 'message');
 */
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
hmac.create = (hash, key) => new HMAC(hash, key);

/**
 * Hex, bytes and number utilities.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = /* @__PURE__ */ BigInt(0);
const _1n$3 = /* @__PURE__ */ BigInt(1);
// tmp name until v2
function _abool2(value, title = '') {
    if (typeof value !== 'boolean') {
        const prefix = title && `"${title}"`;
        throw new Error(prefix + 'expected boolean, got type=' + typeof value);
    }
    return value;
}
// tmp name until v2
/** Asserts something is Uint8Array. */
function _abytes2(value, length, title = '') {
    const bytes = isBytes(value);
    const len = value?.length;
    const needsLen = length !== undefined;
    if (!bytes || (needsLen && len !== length)) {
        const prefix = title && `"${title}" `;
        const ofLen = needsLen ? ` of length ${length}` : '';
        const got = bytes ? `length=${len}` : `type=${typeof value}`;
        throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);
    }
    return value;
}
// Used in weierstrass, der
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? '0' + hex : hex;
}
function hexToNumber(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    return hex === '' ? _0n$3 : BigInt('0x' + hex); // Big Endian
}
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
function bytesToNumberLE(bytes) {
    abytes(bytes);
    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, '0'));
}
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'secret key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */
function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === 'string') {
        try {
            res = hexToBytes(hex);
        }
        catch (e) {
            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);
        }
    }
    else if (isBytes(hex)) {
        // Uint8Array.from() instead of hash.slice() because node.js Buffer
        // is instance of Uint8Array, and its slice() creates **mutable** copy
        res = Uint8Array.from(hex);
    }
    else {
        throw new Error(title + ' must be hex string or Uint8Array');
    }
    res.length;
    return res;
}
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;
/**
 * Converts bytes to string using UTF8 encoding.
 * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'
 */
// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;
// Is positive bigint
const isPosBig = (n) => typeof n === 'bigint' && _0n$3 <= n;
function inRange(n, min, max) {
    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
/**
 * Asserts min <= n < max. NOTE: It's < max and not <= max.
 * @example
 * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)
 */
function aInRange(title, n, min, max) {
    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?
    // consider P=256n, min=0n, max=P
    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`
    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`
    // - our way is the cleanest:               `inRange('x', x, 0n, P)
    if (!inRange(n, min, max))
        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);
}
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 * TODO: merge with nLength in modular
 */
function bitLen(n) {
    let len;
    for (len = 0; n > _0n$3; n >>= _1n$3, len += 1)
        ;
    return len;
}
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */
const bitMask = (n) => (_1n$3 << BigInt(n)) - _1n$3;
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== 'number' || hashLen < 2)
        throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2)
        throw new Error('qByteLen must be a number');
    if (typeof hmacFn !== 'function')
        throw new Error('hmacFn must be a function');
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    const u8n = (len) => new Uint8Array(len); // creates Uint8Array
    const u8of = (byte) => Uint8Array.of(byte); // another shortcut
    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    let i = 0; // Iterations counter, will throw when over 1000
    const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)
    const reseed = (seed = u8n(0)) => {
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0)
            return;
        k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    const gen = () => {
        // HMAC-DRBG generate() function
        if (i++ >= 1000)
            throw new Error('drbg: tried 1000 values');
        let len = 0;
        const out = [];
        while (len < qByteLen) {
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return concatBytes(...out);
    };
    const genUntil = (seed, pred) => {
        reset();
        reseed(seed); // Steps D-G
        let res = undefined; // Step H: grind until k is in [1..n-1]
        while (!(res = pred(gen())))
            reseed();
        reset();
        return res;
    };
    return genUntil;
}
function _validateObject(object, fields, optFields = {}) {
    if (!object || typeof object !== 'object')
        throw new Error('expected valid options object');
    function checkField(fieldName, expectedType, isOpt) {
        const val = object[fieldName];
        if (isOpt && val === undefined)
            return;
        const current = typeof val;
        if (current !== expectedType || val === null)
            throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
    }
    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
}
/**
 * Memoizes (caches) computation result.
 * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.
 */
function memoized(fn) {
    const map = new WeakMap();
    return (arg, ...args) => {
        const val = map.get(arg);
        if (val !== undefined)
            return val;
        const computed = fn(arg, ...args);
        map.set(arg, computed);
        return computed;
    };
}

/**
 * Utils for modular division and fields.
 * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.
 * There is no division: it is replaced by modular multiplicative inverse.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// prettier-ignore
const _0n$2 = BigInt(0), _1n$2 = BigInt(1), _2n$2 = /* @__PURE__ */ BigInt(2), _3n$1 = /* @__PURE__ */ BigInt(3);
// prettier-ignore
const _4n$1 = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _7n = /* @__PURE__ */ BigInt(7);
// prettier-ignore
const _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);
// Calculates a modulo b
function mod(a, b) {
    const result = a % b;
    return result >= _0n$2 ? result : b + result;
}
/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */
function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n$2) {
        res *= res;
        res %= modulo;
    }
    return res;
}
/**
 * Inverses number over modulo.
 * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).
 */
function invert(number, modulo) {
    if (number === _0n$2)
        throw new Error('invert: expected non-zero number');
    if (modulo <= _0n$2)
        throw new Error('invert: expected positive modulus, got ' + modulo);
    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
    let a = mod(number, modulo);
    let b = modulo;
    // prettier-ignore
    let x = _0n$2, u = _1n$2;
    while (a !== _0n$2) {
        // JIT applies optimization if those two lines follow each other
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        // prettier-ignore
        b = a, a = r, x = u, u = m;
    }
    const gcd = b;
    if (gcd !== _1n$2)
        throw new Error('invert: does not exist');
    return mod(x, modulo);
}
function assertIsSquare(Fp, root, n) {
    if (!Fp.eql(Fp.sqr(root), n))
        throw new Error('Cannot find square root');
}
// Not all roots are possible! Example which will throw:
// const NUM =
// n = 72057594037927816n;
// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));
function sqrt3mod4(Fp, n) {
    const p1div4 = (Fp.ORDER + _1n$2) / _4n$1;
    const root = Fp.pow(n, p1div4);
    assertIsSquare(Fp, root, n);
    return root;
}
function sqrt5mod8(Fp, n) {
    const p5div8 = (Fp.ORDER - _5n) / _8n;
    const n2 = Fp.mul(n, _2n$2);
    const v = Fp.pow(n2, p5div8);
    const nv = Fp.mul(n, v);
    const i = Fp.mul(Fp.mul(nv, _2n$2), v);
    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
    assertIsSquare(Fp, root, n);
    return root;
}
// Based on RFC9380, Kong algorithm
// prettier-ignore
function sqrt9mod16(P) {
    const Fp_ = Field(P);
    const tn = tonelliShanks(P);
    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F
    const c2 = tn(Fp_, c1); //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F
    const c3 = tn(Fp_, Fp_.neg(c1)); //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F
    const c4 = (P + _7n) / _16n; //  4. c4 = (q + 7) / 16        # Integer arithmetic
    return (Fp, n) => {
        let tv1 = Fp.pow(n, c4); //  1. tv1 = x^c4
        let tv2 = Fp.mul(tv1, c1); //  2. tv2 = c1 * tv1
        const tv3 = Fp.mul(tv1, c2); //  3. tv3 = c2 * tv1
        const tv4 = Fp.mul(tv1, c3); //  4. tv4 = c3 * tv1
        const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x
        const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x
        tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x
        tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x
        const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x
        const root = Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2
        assertIsSquare(Fp, root, n);
        return root;
    };
}
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */
function tonelliShanks(P) {
    // Initialization (precomputation).
    // Caching initialization could boost perf by 7%.
    if (P < _3n$1)
        throw new Error('sqrt is not defined for small field');
    // Factor P - 1 = Q * 2^S, where Q is odd
    let Q = P - _1n$2;
    let S = 0;
    while (Q % _2n$2 === _0n$2) {
        Q /= _2n$2;
        S++;
    }
    // Find the first quadratic non-residue Z >= 2
    let Z = _2n$2;
    const _Fp = Field(P);
    while (FpLegendre(_Fp, Z) === 1) {
        // Basic primality test for P. After x iterations, chance of
        // not finding quadratic non-residue is 2^x, so 2^1000.
        if (Z++ > 1000)
            throw new Error('Cannot find square root: probably non-prime P');
    }
    // Fast-path; usually done before Z, but we do "primality test".
    if (S === 1)
        return sqrt3mod4;
    // Slow-path
    // TODO: test on Fp2 and others
    let cc = _Fp.pow(Z, Q); // c = z^Q
    const Q1div2 = (Q + _1n$2) / _2n$2;
    return function tonelliSlow(Fp, n) {
        if (Fp.is0(n))
            return n;
        // Check if n is a quadratic residue using Legendre symbol
        if (FpLegendre(Fp, n) !== 1)
            throw new Error('Cannot find square root');
        // Initialize variables for the main loop
        let M = S;
        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp
        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor
        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root
        // Main loop
        // while t != 1
        while (!Fp.eql(t, Fp.ONE)) {
            if (Fp.is0(t))
                return Fp.ZERO; // if t=0 return R=0
            let i = 1;
            // Find the smallest i >= 1 such that t^(2^i)  1 (mod P)
            let t_tmp = Fp.sqr(t); // t^(2^1)
            while (!Fp.eql(t_tmp, Fp.ONE)) {
                i++;
                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...
                if (i === M)
                    throw new Error('Cannot find square root');
            }
            // Calculate the exponent for b: 2^(M - i - 1)
            const exponent = _1n$2 << BigInt(M - i - 1); // bigint is important
            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)
            // Update variables
            M = i;
            c = Fp.sqr(b); // c = b^2
            t = Fp.mul(t, c); // t = (t * b^2)
            R = Fp.mul(R, b); // R = R*b
        }
        return R;
    };
}
/**
 * Square root for a finite field. Will try optimized versions first:
 *
 * 1. P  3 (mod 4)
 * 2. P  5 (mod 8)
 * 3. P  9 (mod 16)
 * 4. Tonelli-Shanks algorithm
 *
 * Different algorithms can give different roots, it is up to user to decide which one they want.
 * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
 */
function FpSqrt(P) {
    // P  3 (mod 4) => n = n^((P+1)/4)
    if (P % _4n$1 === _3n$1)
        return sqrt3mod4;
    // P  5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf
    if (P % _8n === _5n)
        return sqrt5mod8;
    // P  9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)
    if (P % _16n === _9n)
        return sqrt9mod16(P);
    // Tonelli-Shanks algorithm
    return tonelliShanks(P);
}
// prettier-ignore
const FIELD_FIELDS = [
    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',
    'eql', 'add', 'sub', 'mul', 'pow', 'div',
    'addN', 'subN', 'mulN', 'sqrN'
];
function validateField(field) {
    const initial = {
        ORDER: 'bigint',
        MASK: 'bigint',
        BYTES: 'number',
        BITS: 'number',
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = 'function';
        return map;
    }, initial);
    _validateObject(field, opts);
    // const max = 16384;
    // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');
    // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');
    return field;
}
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */
function FpPow(Fp, num, power) {
    if (power < _0n$2)
        throw new Error('invalid exponent, negatives unsupported');
    if (power === _0n$2)
        return Fp.ONE;
    if (power === _1n$2)
        return num;
    let p = Fp.ONE;
    let d = num;
    while (power > _0n$2) {
        if (power & _1n$2)
            p = Fp.mul(p, d);
        d = Fp.sqr(d);
        power >>= _1n$2;
    }
    return p;
}
/**
 * Efficiently invert an array of Field elements.
 * Exception-free. Will return `undefined` for 0 elements.
 * @param passZero map 0 to 0 (instead of undefined)
 */
function FpInvertBatch(Fp, nums, passZero = false) {
    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);
    // Walk from first to last, multiply them by each other MOD p
    const multipliedAcc = nums.reduce((acc, num, i) => {
        if (Fp.is0(num))
            return acc;
        inverted[i] = acc;
        return Fp.mul(acc, num);
    }, Fp.ONE);
    // Invert last element
    const invertedAcc = Fp.inv(multipliedAcc);
    // Walk from last to first, multiply them by inverted each other MOD p
    nums.reduceRight((acc, num, i) => {
        if (Fp.is0(num))
            return acc;
        inverted[i] = Fp.mul(acc, inverted[i]);
        return Fp.mul(acc, num);
    }, invertedAcc);
    return inverted;
}
/**
 * Legendre symbol.
 * Legendre constant is used to calculate Legendre symbol (a | p)
 * which denotes the value of a^((p-1)/2) (mod p).
 *
 * * (a | p)  1    if a is a square (mod p), quadratic residue
 * * (a | p)  -1   if a is not a square (mod p), quadratic non residue
 * * (a | p)  0    if a  0 (mod p)
 */
function FpLegendre(Fp, n) {
    // We can use 3rd argument as optional cache of this value
    // but seems unneeded for now. The operation is very fast.
    const p1mod2 = (Fp.ORDER - _1n$2) / _2n$2;
    const powered = Fp.pow(n, p1mod2);
    const yes = Fp.eql(powered, Fp.ONE);
    const zero = Fp.eql(powered, Fp.ZERO);
    const no = Fp.eql(powered, Fp.neg(Fp.ONE));
    if (!yes && !zero && !no)
        throw new Error('invalid Legendre symbol result');
    return yes ? 1 : zero ? 0 : -1;
}
// CURVE.n lengths
function nLength(n, nBitLength) {
    // Bit size, byte size of CURVE.n
    if (nBitLength !== undefined)
        anumber(nBitLength);
    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
}
/**
 * Creates a finite field. Major performance optimizations:
 * * 1. Denormalized operations like mulN instead of mul.
 * * 2. Identical object shape: never add or remove keys.
 * * 3. `Object.freeze`.
 * Fragile: always run a benchmark on a change.
 * Security note: operations don't check 'isValid' for all elements for performance reasons,
 * it is caller responsibility to check this.
 * This is low-level code, please make sure you know what you're doing.
 *
 * Note about field properties:
 * * CHARACTERISTIC p = prime number, number of elements in main subgroup.
 * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.
 *
 * @param ORDER field order, probably prime, or could be composite
 * @param bitLen how many bits the field consumes
 * @param isLE (default: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */
function Field(ORDER, bitLenOrOpts, // TODO: use opts only in v2?
isLE = false, opts = {}) {
    if (ORDER <= _0n$2)
        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);
    let _nbitLength = undefined;
    let _sqrt = undefined;
    let modFromBytes = false;
    let allowedLengths = undefined;
    if (typeof bitLenOrOpts === 'object' && bitLenOrOpts != null) {
        if (opts.sqrt || isLE)
            throw new Error('cannot specify opts in two arguments');
        const _opts = bitLenOrOpts;
        if (_opts.BITS)
            _nbitLength = _opts.BITS;
        if (_opts.sqrt)
            _sqrt = _opts.sqrt;
        if (typeof _opts.isLE === 'boolean')
            isLE = _opts.isLE;
        if (typeof _opts.modFromBytes === 'boolean')
            modFromBytes = _opts.modFromBytes;
        allowedLengths = _opts.allowedLengths;
    }
    else {
        if (typeof bitLenOrOpts === 'number')
            _nbitLength = bitLenOrOpts;
        if (opts.sqrt)
            _sqrt = opts.sqrt;
    }
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
    if (BYTES > 2048)
        throw new Error('invalid field: expected ORDER of <= 2048 bytes');
    let sqrtP; // cached sqrtP
    const f = Object.freeze({
        ORDER,
        isLE,
        BITS,
        BYTES,
        MASK: bitMask(BITS),
        ZERO: _0n$2,
        ONE: _1n$2,
        allowedLengths: allowedLengths,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
            if (typeof num !== 'bigint')
                throw new Error('invalid field element: expected bigint, got ' + typeof num);
            return _0n$2 <= num && num < ORDER; // 0 is valid element, but it's not invertible
        },
        is0: (num) => num === _0n$2,
        // is valid and invertible
        isValidNot0: (num) => !f.is0(num) && f.isValid(num),
        isOdd: (num) => (num & _1n$2) === _1n$2,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: _sqrt ||
            ((n) => {
                if (!sqrtP)
                    sqrtP = FpSqrt(ORDER);
                return sqrtP(f, n);
            }),
        toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),
        fromBytes: (bytes, skipValidation = true) => {
            if (allowedLengths) {
                if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
                    throw new Error('Field.fromBytes: expected ' + allowedLengths + ' bytes, got ' + bytes.length);
                }
                const padded = new Uint8Array(BYTES);
                // isLE add 0 to right, !isLE to the left.
                padded.set(bytes, isLE ? 0 : padded.length - bytes.length);
                bytes = padded;
            }
            if (bytes.length !== BYTES)
                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);
            let scalar = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
            if (modFromBytes)
                scalar = mod(scalar, ORDER);
            if (!skipValidation)
                if (!f.isValid(scalar))
                    throw new Error('invalid field element: outside of range 0..ORDER');
            // NOTE: we don't validate scalar here, please use isValid. This done such way because some
            // protocol may allow non-reduced scalar that reduced later or changed some other way.
            return scalar;
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (a, b, c) => (c ? b : a),
    });
    return Object.freeze(f);
}
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */
function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== 'bigint')
        throw new Error('field order must be bigint');
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
}
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */
function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
}
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */
function mapHashToField(key, fieldOrder, isLE = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
    if (len < 16 || len < minLen || len > 1024)
        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);
    const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);
    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
    const reduced = mod(num, fieldOrder - _1n$2) + _1n$2;
    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

/**
 * Methods for elliptic curve multiplication by scalars.
 * Contains wNAF, pippenger.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$1 = BigInt(0);
const _1n$1 = BigInt(1);
function negateCt(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
}
/**
 * Takes a bunch of Projective Points but executes only one
 * inversion on all of them. Inversion is very slow operation,
 * so this improves performance massively.
 * Optimization: converts a list of projective points to a list of identical points with Z=1.
 */
function normalizeZ(c, points) {
    const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));
    return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
}
function validateW(W, bits) {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);
}
function calcWOpts(W, scalarBits) {
    validateW(W, scalarBits);
    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero
    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero
    const maxNumber = 2 ** W; // W=8 256
    const mask = bitMask(W); // W=8 255 == mask 0b11111111
    const shiftBy = BigInt(W); // W=8 8
    return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n, window, wOpts) {
    const { windowSize, mask, maxNumber, shiftBy } = wOpts;
    let wbits = Number(n & mask); // extract W bits.
    let nextN = n >> shiftBy; // shift number by W bits.
    // What actually happens here:
    // const highestBit = Number(mask ^ (mask >> 1n));
    // let wbits2 = wbits - 1; // skip zero
    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);
    // split if bits > max: +224 => 256-32
    if (wbits > windowSize) {
        // we skip zero, which means instead of `>= size-1`, we do `> size`
        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.
        nextN += _1n$1; // +256 (carry)
    }
    const offsetStart = window * windowSize;
    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero
    const isZero = wbits === 0; // is current window slice a 0?
    const isNeg = wbits < 0; // is current window slice negative?
    const isNegF = window % 2 !== 0; // fake random statement for noise
    const offsetF = offsetStart; // fake offset for noise
    return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c) {
    if (!Array.isArray(points))
        throw new Error('array expected');
    points.forEach((p, i) => {
        if (!(p instanceof c))
            throw new Error('invalid point at index ' + i);
    });
}
function validateMSMScalars(scalars, field) {
    if (!Array.isArray(scalars))
        throw new Error('array of scalars expected');
    scalars.forEach((s, i) => {
        if (!field.isValid(s))
            throw new Error('invalid scalar at index ' + i);
    });
}
// Since points in different groups cannot be equal (different object constructor),
// we can have single place to store precomputes.
// Allows to make points frozen / immutable.
const pointPrecomputes = new WeakMap();
const pointWindowSizes = new WeakMap();
function getW(P) {
    // To disable precomputes:
    // return 1;
    return pointWindowSizes.get(P) || 1;
}
function assert0(n) {
    if (n !== _0n$1)
        throw new Error('invalid wNAF');
}
/**
 * Elliptic curve multiplication of Point by scalar. Fragile.
 * Table generation takes **30MB of ram and 10ms on high-end CPU**,
 * but may take much longer on slow devices. Actual generation will happen on
 * first call of `multiply()`. By default, `BASE` point is precomputed.
 *
 * Scalars should always be less than curve order: this should be checked inside of a curve itself.
 * Creates precomputation tables for fast multiplication:
 * - private scalar is split by fixed size windows of W bits
 * - every window point is collected from window's table & added to accumulator
 * - since windows are different, same point inside tables won't be accessed more than once per calc
 * - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)
 * - +1 window is neccessary for wNAF
 * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
 *
 * @todo Research returning 2d JS array of windows, instead of a single window.
 * This would allow windows to be in different memory locations
 */
class wNAF {
    // Parametrized with a given Point class (not individual point)
    constructor(Point, bits) {
        this.BASE = Point.BASE;
        this.ZERO = Point.ZERO;
        this.Fn = Point.Fn;
        this.bits = bits;
    }
    // non-const time multiplication ladder
    _unsafeLadder(elm, n, p = this.ZERO) {
        let d = elm;
        while (n > _0n$1) {
            if (n & _1n$1)
                p = p.add(d);
            d = d.double();
            n >>= _1n$1;
        }
        return p;
    }
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param point Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(point, W) {
        const { windows, windowSize } = calcWOpts(W, this.bits);
        const points = [];
        let p = point;
        let base = p;
        for (let window = 0; window < windows; window++) {
            base = p;
            points.push(base);
            // i=1, bc we skip 0
            for (let i = 1; i < windowSize; i++) {
                base = base.add(p);
                points.push(base);
            }
            p = base.double();
        }
        return points;
    }
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * More compact implementation:
     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
        // Scalar should be smaller than field order
        if (!this.Fn.isValid(n))
            throw new Error('invalid scalar');
        // Accumulators
        let p = this.ZERO;
        let f = this.BASE;
        // This code was first written with assumption that 'f' and 'p' will never be infinity point:
        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
        // there is negate now: it is possible that negated element from low value
        // would be the same as high element, which will create carry into next window.
        // It's not obvious how this can fail, but still worth investigating later.
        const wo = calcWOpts(W, this.bits);
        for (let window = 0; window < wo.windows; window++) {
            // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise
            const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);
            n = nextN;
            if (isZero) {
                // bits are 0: add garbage to fake point
                // Important part for const-time getPublicKey: add random "noise" point to f.
                f = f.add(negateCt(isNegF, precomputes[offsetF]));
            }
            else {
                // bits are 1: add to result point
                p = p.add(negateCt(isNeg, precomputes[offset]));
            }
        }
        assert0(n);
        // Return both real and fake points: JIT won't eliminate f.
        // At this point there is a way to F be infinity-point even if p is not,
        // which makes it less const-time: around 1 bigint multiply.
        return { p, f };
    }
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
        const wo = calcWOpts(W, this.bits);
        for (let window = 0; window < wo.windows; window++) {
            if (n === _0n$1)
                break; // Early-exit, skip 0 value
            const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);
            n = nextN;
            if (isZero) {
                // Window bits are 0: skip processing.
                // Move to next window.
                continue;
            }
            else {
                const item = precomputes[offset];
                acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM
            }
        }
        assert0(n);
        return acc;
    }
    getPrecomputes(W, point, transform) {
        // Calculate precomputes on a first run, reuse them after
        let comp = pointPrecomputes.get(point);
        if (!comp) {
            comp = this.precomputeWindow(point, W);
            if (W !== 1) {
                // Doing transform outside of if brings 15% perf hit
                if (typeof transform === 'function')
                    comp = transform(comp);
                pointPrecomputes.set(point, comp);
            }
        }
        return comp;
    }
    cached(point, scalar, transform) {
        const W = getW(point);
        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
    }
    unsafe(point, scalar, transform, prev) {
        const W = getW(point);
        if (W === 1)
            return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster
        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
    }
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    createCache(P, W) {
        validateW(W, this.bits);
        pointWindowSizes.set(P, W);
        pointPrecomputes.delete(P);
    }
    hasCache(elm) {
        return getW(elm) !== 1;
    }
}
/**
 * Endomorphism-specific multiplication for Koblitz curves.
 * Cost: 128 dbl, 0-256 adds.
 */
function mulEndoUnsafe(Point, point, k1, k2) {
    let acc = point;
    let p1 = Point.ZERO;
    let p2 = Point.ZERO;
    while (k1 > _0n$1 || k2 > _0n$1) {
        if (k1 & _1n$1)
            p1 = p1.add(acc);
        if (k2 & _1n$1)
            p2 = p2.add(acc);
        acc = acc.double();
        k1 >>= _1n$1;
        k2 >>= _1n$1;
    }
    return { p1, p2 };
}
/**
 * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).
 * 30x faster vs naive addition on L=4096, 10x faster than precomputes.
 * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.
 * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.
 * @param c Curve Point constructor
 * @param fieldN field over CURVE.N - important that it's not over CURVE.P
 * @param points array of L curve points
 * @param scalars array of L scalars (aka secret keys / bigints)
 */
function pippenger(c, fieldN, points, scalars) {
    // If we split scalars by some window (let's say 8 bits), every chunk will only
    // take 256 buckets even if there are 4096 scalars, also re-uses double.
    // TODO:
    // - https://eprint.iacr.org/2024/750.pdf
    // - https://tches.iacr.org/index.php/TCHES/article/view/10287
    // 0 is accepted in scalars
    validateMSMPoints(points, c);
    validateMSMScalars(scalars, fieldN);
    const plength = points.length;
    const slength = scalars.length;
    if (plength !== slength)
        throw new Error('arrays of points and scalars must have equal length');
    // if (plength === 0) throw new Error('array must be of length >= 2');
    const zero = c.ZERO;
    const wbits = bitLen(BigInt(plength));
    let windowSize = 1; // bits
    if (wbits > 12)
        windowSize = wbits - 3;
    else if (wbits > 4)
        windowSize = wbits - 2;
    else if (wbits > 0)
        windowSize = 2;
    const MASK = bitMask(windowSize);
    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array
    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
    let sum = zero;
    for (let i = lastBits; i >= 0; i -= windowSize) {
        buckets.fill(zero);
        for (let j = 0; j < slength; j++) {
            const scalar = scalars[j];
            const wbits = Number((scalar >> BigInt(i)) & MASK);
            buckets[wbits] = buckets[wbits].add(points[j]);
        }
        let resI = zero; // not using this will do small speed-up, but will lose ct
        // Skip first bucket, because it is zero
        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
            sumI = sumI.add(buckets[j]);
            resI = resI.add(sumI);
        }
        sum = sum.add(resI);
        if (i !== 0)
            for (let j = 0; j < windowSize; j++)
                sum = sum.double();
    }
    return sum;
}
function createField(order, field, isLE) {
    if (field) {
        if (field.ORDER !== order)
            throw new Error('Field.ORDER must match order: Fp == p, Fn == n');
        validateField(field);
        return field;
    }
    else {
        return Field(order, { isLE });
    }
}
/** Validates CURVE opts and creates fields */
function _createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {
    if (FpFnLE === undefined)
        FpFnLE = type === 'edwards';
    if (!CURVE || typeof CURVE !== 'object')
        throw new Error(`expected valid ${type} CURVE object`);
    for (const p of ['p', 'n', 'h']) {
        const val = CURVE[p];
        if (!(typeof val === 'bigint' && val > _0n$1))
            throw new Error(`CURVE.${p} must be positive bigint`);
    }
    const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);
    const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);
    const _b = 'b' ;
    const params = ['Gx', 'Gy', 'a', _b];
    for (const p of params) {
        // @ts-ignore
        if (!Fp.isValid(CURVE[p]))
            throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
    }
    CURVE = Object.freeze(Object.assign({}, CURVE));
    return { CURVE, Fp, Fn };
}

/**
 * Short Weierstrass curve methods. The formula is: y = x + ax + b.
 *
 * ### Design rationale for types
 *
 * * Interaction between classes from different curves should fail:
 *   `k256.Point.BASE.add(p256.Point.BASE)`
 * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime
 * * Different calls of `curve()` would return different classes -
 *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,
 *   it won't affect others
 *
 * TypeScript can't infer types for classes created inside a function. Classes is one instance
 * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create
 * unique type for every function call.
 *
 * We can use generic types via some param, like curve opts, but that would:
 *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)
 *     which is hard to debug.
 *     2. Params can be generic and we can't enforce them to be constant value:
 *     if somebody creates curve from non-constant params,
 *     it would be allowed to interact with other curves with non-constant params
 *
 * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// We construct basis in such way that den is always positive and equals n, but num sign depends on basis (not on secret value)
const divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n$1) / den;
/**
 * Splits scalar for GLV endomorphism.
 */
function _splitEndoScalar(k, basis, n) {
    // Split scalar into two such that part is ~half bits: `abs(part) < sqrt(N)`
    // Since part can be negative, we need to do this on point.
    // TODO: verifyScalar function which consumes lambda
    const [[a1, b1], [a2, b2]] = basis;
    const c1 = divNearest(b2 * k, n);
    const c2 = divNearest(-b1 * k, n);
    // |k1|/|k2| is < sqrt(N), but can be negative.
    // If we do `k1 mod N`, we'll get big scalar (`> sqrt(N)`): so, we do cheaper negation instead.
    let k1 = k - c1 * a1 - c2 * a2;
    let k2 = -c1 * b1 - c2 * b2;
    const k1neg = k1 < _0n;
    const k2neg = k2 < _0n;
    if (k1neg)
        k1 = -k1;
    if (k2neg)
        k2 = -k2;
    // Double check that resulting scalar less than half bits of N: otherwise wNAF will fail.
    // This should only happen on wrong basises. Also, math inside is too complex and I don't trust it.
    const MAX_NUM = bitMask(Math.ceil(bitLen(n) / 2)) + _1n; // Half bits of N
    if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {
        throw new Error('splitScalar (endomorphism): failed, k=' + k);
    }
    return { k1neg, k1, k2neg, k2 };
}
function validateSigFormat(format) {
    if (!['compact', 'recovered', 'der'].includes(format))
        throw new Error('Signature format must be "compact", "recovered", or "der"');
    return format;
}
function validateSigOpts(opts, def) {
    const optsn = {};
    for (let optName of Object.keys(def)) {
        // @ts-ignore
        optsn[optName] = opts[optName] === undefined ? def[optName] : opts[optName];
    }
    _abool2(optsn.lowS, 'lowS');
    _abool2(optsn.prehash, 'prehash');
    if (optsn.format !== undefined)
        validateSigFormat(optsn.format);
    return optsn;
}
class DERErr extends Error {
    constructor(m = '') {
        super(m);
    }
}
/**
 * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:
 *
 *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]
 *
 * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html
 */
const DER = {
    // asn.1 DER encoding utils
    Err: DERErr,
    // Basic building block is TLV (Tag-Length-Value)
    _tlv: {
        encode: (tag, data) => {
            const { Err: E } = DER;
            if (tag < 0 || tag > 256)
                throw new E('tlv.encode: wrong tag');
            if (data.length & 1)
                throw new E('tlv.encode: unpadded data');
            const dataLen = data.length / 2;
            const len = numberToHexUnpadded(dataLen);
            if ((len.length / 2) & 128)
                throw new E('tlv.encode: long form length too big');
            // length of length with long form flag
            const lenLen = dataLen > 127 ? numberToHexUnpadded((len.length / 2) | 128) : '';
            const t = numberToHexUnpadded(tag);
            return t + lenLen + len + data;
        },
        // v - value, l - left bytes (unparsed)
        decode(tag, data) {
            const { Err: E } = DER;
            let pos = 0;
            if (tag < 0 || tag > 256)
                throw new E('tlv.encode: wrong tag');
            if (data.length < 2 || data[pos++] !== tag)
                throw new E('tlv.decode: wrong tlv');
            const first = data[pos++];
            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form
            let length = 0;
            if (!isLong)
                length = first;
            else {
                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]
                const lenLen = first & 127;
                if (!lenLen)
                    throw new E('tlv.decode(long): indefinite length not supported');
                if (lenLen > 4)
                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js
                const lengthBytes = data.subarray(pos, pos + lenLen);
                if (lengthBytes.length !== lenLen)
                    throw new E('tlv.decode: length bytes not complete');
                if (lengthBytes[0] === 0)
                    throw new E('tlv.decode(long): zero leftmost byte');
                for (const b of lengthBytes)
                    length = (length << 8) | b;
                pos += lenLen;
                if (length < 128)
                    throw new E('tlv.decode(long): not minimal encoding');
            }
            const v = data.subarray(pos, pos + length);
            if (v.length !== length)
                throw new E('tlv.decode: wrong value length');
            return { v, l: data.subarray(pos + length) };
        },
    },
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    _int: {
        encode(num) {
            const { Err: E } = DER;
            if (num < _0n)
                throw new E('integer: negative integers are not allowed');
            let hex = numberToHexUnpadded(num);
            // Pad with zero byte if negative flag is present
            if (Number.parseInt(hex[0], 16) & 0b1000)
                hex = '00' + hex;
            if (hex.length & 1)
                throw new E('unexpected DER parsing assertion: unpadded hex');
            return hex;
        },
        decode(data) {
            const { Err: E } = DER;
            if (data[0] & 128)
                throw new E('invalid signature integer: negative');
            if (data[0] === 0x00 && !(data[1] & 128))
                throw new E('invalid signature integer: unnecessary leading zero');
            return bytesToNumberBE(data);
        },
    },
    toSig(hex) {
        // parse DER signature
        const { Err: E, _int: int, _tlv: tlv } = DER;
        const data = ensureBytes('signature', hex);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);
        if (seqLeftBytes.length)
            throw new E('invalid signature: left bytes after parsing');
        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);
        if (sLeftBytes.length)
            throw new E('invalid signature: left bytes after parsing');
        return { r: int.decode(rBytes), s: int.decode(sBytes) };
    },
    hexFromSig(sig) {
        const { _tlv: tlv, _int: int } = DER;
        const rs = tlv.encode(0x02, int.encode(sig.r));
        const ss = tlv.encode(0x02, int.encode(sig.s));
        const seq = rs + ss;
        return tlv.encode(0x30, seq);
    },
};
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n$1 = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
function _normFnElement(Fn, key) {
    const { BYTES: expected } = Fn;
    let num;
    if (typeof key === 'bigint') {
        num = key;
    }
    else {
        let bytes = ensureBytes('private key', key);
        try {
            num = Fn.fromBytes(bytes);
        }
        catch (error) {
            throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
        }
    }
    if (!Fn.isValidNot0(num))
        throw new Error('invalid private key: out of range [1..N-1]');
    return num;
}
/**
 * Creates weierstrass Point constructor, based on specified curve options.
 *
 * @example
```js
const opts = {
  p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),
  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),
  h: BigInt(1),
  a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),
  b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),
  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),
  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),
};
const p256_Point = weierstrass(opts);
```
 */
function weierstrassN(params, extraOpts = {}) {
    const validated = _createCurveFields('weierstrass', params, extraOpts);
    const { Fp, Fn } = validated;
    let CURVE = validated.CURVE;
    const { h: cofactor, n: CURVE_ORDER } = CURVE;
    _validateObject(extraOpts, {}, {
        allowInfinityPoint: 'boolean',
        clearCofactor: 'function',
        isTorsionFree: 'function',
        fromBytes: 'function',
        toBytes: 'function',
        endo: 'object',
        wrapPrivateKey: 'boolean',
    });
    const { endo } = extraOpts;
    if (endo) {
        // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });
        if (!Fp.is0(CURVE.a) || typeof endo.beta !== 'bigint' || !Array.isArray(endo.basises)) {
            throw new Error('invalid endo: expected "beta": bigint and "basises": array');
        }
    }
    const lengths = getWLengths(Fp, Fn);
    function assertCompressionIsSupported() {
        if (!Fp.isOdd)
            throw new Error('compression is not supported: Field does not have .isOdd()');
    }
    // Implements IEEE P1363 point encoding
    function pointToBytes(_c, point, isCompressed) {
        const { x, y } = point.toAffine();
        const bx = Fp.toBytes(x);
        _abool2(isCompressed, 'isCompressed');
        if (isCompressed) {
            assertCompressionIsSupported();
            const hasEvenY = !Fp.isOdd(y);
            return concatBytes(pprefix(hasEvenY), bx);
        }
        else {
            return concatBytes(Uint8Array.of(0x04), bx, Fp.toBytes(y));
        }
    }
    function pointFromBytes(bytes) {
        _abytes2(bytes, undefined, 'Point');
        const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths; // e.g. for 32-byte: 33, 65
        const length = bytes.length;
        const head = bytes[0];
        const tail = bytes.subarray(1);
        // No actual validation is done here: use .assertValidity()
        if (length === comp && (head === 0x02 || head === 0x03)) {
            const x = Fp.fromBytes(tail);
            if (!Fp.isValid(x))
                throw new Error('bad point: is not on curve, wrong x');
            const y2 = weierstrassEquation(x); // y = x + ax + b
            let y;
            try {
                y = Fp.sqrt(y2); // y = y ^ (p+1)/4
            }
            catch (sqrtError) {
                const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';
                throw new Error('bad point: is not on curve, sqrt error' + err);
            }
            assertCompressionIsSupported();
            const isYOdd = Fp.isOdd(y); // (y & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1; // ECDSA-specific
            if (isHeadOdd !== isYOdd)
                y = Fp.neg(y);
            return { x, y };
        }
        else if (length === uncomp && head === 0x04) {
            // TODO: more checks
            const L = Fp.BYTES;
            const x = Fp.fromBytes(tail.subarray(0, L));
            const y = Fp.fromBytes(tail.subarray(L, L * 2));
            if (!isValidXY(x, y))
                throw new Error('bad point: is not on curve');
            return { x, y };
        }
        else {
            throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);
        }
    }
    const encodePoint = extraOpts.toBytes || pointToBytes;
    const decodePoint = extraOpts.fromBytes || pointFromBytes;
    function weierstrassEquation(x) {
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x * x
        return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b); // x + a * x + b
    }
    // TODO: move top-level
    /** Checks whether equation holds for given x, y: y == x + ax + b */
    function isValidXY(x, y) {
        const left = Fp.sqr(y); // y
        const right = weierstrassEquation(x); // x + ax + b
        return Fp.eql(left, right);
    }
    // Validate whether the passed curve params are valid.
    // Test 1: equation y = x + ax + b should work for generator point.
    if (!isValidXY(CURVE.Gx, CURVE.Gy))
        throw new Error('bad curve params: generator point');
    // Test 2: discriminant  part should be non-zero: 4a + 27b != 0.
    // Guarantees curve is genus-1, smooth (non-singular).
    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);
    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
    if (Fp.is0(Fp.add(_4a3, _27b2)))
        throw new Error('bad curve params: a or b');
    /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */
    function acoord(title, n, banZero = false) {
        if (!Fp.isValid(n) || (banZero && Fp.is0(n)))
            throw new Error(`bad point coordinate ${title}`);
        return n;
    }
    function aprjpoint(other) {
        if (!(other instanceof Point))
            throw new Error('ProjectivePoint expected');
    }
    function splitEndoScalarN(k) {
        if (!endo || !endo.basises)
            throw new Error('no endo');
        return _splitEndoScalar(k, endo.basises, Fn.ORDER);
    }
    // Memoized toAffine / validity check. They are heavy. Points are immutable.
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (X, Y, Z)  (x=X/Z, y=Y/Z)
    const toAffineMemo = memoized((p, iz) => {
        const { X, Y, Z } = p;
        // Fast-path for normalized points
        if (Fp.eql(Z, Fp.ONE))
            return { x: X, y: Y };
        const is0 = p.is0();
        // If invZ was 0, we return zero point. However we still want to execute
        // all operations, so we replace invZ with a random number, 1.
        if (iz == null)
            iz = is0 ? Fp.ONE : Fp.inv(Z);
        const x = Fp.mul(X, iz);
        const y = Fp.mul(Y, iz);
        const zz = Fp.mul(Z, iz);
        if (is0)
            return { x: Fp.ZERO, y: Fp.ZERO };
        if (!Fp.eql(zz, Fp.ONE))
            throw new Error('invZ was invalid');
        return { x, y };
    });
    // NOTE: on exception this will crash 'cached' and no value will be set.
    // Otherwise true will be return
    const assertValidMemo = memoized((p) => {
        if (p.is0()) {
            // (0, 1, 0) aka ZERO is invalid in most contexts.
            // In BLS, ZERO can be serialized, so we allow it.
            // (0, 0, 0) is invalid representation of ZERO.
            if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y))
                return;
            throw new Error('bad point: ZERO');
        }
        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
        const { x, y } = p.toAffine();
        if (!Fp.isValid(x) || !Fp.isValid(y))
            throw new Error('bad point: x or y not field elements');
        if (!isValidXY(x, y))
            throw new Error('bad point: equation left != right');
        if (!p.isTorsionFree())
            throw new Error('bad point: not in prime-order subgroup');
        return true;
    });
    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
        k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
        k1p = negateCt(k1neg, k1p);
        k2p = negateCt(k2neg, k2p);
        return k1p.add(k2p);
    }
    /**
     * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z)  (x=X/Z, y=Y/Z).
     * Default Point works in 2d / affine coordinates: (x, y).
     * We're doing calculations in projective, because its operations don't require costly inversion.
     */
    class Point {
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        constructor(X, Y, Z) {
            this.X = acoord('x', X);
            this.Y = acoord('y', Y, true);
            this.Z = acoord('z', Z);
            Object.freeze(this);
        }
        static CURVE() {
            return CURVE;
        }
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y))
                throw new Error('invalid affine point');
            if (p instanceof Point)
                throw new Error('projective point not allowed');
            // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)
            if (Fp.is0(x) && Fp.is0(y))
                return Point.ZERO;
            return new Point(x, y, Fp.ONE);
        }
        static fromBytes(bytes) {
            const P = Point.fromAffine(decodePoint(_abytes2(bytes, undefined, 'point')));
            P.assertValidity();
            return P;
        }
        static fromHex(hex) {
            return Point.fromBytes(ensureBytes('pointHex', hex));
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        /**
         *
         * @param windowSize
         * @param isLazy true will defer table computation until the first multiplication
         * @returns
         */
        precompute(windowSize = 8, isLazy = true) {
            wnaf.createCache(this, windowSize);
            if (!isLazy)
                this.multiply(_3n); // random number
            return this;
        }
        // TODO: return `this`
        /** A point on curve is valid if it conforms to equation. */
        assertValidity() {
            assertValidMemo(this);
        }
        hasEvenY() {
            const { y } = this.toAffine();
            if (!Fp.isOdd)
                throw new Error("Field doesn't support isOdd");
            return !Fp.isOdd(y);
        }
        /** Compare one point to another. */
        equals(other) {
            aprjpoint(other);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const { X: X2, Y: Y2, Z: Z2 } = other;
            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
        }
        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
        negate() {
            return new Point(this.X, Fp.neg(this.Y), this.Z);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a, b } = CURVE;
            const b3 = Fp.mul(b, _3n);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            let t0 = Fp.mul(X1, X1); // step 1
            let t1 = Fp.mul(Y1, Y1);
            let t2 = Fp.mul(Z1, Z1);
            let t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3); // step 5
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3); // step 10
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3); // step 15
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0); // step 20
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1); // step 25
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3); // step 30
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
            aprjpoint(other);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const { X: X2, Y: Y2, Z: Z2 } = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            const a = CURVE.a;
            const b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2); // step 1
            let t1 = Fp.mul(Y1, Y2);
            let t2 = Fp.mul(Z1, Z2);
            let t3 = Fp.add(X1, Y1);
            let t4 = Fp.add(X2, Y2); // step 5
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2); // step 10
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2); // step 15
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2); // step 20
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0); // step 25
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2); // step 30
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4); // step 35
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0); // step 40
            return new Point(X3, Y3, Z3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
            const { endo } = extraOpts;
            if (!Fn.isValidNot0(scalar))
                throw new Error('invalid scalar: out of range'); // 0 is invalid
            let point, fake; // Fake point is used to const-time mult
            const mul = (n) => wnaf.cached(this, n, (p) => normalizeZ(Point, p));
            /** See docs for {@link EndomorphismOpts} */
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
                const { p: k1p, f: k1f } = mul(k1);
                const { p: k2p, f: k2f } = mul(k2);
                fake = k1f.add(k2f);
                point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);
            }
            else {
                const { p, f } = mul(scalar);
                point = p;
                fake = f;
            }
            // Normalize `z` for both points, but return only real one
            return normalizeZ(Point, [point, fake])[0];
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed secret key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(sc) {
            const { endo } = extraOpts;
            const p = this;
            if (!Fn.isValid(sc))
                throw new Error('invalid scalar: out of range'); // 0 is valid
            if (sc === _0n || p.is0())
                return Point.ZERO;
            if (sc === _1n)
                return p; // fast-path
            if (wnaf.hasCache(this))
                return this.multiply(sc);
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
                const { p1, p2 } = mulEndoUnsafe(Point, p, k1, k2); // 30% faster vs wnaf.unsafe
                return finishEndo(endo.beta, p1, p2, k1neg, k2neg);
            }
            else {
                return wnaf.unsafe(p, sc);
            }
        }
        multiplyAndAddUnsafe(Q, a, b) {
            const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
            return sum.is0() ? undefined : sum;
        }
        /**
         * Converts Projective point to affine (x, y) coordinates.
         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
         */
        toAffine(invertedZ) {
            return toAffineMemo(this, invertedZ);
        }
        /**
         * Checks whether Point is free of torsion elements (is in prime subgroup).
         * Always torsion-free for cofactor=1 curves.
         */
        isTorsionFree() {
            const { isTorsionFree } = extraOpts;
            if (cofactor === _1n)
                return true;
            if (isTorsionFree)
                return isTorsionFree(Point, this);
            return wnaf.unsafe(this, CURVE_ORDER).is0();
        }
        clearCofactor() {
            const { clearCofactor } = extraOpts;
            if (cofactor === _1n)
                return this; // Fast-path
            if (clearCofactor)
                return clearCofactor(Point, this);
            return this.multiplyUnsafe(cofactor);
        }
        isSmallOrder() {
            // can we use this.clearCofactor()?
            return this.multiplyUnsafe(cofactor).is0();
        }
        toBytes(isCompressed = true) {
            _abool2(isCompressed, 'isCompressed');
            this.assertValidity();
            return encodePoint(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
            return bytesToHex(this.toBytes(isCompressed));
        }
        toString() {
            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;
        }
        // TODO: remove
        get px() {
            return this.X;
        }
        get py() {
            return this.X;
        }
        get pz() {
            return this.Z;
        }
        toRawBytes(isCompressed = true) {
            return this.toBytes(isCompressed);
        }
        _setWindowSize(windowSize) {
            this.precompute(windowSize);
        }
        static normalizeZ(points) {
            return normalizeZ(Point, points);
        }
        static msm(points, scalars) {
            return pippenger(Point, Fn, points, scalars);
        }
        static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(_normFnElement(Fn, privateKey));
        }
    }
    // base / generator point
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
    // zero / infinity / identity point
    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0
    // math field
    Point.Fp = Fp;
    // scalar field
    Point.Fn = Fn;
    const bits = Fn.BITS;
    const wnaf = new wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);
    Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.
    return Point;
}
// Points start with byte 0x02 when y is even; otherwise 0x03
function pprefix(hasEvenY) {
    return Uint8Array.of(hasEvenY ? 0x02 : 0x03);
}
function getWLengths(Fp, Fn) {
    return {
        secretKey: Fn.BYTES,
        publicKey: 1 + Fp.BYTES,
        publicKeyUncompressed: 1 + 2 * Fp.BYTES,
        publicKeyHasPrefix: true,
        signature: 2 * Fn.BYTES,
    };
}
/**
 * Sometimes users only need getPublicKey, getSharedSecret, and secret key handling.
 * This helper ensures no signature functionality is present. Less code, smaller bundle size.
 */
function ecdh(Point, ecdhOpts = {}) {
    const { Fn } = Point;
    const randomBytes_ = ecdhOpts.randomBytes || randomBytes;
    const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: getMinHashLength(Fn.ORDER) });
    function isValidSecretKey(secretKey) {
        try {
            return !!_normFnElement(Fn, secretKey);
        }
        catch (error) {
            return false;
        }
    }
    function isValidPublicKey(publicKey, isCompressed) {
        const { publicKey: comp, publicKeyUncompressed } = lengths;
        try {
            const l = publicKey.length;
            if (isCompressed === true && l !== comp)
                return false;
            if (isCompressed === false && l !== publicKeyUncompressed)
                return false;
            return !!Point.fromBytes(publicKey);
        }
        catch (error) {
            return false;
        }
    }
    /**
     * Produces cryptographically secure secret key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    function randomSecretKey(seed = randomBytes_(lengths.seed)) {
        return mapHashToField(_abytes2(seed, lengths.seed, 'seed'), Fn.ORDER);
    }
    /**
     * Computes public key for a secret key. Checks for validity of the secret key.
     * @param isCompressed whether to return compact (default), or full key
     * @returns Public key, full when isCompressed=false; short when isCompressed=true
     */
    function getPublicKey(secretKey, isCompressed = true) {
        return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);
    }
    function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: getPublicKey(secretKey) };
    }
    /**
     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
     */
    function isProbPub(item) {
        if (typeof item === 'bigint')
            return false;
        if (item instanceof Point)
            return true;
        const { secretKey, publicKey, publicKeyUncompressed } = lengths;
        if (Fn.allowedLengths || secretKey === publicKey)
            return undefined;
        const l = ensureBytes('key', item).length;
        return l === publicKey || l === publicKeyUncompressed;
    }
    /**
     * ECDH (Elliptic Curve Diffie Hellman).
     * Computes shared public key from secret key A and public key B.
     * Checks: 1) secret key validity 2) shared key is on-curve.
     * Does NOT hash the result.
     * @param isCompressed whether to return compact (default), or full key
     * @returns shared public key
     */
    function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
        if (isProbPub(secretKeyA) === true)
            throw new Error('first arg must be private key');
        if (isProbPub(publicKeyB) === false)
            throw new Error('second arg must be public key');
        const s = _normFnElement(Fn, secretKeyA);
        const b = Point.fromHex(publicKeyB); // checks for being on-curve
        return b.multiply(s).toBytes(isCompressed);
    }
    const utils = {
        isValidSecretKey,
        isValidPublicKey,
        randomSecretKey,
        // TODO: remove
        isValidPrivateKey: isValidSecretKey,
        randomPrivateKey: randomSecretKey,
        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
        precompute(windowSize = 8, point = Point.BASE) {
            return point.precompute(windowSize, false);
        },
    };
    return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });
}
/**
 * Creates ECDSA signing interface for given elliptic curve `Point` and `hash` function.
 * We need `hash` for 2 features:
 * 1. Message prehash-ing. NOT used if `sign` / `verify` are called with `prehash: false`
 * 2. k generation in `sign`, using HMAC-drbg(hash)
 *
 * ECDSAOpts are only rarely needed.
 *
 * @example
 * ```js
 * const p256_Point = weierstrass(...);
 * const p256_sha256 = ecdsa(p256_Point, sha256);
 * const p256_sha224 = ecdsa(p256_Point, sha224);
 * const p256_sha224_r = ecdsa(p256_Point, sha224, { randomBytes: (length) => { ... } });
 * ```
 */
function ecdsa(Point, hash, ecdsaOpts = {}) {
    ahash(hash);
    _validateObject(ecdsaOpts, {}, {
        hmac: 'function',
        lowS: 'boolean',
        randomBytes: 'function',
        bits2int: 'function',
        bits2int_modN: 'function',
    });
    const randomBytes$1 = ecdsaOpts.randomBytes || randomBytes;
    const hmac$1 = ecdsaOpts.hmac ||
        ((key, ...msgs) => hmac(hash, key, concatBytes(...msgs)));
    const { Fp, Fn } = Point;
    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
    const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);
    const defaultSigOpts = {
        prehash: false,
        lowS: typeof ecdsaOpts.lowS === 'boolean' ? ecdsaOpts.lowS : false,
        format: undefined, //'compact' as ECDSASigFormat,
        extraEntropy: false,
    };
    const defaultSigOpts_format = 'compact';
    function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
    }
    function validateRS(title, num) {
        if (!Fn.isValidNot0(num))
            throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
        return num;
    }
    function validateSigLength(bytes, format) {
        validateSigFormat(format);
        const size = lengths.signature;
        const sizer = format === 'compact' ? size : format === 'recovered' ? size + 1 : undefined;
        return _abytes2(bytes, sizer, `${format} signature`);
    }
    /**
     * ECDSA signature with its (r, s) properties. Supports compact, recovered & DER representations.
     */
    class Signature {
        constructor(r, s, recovery) {
            this.r = validateRS('r', r); // r in [1..N-1];
            this.s = validateRS('s', s); // s in [1..N-1];
            if (recovery != null)
                this.recovery = recovery;
            Object.freeze(this);
        }
        static fromBytes(bytes, format = defaultSigOpts_format) {
            validateSigLength(bytes, format);
            let recid;
            if (format === 'der') {
                const { r, s } = DER.toSig(_abytes2(bytes));
                return new Signature(r, s);
            }
            if (format === 'recovered') {
                recid = bytes[0];
                format = 'compact';
                bytes = bytes.subarray(1);
            }
            const L = Fn.BYTES;
            const r = bytes.subarray(0, L);
            const s = bytes.subarray(L, L * 2);
            return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);
        }
        static fromHex(hex, format) {
            return this.fromBytes(hexToBytes(hex), format);
        }
        addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(messageHash) {
            const FIELD_ORDER = Fp.ORDER;
            const { r, s, recovery: rec } = this;
            if (rec == null || ![0, 1, 2, 3].includes(rec))
                throw new Error('recovery id invalid');
            // ECDSA recovery is hard for cofactor > 1 curves.
            // In sign, `r = q.x mod n`, and here we recover q.x from r.
            // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.
            // However, for cofactor>1, r+n may not get q.x:
            // r+n*i would need to be done instead where i is unknown.
            // To easily get i, we either need to:
            // a. increase amount of valid recid values (4, 5...); OR
            // b. prohibit non-prime-order signatures (recid > 1).
            const hasCofactor = CURVE_ORDER * _2n$1 < FIELD_ORDER;
            if (hasCofactor && rec > 1)
                throw new Error('recovery id is ambiguous for h>1 curve');
            const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
            if (!Fp.isValid(radj))
                throw new Error('recovery id 2 or 3 invalid');
            const x = Fp.toBytes(radj);
            const R = Point.fromBytes(concatBytes(pprefix((rec & 1) === 0), x));
            const ir = Fn.inv(radj); // r^-1
            const h = bits2int_modN(ensureBytes('msgHash', messageHash)); // Truncate hash
            const u1 = Fn.create(-h * ir); // -hr^-1
            const u2 = Fn.create(s * ir); // sr^-1
            // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.
            const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
            if (Q.is0())
                throw new Error('point at infinify');
            Q.assertValidity();
            return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return isBiggerThanHalfOrder(this.s);
        }
        toBytes(format = defaultSigOpts_format) {
            validateSigFormat(format);
            if (format === 'der')
                return hexToBytes(DER.hexFromSig(this));
            const r = Fn.toBytes(this.r);
            const s = Fn.toBytes(this.s);
            if (format === 'recovered') {
                if (this.recovery == null)
                    throw new Error('recovery bit must be present');
                return concatBytes(Uint8Array.of(this.recovery), r, s);
            }
            return concatBytes(r, s);
        }
        toHex(format) {
            return bytesToHex(this.toBytes(format));
        }
        // TODO: remove
        assertValidity() { }
        static fromCompact(hex) {
            return Signature.fromBytes(ensureBytes('sig', hex), 'compact');
        }
        static fromDER(hex) {
            return Signature.fromBytes(ensureBytes('sig', hex), 'der');
        }
        normalizeS() {
            return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;
        }
        toDERRawBytes() {
            return this.toBytes('der');
        }
        toDERHex() {
            return bytesToHex(this.toBytes('der'));
        }
        toCompactRawBytes() {
            return this.toBytes('compact');
        }
        toCompactHex() {
            return bytesToHex(this.toBytes('compact'));
        }
    }
    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
    const bits2int = ecdsaOpts.bits2int ||
        function bits2int_def(bytes) {
            // Our custom check "just in case", for protection against DoS
            if (bytes.length > 8192)
                throw new Error('input is too large');
            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
            // for some cases, since bytes.length * 8 is not actual bitLength.
            const num = bytesToNumberBE(bytes); // check for == u8 done here
            const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits
            return delta > 0 ? num >> BigInt(delta) : num;
        };
    const bits2int_modN = ecdsaOpts.bits2int_modN ||
        function bits2int_modN_def(bytes) {
            return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here
        };
    // Pads output with zero as per spec
    const ORDER_MASK = bitMask(fnBits);
    /** Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`. */
    function int2octets(num) {
        // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`
        aInRange('num < 2^' + fnBits, num, _0n, ORDER_MASK);
        return Fn.toBytes(num);
    }
    function validateMsgAndHash(message, prehash) {
        _abytes2(message, undefined, 'message');
        return prehash ? _abytes2(hash(message), undefined, 'prehashed message') : message;
    }
    /**
     * Steps A, D of RFC6979 3.2.
     * Creates RFC6979 seed; converts msg/privKey to numbers.
     * Used only in sign, not in verify.
     *
     * Warning: we cannot assume here that message has same amount of bytes as curve order,
     * this will be invalid at least for P521. Also it can be bigger for P224 + SHA256.
     */
    function prepSig(message, privateKey, opts) {
        if (['recovered', 'canonical'].some((k) => k in opts))
            throw new Error('sign() legacy options not supported');
        const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
        message = validateMsgAndHash(message, prehash); // RFC6979 3.2 A: h1 = H(m)
        // We can't later call bits2octets, since nested bits2int is broken for curves
        // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.
        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
        const h1int = bits2int_modN(message);
        const d = _normFnElement(Fn, privateKey); // validate secret key, convert to bigint
        const seedArgs = [int2octets(d), int2octets(h1int)];
        // extraEntropy. RFC6979 3.6: additional k' (optional).
        if (extraEntropy != null && extraEntropy !== false) {
            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
            // gen random bytes OR pass as-is
            const e = extraEntropy === true ? randomBytes$1(lengths.secretKey) : extraEntropy;
            seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes
        }
        const seed = concatBytes(...seedArgs); // Step D of RFC6979 3.2
        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
        // Converts signature params into point w r/s, checks result for validity.
        // To transform k => Signature:
        // q = kG
        // r = q.x mod n
        // s = k^-1(m + rd) mod n
        // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to
        // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
        // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
        function k2sig(kBytes) {
            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
            // Important: all mod() calls here must be done over N
            const k = bits2int(kBytes); // mod n, not mod p
            if (!Fn.isValidNot0(k))
                return; // Valid scalars (including k) must be in 1..N-1
            const ik = Fn.inv(k); // k^-1 mod n
            const q = Point.BASE.multiply(k).toAffine(); // q = kG
            const r = Fn.create(q.x); // r = q.x mod n
            if (r === _0n)
                return;
            const s = Fn.create(ik * Fn.create(m + r * d)); // Not using blinding here, see comment above
            if (s === _0n)
                return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
                normS = Fn.neg(s); // if lowS was passed, ensure s is always
                recovery ^= 1; // // in the bottom half of N
            }
            return new Signature(r, normS, recovery); // use normS, not s
        }
        return { seed, k2sig };
    }
    /**
     * Signs message hash with a secret key.
     *
     * ```
     * sign(m, d) where
     *   k = rfc6979_hmac_drbg(m, d)
     *   (x, y) = G  k
     *   r = x mod n
     *   s = (m + dr) / k mod n
     * ```
     */
    function sign(message, secretKey, opts = {}) {
        message = ensureBytes('message', message);
        const { seed, k2sig } = prepSig(message, secretKey, opts); // Steps A, D of RFC6979 3.2.
        const drbg = createHmacDrbg(hash.outputLen, Fn.BYTES, hmac$1);
        const sig = drbg(seed, k2sig); // Steps B, C, D, E, F, G
        return sig;
    }
    function tryParsingSig(sg) {
        // Try to deduce format
        let sig = undefined;
        const isHex = typeof sg === 'string' || isBytes(sg);
        const isObj = !isHex &&
            sg !== null &&
            typeof sg === 'object' &&
            typeof sg.r === 'bigint' &&
            typeof sg.s === 'bigint';
        if (!isHex && !isObj)
            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');
        if (isObj) {
            sig = new Signature(sg.r, sg.s);
        }
        else if (isHex) {
            try {
                sig = Signature.fromBytes(ensureBytes('sig', sg), 'der');
            }
            catch (derError) {
                if (!(derError instanceof DER.Err))
                    throw derError;
            }
            if (!sig) {
                try {
                    sig = Signature.fromBytes(ensureBytes('sig', sg), 'compact');
                }
                catch (error) {
                    return false;
                }
            }
        }
        if (!sig)
            return false;
        return sig;
    }
    /**
     * Verifies a signature against message and public key.
     * Rejects lowS signatures by default: see {@link ECDSAVerifyOpts}.
     * Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
     *
     * ```
     * verify(r, s, h, P) where
     *   u1 = hs^-1 mod n
     *   u2 = rs^-1 mod n
     *   R = u1G + u2P
     *   mod(R.x, n) == r
     * ```
     */
    function verify(signature, message, publicKey, opts = {}) {
        const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);
        publicKey = ensureBytes('publicKey', publicKey);
        message = validateMsgAndHash(ensureBytes('message', message), prehash);
        if ('strict' in opts)
            throw new Error('options.strict was renamed to lowS');
        const sig = format === undefined
            ? tryParsingSig(signature)
            : Signature.fromBytes(ensureBytes('sig', signature), format);
        if (sig === false)
            return false;
        try {
            const P = Point.fromBytes(publicKey);
            if (lowS && sig.hasHighS())
                return false;
            const { r, s } = sig;
            const h = bits2int_modN(message); // mod n, not mod p
            const is = Fn.inv(s); // s^-1 mod n
            const u1 = Fn.create(h * is); // u1 = hs^-1 mod n
            const u2 = Fn.create(r * is); // u2 = rs^-1 mod n
            const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2)); // u1G + u2P
            if (R.is0())
                return false;
            const v = Fn.create(R.x); // v = r.x mod n
            return v === r;
        }
        catch (e) {
            return false;
        }
    }
    function recoverPublicKey(signature, message, opts = {}) {
        const { prehash } = validateSigOpts(opts, defaultSigOpts);
        message = validateMsgAndHash(message, prehash);
        return Signature.fromBytes(signature, 'recovered').recoverPublicKey(message).toBytes();
    }
    return Object.freeze({
        keygen,
        getPublicKey,
        getSharedSecret,
        utils,
        lengths,
        Point,
        sign,
        verify,
        recoverPublicKey,
        Signature,
        hash,
    });
}
function _weierstrass_legacy_opts_to_new(c) {
    const CURVE = {
        a: c.a,
        b: c.b,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy,
    };
    const Fp = c.Fp;
    let allowedLengths = c.allowedPrivateKeyLengths
        ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2))))
        : undefined;
    const Fn = Field(CURVE.n, {
        BITS: c.nBitLength,
        allowedLengths: allowedLengths,
        modFromBytes: c.wrapPrivateKey,
    });
    const curveOpts = {
        Fp,
        Fn,
        allowInfinityPoint: c.allowInfinityPoint,
        endo: c.endo,
        isTorsionFree: c.isTorsionFree,
        clearCofactor: c.clearCofactor,
        fromBytes: c.fromBytes,
        toBytes: c.toBytes,
    };
    return { CURVE, curveOpts };
}
function _ecdsa_legacy_opts_to_new(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
    const ecdsaOpts = {
        hmac: c.hmac,
        randomBytes: c.randomBytes,
        lowS: c.lowS,
        bits2int: c.bits2int,
        bits2int_modN: c.bits2int_modN,
    };
    return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };
}
function _ecdsa_new_output_to_legacy(c, _ecdsa) {
    const Point = _ecdsa.Point;
    return Object.assign({}, _ecdsa, {
        ProjectivePoint: Point,
        CURVE: Object.assign({}, c, nLength(Point.Fn.ORDER, Point.Fn.BITS)),
    });
}
// _ecdsa_legacy
function weierstrass(c) {
    const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
    const Point = weierstrassN(CURVE, curveOpts);
    const signs = ecdsa(Point, hash, ecdsaOpts);
    return _ecdsa_new_output_to_legacy(c, signs);
}

/**
 * Utilities for short weierstrass curves, combined with noble-hashes.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
/** @deprecated use new `weierstrass()` and `ecdsa()` methods */
function createCurve(curveDef, defHash) {
    const create = (hash) => weierstrass({ ...curveDef, hash: hash });
    return { ...create(defHash), create };
}

/**
 * SECG secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).
 *
 * Belongs to Koblitz curves: it has efficiently-computable GLV endomorphism ,
 * check out {@link EndomorphismOpts}. Seems to be rigid (not backdoored).
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Seems like generator was produced from some seed:
// `Point.BASE.multiply(Point.Fn.inv(2n, N)).toAffine().x`
// // gives short x 0x3b78ce563f89a0ed9414f5aa28ad0d96d6795f9c63n
const secp256k1_CURVE = {
    p: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),
    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt('0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    Gy: BigInt('0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'),
};
const secp256k1_ENDO = {
    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
    basises: [
        [BigInt('0x3086d221a7d46bcde86c90e49284eb15'), -BigInt('0xe4437ed6010e88286f547fa90abfe4c3')],
        [BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'), BigInt('0x3086d221a7d46bcde86c90e49284eb15')],
    ],
};
const _2n = /* @__PURE__ */ BigInt(2);
/**
 * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
 * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
 */
function sqrtMod(y) {
    const P = secp256k1_CURVE.p;
    // prettier-ignore
    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    // prettier-ignore
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = (y * y * y) % P; // x^3, 11
    const b3 = (b2 * b2 * y) % P; // x^7
    const b6 = (pow2(b3, _3n, P) * b3) % P;
    const b9 = (pow2(b6, _3n, P) * b3) % P;
    const b11 = (pow2(b9, _2n, P) * b2) % P;
    const b22 = (pow2(b11, _11n, P) * b11) % P;
    const b44 = (pow2(b22, _22n, P) * b22) % P;
    const b88 = (pow2(b44, _44n, P) * b44) % P;
    const b176 = (pow2(b88, _88n, P) * b88) % P;
    const b220 = (pow2(b176, _44n, P) * b44) % P;
    const b223 = (pow2(b220, _3n, P) * b3) % P;
    const t1 = (pow2(b223, _23n, P) * b22) % P;
    const t2 = (pow2(t1, _6n, P) * b2) % P;
    const root = pow2(t2, _2n, P);
    if (!Fpk1.eql(Fpk1.sqr(root), y))
        throw new Error('Cannot find square root');
    return root;
}
const Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });
/**
 * secp256k1 curve, ECDSA and ECDH methods.
 *
 * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`
 *
 * @example
 * ```js
 * import { secp256k1 } from '@noble/curves/secp256k1';
 * const { secretKey, publicKey } = secp256k1.keygen();
 * const msg = new TextEncoder().encode('hello');
 * const sig = secp256k1.sign(msg, secretKey);
 * const isValid = secp256k1.verify(sig, msg, publicKey) === true;
 * ```
 */
const secp256k1 = createCurve({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha256);

/**
 * @description Parses a hex formatted signature into a structured signature.
 *
 * @param signatureHex Signature in hex format.
 * @returns The structured signature.
 *
 * @example
 * parseSignature('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')
 * // { r: '0x...', s: '0x...', v: 28n }
 */
function parseSignature(signatureHex) {
    const { r, s } = secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));
    const yParityOrV = Number(`0x${signatureHex.slice(130)}`);
    const [v, yParity] = (() => {
        if (yParityOrV === 0 || yParityOrV === 1)
            return [undefined, yParityOrV];
        if (yParityOrV === 27)
            return [BigInt(yParityOrV), 0];
        if (yParityOrV === 28)
            return [BigInt(yParityOrV), 1];
        throw new Error('Invalid yParityOrV value');
    })();
    if (typeof v !== 'undefined')
        return {
            r: numberToHex(r, { size: 32 }),
            s: numberToHex(s, { size: 32 }),
            v,
            yParity,
        };
    return {
        r: numberToHex(r, { size: 32 }),
        s: numberToHex(s, { size: 32 }),
        yParity,
    };
}

const CONFIGS$1 = {
    mainnet: {
        packageId: '0x10847461e9082108a764664f5634377168c841d2daf81c2a3de0baa9a42254bd',
        versionedObjectId: '0xf52c4b2af16221e86a0eb606748e70313ae15cdfb0264d7b3fef0c607e501ec6',
        treasuryObjectId: '0x202a3db8723923130e4ff4baaba240fa1f6711acb085f42682fa20d999432b7d',
        txStatusObjectId: '0x4249a9f4eeecf47a1eae43ae145545fcb22ec663ef58ebed458c4117fa638469',
        coinTypeArgs: '0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC',
        arbitrum: {
            chain: {
                id: 42161,
                rpcUrl: 'https://arb1.arbitrum.io/rpc',
                version: '2',
            },
            usdcAddress: '0xaf88d065e77c8cC2239327C5EDb3A432268e5831',
            bridgeAddress: '0x640cbD3728CF363570d5f2a021861eDD3e7EcaCE',
            hyperLiquidAddress: 'string',
            usdcName: 'USD Coin',
        },
        permitDeadlineSecond: 86400 * 365 * 200,
    },
    testnet: {
        packageId: '',
        versionedObjectId: '',
        treasuryObjectId: '',
        txStatusObjectId: '',
        coinTypeArgs: '0x2::sui::SUI',
        arbitrum: {
            chain: {
                id: 42161,
                rpcUrl: 'https://arb1.arbitrum.io/rpc',
                version: '2',
            },
            usdcAddress: '0xaf88d065e77c8cC2239327C5EDb3A432268e5831',
            bridgeAddress: '0xa7f2dD4f18A4658Cbcad70cC885eb7AC63AdfA79',
            hyperLiquidAddress: 'string',
            usdcName: 'USD Coin',
        },
        permitDeadlineSecond: 86400 * 365 * 200,
    },
};

const stringToCharCodes = (str) => {
    return Array.from(str).map((ch) => ch.charCodeAt(0));
};

class Bridge extends TxBuilder {
    constructor(network) {
        super(network);
        this.modulePool = 'bridge_manager';
        this.config = CONFIGS$1[network];
        this.packageId = this.config.packageId;
    }
    permit(walletClient, publicClient) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = this.getTx();
            const permit = yield this.signPermit(walletClient, publicClient);
            const permitSigner = stringToCharCodes(permit.permitSignerAddress);
            const r = stringToCharCodes(permit.r);
            const s = stringToCharCodes(permit.s);
            tx.moveCall({
                target: `${this.packageId}::${this.modulePool}::permit`,
                arguments: [
                    tx.object(this.config.versionedObjectId),
                    tx.pure.vector('u8', permitSigner),
                    tx.pure.u64(maxUint64),
                    tx.pure.u64(permit.deadline),
                    tx.pure.u64(permit.v),
                    tx.pure.vector('u8', r),
                    tx.pure.vector('u8', s),
                ],
            });
            return tx;
        });
    }
    getNonce(evmPublicKey, publicClient) {
        return __awaiter(this, void 0, void 0, function* () {
            const usdcAbi = parseAbi([
                'function nonces(address owner) view returns (uint256)',
            ]);
            const nonce = yield publicClient.readContract({
                address: this.config.arbitrum.usdcAddress,
                abi: usdcAbi,
                functionName: 'nonces',
                args: [evmPublicKey],
                authorizationList: undefined
            });
            return nonce;
        });
    }
    signPermit(walletClient, publicClient) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const publicKey = (_b = (_a = walletClient.account) === null || _a === void 0 ? void 0 : _a.address) !== null && _b !== void 0 ? _b : '';
            const nonce = yield this.getNonce(publicKey, publicClient);
            const payload = {
                owner: publicKey,
                spender: this.config.arbitrum.bridgeAddress,
                value: maxUint64.toString(),
                nonce,
                deadline: Math.floor(Date.now() / 1000) + this.config.permitDeadlineSecond,
            };
            const domain = {
                name: this.config.arbitrum.usdcName,
                version: this.config.arbitrum.chain.version,
                chainId: this.config.arbitrum.chain.id,
                verifyingContract: this.config.arbitrum.usdcAddress,
            };
            const permitTypes = {
                Permit: [
                    { name: 'owner', type: 'address' },
                    { name: 'spender', type: 'address' },
                    { name: 'value', type: 'uint256' },
                    { name: 'nonce', type: 'uint256' },
                    { name: 'deadline', type: 'uint256' },
                ],
            };
            const dataToSign = {
                domain,
                types: permitTypes,
                primaryType: 'Permit',
                message: payload,
                payload,
            };
            const signature = yield walletClient.signTypedData(dataToSign);
            const signatureParsed = parseSignature(signature);
            return {
                r: signatureParsed.r,
                s: signatureParsed.s,
                v: signatureParsed.v,
                deadline: payload.deadline,
                permitSignerAddress: payload.owner,
            };
        });
    }
    getAllowance(publicClient, owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const allowance = yield publicClient.readContract({
                address: this.config.arbitrum.usdcAddress,
                abi: erc20Abi,
                functionName: 'allowance',
                args: [
                    owner,
                    this.config.arbitrum.bridgeAddress,
                ],
                authorizationList: undefined
            });
            return allowance.toString();
        });
    }
    getMaxDeposit(publicClient) {
        return __awaiter(this, void 0, void 0, function* () {
            const balance = yield publicClient.readContract({
                address: this.config.arbitrum.usdcAddress,
                abi: erc20Abi,
                functionName: 'balanceOf',
                args: [
                    this.config.arbitrum.bridgeAddress
                ],
                authorizationList: undefined
            });
            return balance;
        });
    }
    deposit(coin, primaryAddress) {
        const tx = this.getTx();
        tx.moveCall({
            target: `${this.packageId}::${this.modulePool}::deposit`,
            typeArguments: [this.config.coinTypeArgs],
            arguments: [
                tx.object(this.config.versionedObjectId),
                tx.object(this.config.treasuryObjectId),
                typeof coin.object === 'string' ? tx.object(coin.object) : coin.object,
                tx.pure.vector('u8', stringToCharCodes(primaryAddress)),
            ],
        });
        return tx;
    }
}

const CONFIGS = {
    mainnet: {
        packageId: '0x601047df6c9a19af5484870450b9caf76a9207daeba6177c2728e9b91f545ee8',
        vaultObjectId: '0xe6a84cb89183a0f1be00ce525c9d9f5260ef1ccf5454ac177329b1b31c7dc802',
        adminCapObjectId: '0xcc7ee7fdbd544f930a88bb99cd4fc66d3c992ebc9740ea88e05e30c14a4961d7',
    },
    testnet: {
        packageId: '',
        vaultObjectId: '',
        adminCapObjectId: '',
    },
};

class PerpBonus extends TxBuilder {
    constructor(network) {
        super(network);
        this.modulePool = 'perp_bonus';
        this.config = CONFIGS[network];
        this.packageId = this.config.packageId;
    }
    depositFund(coinObjectId) {
        const tx = this.getTx();
        return tx.moveCall({
            target: `${this.packageId}::${this.modulePool}::admin_deposit`,
            arguments: [
                tx.object(this.config.vaultObjectId),
                tx.object(coinObjectId),
            ],
        });
    }
    withdrawFund(amount) {
        const tx = this.getTx();
        return tx.moveCall({
            target: `${this.packageId}::${this.modulePool}::admin_withdraw`,
            arguments: [tx.object(this.config.vaultObjectId), tx.pure.u64(amount)],
        });
    }
    grantWhitelist(accounts, amounts) {
        const tx = this.getTx();
        return tx.moveCall({
            target: `${this.packageId}::${this.modulePool}::grant_whitelist`,
            arguments: [
                tx.object(this.config.adminCapObjectId),
                tx.object(this.config.vaultObjectId),
                tx.pure.vector('address', accounts),
                tx.pure.vector('u64', amounts),
            ],
        });
    }
    revokeWhitelist(accounts) {
        const tx = this.getTx();
        return tx.moveCall({
            target: `${this.packageId}::${this.modulePool}::grant_whitelist`,
            arguments: [
                tx.object(this.config.adminCapObjectId),
                tx.object(this.config.vaultObjectId),
                tx.pure.vector('address', accounts),
            ],
        });
    }
    isEligibleBonus(account) {
        const tx = this.getTx();
        return tx.moveCall({
            target: `${this.packageId}::${this.modulePool}::is_eligible_bonus`,
            arguments: [
                tx.object(this.config.vaultObjectId),
                tx.pure.address(account),
            ],
        });
    }
    claim() {
        const tx = this.getTx();
        return tx.moveCall({
            target: `${this.packageId}::${this.modulePool}::claim`,
            arguments: [
                tx.object(this.config.vaultObjectId),
            ],
        });
    }
}

export { ADDRESS_ZERO, AggregatorQuoter, AmmLiquidityMath, AmmPool, AmmPoolManager, AmmPosition, AmmPositionManager, AutoInvest, BPS$2 as BPS, BasePool, Bridge, CONFIGS$5 as CONFIGS, ClmmLiquidityMath, ClmmPool, ClmmPoolManager, ClmmPosition, ClmmPositionManager, ClmmSqrtPriceMath, ClmmTickMath, Coin, CoinAmount, CoinProvider, Commission, CommissionType, CustomError, DEADLINE_TIME_SECONDS, DEFAULT_CACHE_EXPIRATION_TIME_SECONDS, DEFAULT_CONCURRENCY, DEFAULT_DECIMAL, FLOAT_SCALING, FaaSPool, FaaSPoolManager, FaaSPosition, FaaSPositionManager, FlowXPriceProvider, Fraction, GraphqlProvider, LimitOrderBuilder, MAPPING_INVESTMENT_OBJECT_ID, MAPPING_PACKAGE_ID, MAX_OBJECTS_DEV_INSPECT_PER_QUERY, MAX_OBJECTS_PER_QUERY, MODULE_AUTO_INVEST, MODULE_COMMISSION, MODULE_COMMISSION_TYPE, MODULE_OPTION, MODULE_PLAN_QUERY, MODULE_UNIVERSAL_ROUTER, MaxUint256, MaxUint64, MultiTradesBuilder, NoTickDataProvider, ONE, ONE_DAY, ONE_HOUR, ONE_MINUTE, ONE_MONTH, ONE_WEEK, ObjectId, OrderBCS, PartnerManager, Percent, PerpBonus, Plan, PlanBuilder, PlanStatus, Price, PricePredict, PromiseAll, Protocol, Q128, Q64, QueryResultBCS$1 as QueryResultBCS, Rebalancer, Rounding, Route, STD_PACKAGE_ID, SUI_PACKAGE_ID, SubscriptionCycle, SuiBatchClient, Swap, Tick, TickLibrary, TickList, TickListDataProvider, TickOnchainDataProvider, Trade, TradeBuilder, TxBuilder, TypeNameBCS$1 as TypeNameBCS, ZERO, ZapCalculator, bigNumber as bigNumberUtils, calculateExecutionPrice, calculateSubscriptionInterval, closestActiveRange, encodeSqrtRatioX64, fetchCoin, getAllDynamicFields, getAllOwnedObjects, getDeadlineAtTimestampMs, isSorted, isSortedSymbols, maxBn, minBn, multiGetObjects, now, nowInMilliseconds, priceToClosestTick, queryAllEvents, reflect, removeEmptyFields, sdk, sdkCache, shortedCoinType, sqrtBn, sqrtPriceX64ToPrice, standardShortCoinType, sumBn$1 as sumBn, tickToPrice, toSeconds };
