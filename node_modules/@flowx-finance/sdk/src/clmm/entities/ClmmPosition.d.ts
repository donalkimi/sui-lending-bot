import BN from 'bn.js';
import { BigintIsh, Coin, ObjectId, Percent, Price } from '../../core';
import { CoinAmount } from '../../core/entities/CoinAmount';
import { ClmmPool } from './ClmmPool';
import { ClmmPositionReward } from './ClmmPositionReward';
interface PositionRewardInfoArgs {
    coinsOwedReward: BigintIsh;
    rewardGrowthInsideLast: BigintIsh;
}
interface PositionConstructorArgs {
    objectId?: string;
    owner: string;
    pool: ClmmPool;
    tickLower: number;
    tickUpper: number;
    liquidity: BigintIsh;
    coinsOwedX: BigintIsh;
    coinsOwedY: BigintIsh;
    feeGrowthInsideXLast: BigintIsh;
    feeGrowthInsideYLast: BigintIsh;
    rewardInfos: PositionRewardInfoArgs[];
}
export declare class ClmmPosition extends ObjectId {
    readonly owner: string;
    readonly pool: ClmmPool;
    readonly tickLower: number;
    readonly tickUpper: number;
    readonly liquidity: BN;
    readonly coinsOwedX: BN;
    readonly coinsOwedY: BN;
    readonly feeGrowthInsideXLast: BN;
    readonly feeGrowthInsideYLast: BN;
    readonly rewardInfos: ClmmPositionReward[];
    feeReward: CoinAmount<Coin>[] | null;
    incentiveReward: CoinAmount<Coin>[] | null;
    private _coinXAmount;
    private _coinYAmount;
    private _mintAmounts;
    constructor({ objectId, owner, pool, tickLower, tickUpper, liquidity, coinsOwedX, coinsOwedY, feeGrowthInsideXLast, feeGrowthInsideYLast, rewardInfos, }: PositionConstructorArgs);
    get priceLower(): Price<Coin, Coin>;
    get priceUpper(): Price<Coin, Coin>;
    get amountX(): CoinAmount<Coin>;
    /**
     * Returns the amount of token1 that this position's liquidity could be burned for at the current pool price
     */
    get amountY(): CoinAmount<Coin>;
    get mintAmounts(): Readonly<{
        amountX: BN;
        amountY: BN;
    }>;
    /**
     * Computes the maximum amount of liquidity received for a given amount of tokenX, tokenY,
     * and the prices at the tick boundaries.
     * @param objectId The object ID of the position, if it exists
     * @param owner The owner of the position
     * @param pool The pool for which the position should be created
     * @param tickLower The lower tick of the position
     * @param tickUpper The upper tick of the position
     * @param amountX tokenX amount
     * @param amountY tokenY amount
     * @param useFullPrecision If false, liquidity will be maximized according to what the router can calculate,
     * not what core can theoretically support
     * @returns The position
     */
    static fromAmounts({ objectId, owner, pool, tickLower, tickUpper, amountX, amountY, useFullPrecision, }: {
        objectId?: string;
        owner: string;
        pool: ClmmPool;
        tickLower: number;
        tickUpper: number;
        amountX: BigintIsh;
        amountY: BigintIsh;
        useFullPrecision: boolean;
    }): ClmmPosition;
    /**
     * Computes a position with the maximum amount of liquidity received for a given amount of tokenX, assuming an unlimited amount of tokenY
     * @param objectId The object ID of the position, if it exists
     * @param owner The owner of the position
     * @param pool The pool for which the position is created
     * @param tickLower The lower tick
     * @param tickUpper The upper tick
     * @param amountX The desired amount of tokenX
     * @param useFullPrecision If true, liquidity will be maximized according to what the router can calculate,
     * not what core can theoretically support
     * @returns The position
     */
    static fromAmountX({ objectId, owner, pool, tickLower, tickUpper, amountX, useFullPrecision, }: {
        objectId?: string;
        owner: string;
        pool: ClmmPool;
        tickLower: number;
        tickUpper: number;
        amountX: BigintIsh;
        useFullPrecision: boolean;
    }): ClmmPosition;
    /**
     * Computes a position with the maximum amount of liquidity received for a given amount of tokenY, assuming an unlimited amount of tokenX
     * @param objectId The object ID of the position, if it exists
     * @param owner The owner of the position
     * @param pool The pool for which the position is created
     * @param tickLower The lower tick
     * @param tickUpper The upper tick
     * @param amountY The desired amount of tokenY
     * @param useFullPrecision If true, liquidity will be maximized according to what the router can calculate,
     * not what core can theoretically support
     * @returns The position
     */
    static fromAmountY({ objectId, owner, pool, tickLower, tickUpper, amountY, useFullPrecision, }: {
        objectId?: string;
        owner: string;
        pool: ClmmPool;
        tickLower: number;
        tickUpper: number;
        amountY: BigintIsh;
        useFullPrecision: boolean;
    }): ClmmPosition;
    /**
     * Returns the lower and upper sqrt ratios if the price 'slips' up to slippage tolerance percentage
     * @param slippageTolerance The amount by which the price can 'slip' before the transaction will revert
     * @returns The sqrt ratios after slippage
     */
    private ratiosAfterSlippage;
    /**
     * Returns the minimum amounts that must be sent in order to safely mint the amount of liquidity held by the position
     * with the given slippage tolerance
     * @param slippageTolerance Tolerance of unfavorable slippage from the current price
     * @returns The amounts, with slippage
     */
    mintAmountsWithSlippage(slippageTolerance: Percent): Readonly<{
        amountX: BN;
        amountY: BN;
    }>;
    burnAmountsWithSlippage(slippageTolerance: Percent): Readonly<{
        amountX: BN;
        amountY: BN;
    }>;
    getFees(): Promise<Readonly<{
        amountX: BN;
        amountY: BN;
    }>>;
    getRewards(): Promise<Readonly<BN[]>>;
    setFeeReward(rewards: CoinAmount<Coin>[]): void;
    setIncentiveReward(rewards: CoinAmount<Coin>[]): void;
}
export {};
