import { SuiClient } from "@mysten/sui/client";
import { AlphalendClient } from "../src/core/client.js";
import { performance } from "perf_hooks";

/**
 * Profiling script for getAllMarkets() function
 *
 * This script measures execution time at various stages to identify bottlenecks
 */

interface TimingResult {
  name: string;
  duration: number;
  startTime: number;
  endTime: number;
}

class Profiler {
  private timings: Map<string, { start: number; end?: number }> = new Map();
  private results: TimingResult[] = [];

  start(name: string) {
    const startTime = performance.now();
    this.timings.set(name, { start: startTime });
    console.log(`‚è±Ô∏è  [START] ${name}`);
  }

  end(name: string) {
    const timing = this.timings.get(name);
    if (!timing) {
      console.error(`‚ö†Ô∏è  No start time found for: ${name}`);
      return;
    }

    const endTime = performance.now();
    const duration = endTime - timing.start;
    timing.end = endTime;

    this.results.push({
      name,
      duration,
      startTime: timing.start,
      endTime,
    });

    console.log(`‚è±Ô∏è  [END] ${name} - ${duration.toFixed(2)}ms`);
  }

  async measure<T>(name: string, fn: () => Promise<T>): Promise<T> {
    this.start(name);
    try {
      const result = await fn();
      this.end(name);
      return result;
    } catch (error) {
      this.end(name);
      throw error;
    }
  }

  measureSync<T>(name: string, fn: () => T): T {
    this.start(name);
    try {
      const result = fn();
      this.end(name);
      return result;
    } catch (error) {
      this.end(name);
      throw error;
    }
  }

  printSummary() {
    console.log("\n" + "=".repeat(80));
    console.log("üìä PERFORMANCE SUMMARY");
    console.log("=".repeat(80));

    // Sort by duration descending
    const sorted = [...this.results].sort((a, b) => b.duration - a.duration);

    const totalDuration = this.results.reduce((sum, r) => sum + r.duration, 0);

    console.log("\nüêå Top 10 Slowest Operations:");
    sorted.slice(0, 10).forEach((result, index) => {
      const percentage = (result.duration / totalDuration) * 100;
      console.log(
        `${index + 1}. ${result.name.padEnd(50)} ${result.duration.toFixed(2)}ms (${percentage.toFixed(1)}%)`
      );
    });

    console.log("\nüìà All Operations (chronological):");
    this.results.forEach((result, index) => {
      const percentage = (result.duration / totalDuration) * 100;
      console.log(
        `${(index + 1).toString().padStart(3)}. ${result.name.padEnd(50)} ${result.duration.toFixed(2)}ms (${percentage.toFixed(1)}%)`
      );
    });

    console.log(`\n‚è±Ô∏è  Total Measured Time: ${totalDuration.toFixed(2)}ms`);
    console.log(`‚è±Ô∏è  Average per Operation: ${(totalDuration / this.results.length).toFixed(2)}ms`);
  }

  getResults(): TimingResult[] {
    return [...this.results];
  }
}

function getSuiClient(network: "mainnet" | "testnet" | "devnet" = "mainnet") {
  const rpcUrls = {
    mainnet: "https://fullnode.mainnet.sui.io/",
    testnet: "https://fullnode.testnet.sui.io/",
    devnet: "https://fullnode.devnet.sui.io/",
  };

  return new SuiClient({
    url: rpcUrls[network],
  });
}

async function profileGetAllMarkets() {
  const profiler = new Profiler();
  const scriptStart = performance.now();

  console.log("üîç Profiling getAllMarkets() function...\n");

  const network = "mainnet";

  console.log(`üì° Network: ${network}\n`);

  // Measure SuiClient creation
  const suiClient = profiler.measureSync(
    "1. Create SuiClient",
    () => getSuiClient(network)
  );

  // Measure AlphalendClient creation
  const alphalendClient = await profiler.measure(
    "2. Create AlphalendClient",
    async () => new AlphalendClient(network, suiClient)
  );

  // Measure getAllMarkets call
  const markets = await profiler.measure(
    "3. getAllMarkets() - TOTAL",
    async () => {
      // Let's also measure the internal initialization if it happens
      return await alphalendClient.getAllMarkets();
    }
  );

  if (!markets || markets.length === 0) {
    console.log("‚ùå No markets found");
    return;
  }

  console.log(`\n‚úÖ Successfully fetched ${markets.length} markets`);

  // Measure individual market data access
  console.log("\nüìä Profiling individual market access...");
  for (let i = 0; i < Math.min(5, markets.length); i++) {
    profiler.measureSync(
      `4. Access market ${i + 1} data`,
      () => {
        const m = markets[i];
        // Access various properties to see if there are computed getters
        return {
          id: m.marketId,
          type: m.coinType,
          supply: m.totalSupply,
          borrowed: m.totalBorrowed,
          price: m.price,
          apy: m.supplyApy,
        };
      }
    );
  }

  const scriptEnd = performance.now();
  const totalScriptTime = scriptEnd - scriptStart;

  // Print detailed summary
  profiler.printSummary();

  console.log("\n" + "=".repeat(80));
  console.log(`üèÅ Total Script Execution Time: ${totalScriptTime.toFixed(2)}ms`);
  console.log("=".repeat(80));
}

// Run with Node.js built-in profiler option
console.log("üí° TIP: For even more detailed profiling, run with:");
console.log("   node --prof $(which tsx) scripts/profileGetAllMarkets.ts");
console.log("   node --prof-process isolate-*.log > profile.txt\n");

profileGetAllMarkets()
  .then(() => {
    console.log("\n‚úÖ Profiling completed");
    process.exit(0);
  })
  .catch((error) => {
    console.error("\n‚ùå Profiling failed:", error);
    process.exit(1);
  });
