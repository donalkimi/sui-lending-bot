import { SuiClient } from "@mysten/sui/client";
import { AlphalendClient } from "../src/core/client.js";
import { performance } from "perf_hooks";

/**
 * Detailed profiling script with SuiClient RPC call instrumentation
 *
 * This wraps the SuiClient methods to measure individual RPC calls
 */

class InstrumentedSuiClient extends SuiClient {
  private callCount = new Map<string, number>();
  private callDurations = new Map<string, number[]>();

  async getDynamicFields(...args: Parameters<SuiClient["getDynamicFields"]>) {
    return this.measureCall("getDynamicFields", () =>
      super.getDynamicFields(...args)
    );
  }

  async multiGetObjects(...args: Parameters<SuiClient["multiGetObjects"]>) {
    return this.measureCall("multiGetObjects", () =>
      super.multiGetObjects(...args)
    );
  }

  async getObject(...args: Parameters<SuiClient["getObject"]>) {
    return this.measureCall("getObject", () => super.getObject(...args));
  }

  async queryTransactionBlocks(
    ...args: Parameters<SuiClient["queryTransactionBlocks"]>
  ) {
    return this.measureCall("queryTransactionBlocks", () =>
      super.queryTransactionBlocks(...args)
    );
  }

  async getCoins(...args: Parameters<SuiClient["getCoins"]>) {
    return this.measureCall("getCoins", () => super.getCoins(...args));
  }

  private async measureCall<T>(methodName: string, fn: () => Promise<T>): Promise<T> {
    const start = performance.now();
    const callNum = (this.callCount.get(methodName) || 0) + 1;
    this.callCount.set(methodName, callNum);

    console.log(`  üîµ [RPC ${callNum}] ${methodName} - START`);

    try {
      const result = await fn();
      const duration = performance.now() - start;

      const durations = this.callDurations.get(methodName) || [];
      durations.push(duration);
      this.callDurations.set(methodName, durations);

      console.log(
        `  ‚úÖ [RPC ${callNum}] ${methodName} - ${duration.toFixed(2)}ms`
      );

      return result;
    } catch (error) {
      const duration = performance.now() - start;
      console.log(
        `  ‚ùå [RPC ${callNum}] ${methodName} - FAILED after ${duration.toFixed(2)}ms`
      );
      throw error;
    }
  }

  printRpcStats() {
    console.log("\n" + "=".repeat(80));
    console.log("üåê RPC CALL STATISTICS");
    console.log("=".repeat(80));

    let totalCalls = 0;
    let totalDuration = 0;

    const stats: Array<{
      method: string;
      count: number;
      totalTime: number;
      avgTime: number;
      minTime: number;
      maxTime: number;
    }> = [];

    for (const [method, durations] of this.callDurations.entries()) {
      const count = durations.length;
      const total = durations.reduce((sum, d) => sum + d, 0);
      const avg = total / count;
      const min = Math.min(...durations);
      const max = Math.max(...durations);

      totalCalls += count;
      totalDuration += total;

      stats.push({
        method,
        count,
        totalTime: total,
        avgTime: avg,
        minTime: min,
        maxTime: max,
      });
    }

    // Sort by total time descending
    stats.sort((a, b) => b.totalTime - a.totalTime);

    console.log("\nüìä RPC Methods (sorted by total time):\n");
    stats.forEach((stat, index) => {
      const percentage = (stat.totalTime / totalDuration) * 100;
      console.log(`${index + 1}. ${stat.method}`);
      console.log(`   Calls:      ${stat.count}`);
      console.log(`   Total Time: ${stat.totalTime.toFixed(2)}ms (${percentage.toFixed(1)}%)`);
      console.log(`   Avg Time:   ${stat.avgTime.toFixed(2)}ms`);
      console.log(`   Min Time:   ${stat.minTime.toFixed(2)}ms`);
      console.log(`   Max Time:   ${stat.maxTime.toFixed(2)}ms`);
      console.log();
    });

    console.log(`üìà Summary:`);
    console.log(`   Total RPC Calls:    ${totalCalls}`);
    console.log(`   Total RPC Time:     ${totalDuration.toFixed(2)}ms`);
    console.log(`   Avg Time per Call:  ${(totalDuration / totalCalls).toFixed(2)}ms`);
  }
}

async function detailedProfile() {
  console.log("üîç Detailed Profiling of getAllMarkets()\n");
  console.log("This will track individual RPC calls to the Sui network\n");
  console.log("=".repeat(80) + "\n");

  const network = "mainnet";
  const scriptStart = performance.now();

  // Create instrumented client
  const rpcUrl = "https://fullnode.mainnet.sui.io/";
  const suiClient = new InstrumentedSuiClient({ url: rpcUrl });

  console.log(`üì° Network: ${network}`);
  console.log(`üì° RPC URL: ${rpcUrl}\n`);

  console.log("‚è±Ô∏è  [START] Creating AlphalendClient...");
  const clientStart = performance.now();
  const alphalendClient = new AlphalendClient(network, suiClient);
  const clientDuration = performance.now() - clientStart;
  console.log(`‚è±Ô∏è  [END] AlphalendClient created - ${clientDuration.toFixed(2)}ms\n`);

  console.log("‚è±Ô∏è  [START] Calling getAllMarkets()...\n");
  const getAllMarketsStart = performance.now();

  const markets = await alphalendClient.getAllMarkets();

  const getAllMarketsDuration = performance.now() - getAllMarketsStart;
  console.log(`\n‚è±Ô∏è  [END] getAllMarkets() completed - ${getAllMarketsDuration.toFixed(2)}ms\n`);

  if (!markets || markets.length === 0) {
    console.log("‚ùå No markets found");
    return;
  }

  console.log(`‚úÖ Successfully fetched ${markets.length} markets`);

  const scriptDuration = performance.now() - scriptStart;

  // Print RPC statistics
  suiClient.printRpcStats();

  console.log("\n" + "=".repeat(80));
  console.log("‚è±Ô∏è  OVERALL TIMING");
  console.log("=".repeat(80));
  console.log(`AlphalendClient creation:  ${clientDuration.toFixed(2)}ms`);
  console.log(`getAllMarkets() call:      ${getAllMarketsDuration.toFixed(2)}ms`);
  console.log(`Total script execution:    ${scriptDuration.toFixed(2)}ms`);

  // Analysis
  console.log("\n" + "=".repeat(80));
  console.log("üí° BOTTLENECK ANALYSIS");
  console.log("=".repeat(80));

  const rpcTime =
    Array.from(suiClient["callDurations"].values())
      .flat()
      .reduce((sum, d) => sum + d, 0);

  const nonRpcTime = getAllMarketsDuration - rpcTime;

  console.log(`Time spent in RPC calls:      ${rpcTime.toFixed(2)}ms (${((rpcTime / getAllMarketsDuration) * 100).toFixed(1)}%)`);
  console.log(`Time spent in SDK processing: ${nonRpcTime.toFixed(2)}ms (${((nonRpcTime / getAllMarketsDuration) * 100).toFixed(1)}%)`);

  if (rpcTime > getAllMarketsDuration * 0.8) {
    console.log("\n‚ö†Ô∏è  BOTTLENECK: Network RPC calls are the main bottleneck");
    console.log("üí° Suggestions:");
    console.log("   - Use a faster RPC endpoint (dedicated node, paid service)");
    console.log("   - Implement caching for market data");
    console.log("   - Consider batching or parallel requests where possible");
  } else {
    console.log("\n‚ö†Ô∏è  BOTTLENECK: SDK processing is significant");
    console.log("üí° Suggestions:");
    console.log("   - Optimize data parsing and transformation");
    console.log("   - Review computational complexity in SDK code");
  }
}

detailedProfile()
  .then(() => {
    console.log("\n‚úÖ Profiling completed");
    process.exit(0);
  })
  .catch((error) => {
    console.error("\n‚ùå Profiling failed:", error);
    console.error(error.stack);
    process.exit(1);
  });
