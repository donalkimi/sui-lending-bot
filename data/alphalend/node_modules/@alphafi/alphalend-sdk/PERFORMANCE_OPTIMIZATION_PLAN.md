# Performance Optimization Plan for getAllMarkets()

## Problem Summary
The SDK is spending significantly more time on local computation than on RPC calls. When profiling `getAllMarkets()`, the RPC time is minimal compared to SDK processing time.

## Root Causes Identified

### 1. Heavy Computation in Market.refresh()
**Location:** `src/models/market.ts:117-242`

The `refresh()` method performs CPU-intensive calculations for every market:
- **Compound Interest Calculation** (lines 124-177): Uses exponentiation by squaring with bigint operations
- **XToken Ratio Refresh** (lines 179-187): Calculates token ratios
- **Reward Distributors Refresh** (lines 189-242): Called twice, iterates through all rewards

**Impact:** For 18+ markets, this runs 18+ times with heavy mathematical operations.

### 2. HTTP Call for stSUI APR in Every Market
**Location:** `src/models/market.ts:406-413`

```typescript
const data = await httpCache.fetchWithCache<{ APR: number }>(
  "https://ws.stsui.com/api/variables",
);
```

**Issues:**
- First call requires HTTP round-trip (not cached yet)
- Even with caching, there's overhead in cache checking
- The check happens inside `calculateSupplyApr()` which is called for ALL markets
- Only ONE market (stSUI) actually needs this data

**Impact:** Adds latency to the entire `getAllMarkets()` call since all markets wait for this.

### 3. Extensive APR Calculations
**Location:** `src/models/market.ts:244-472`

For every market:
- `calculateSupplyRewardApr()` - iterates through all supply rewards
- `calculateBorrowRewardApr()` - iterates through all borrow rewards
- `calculateSupplyApr()` - includes HTTP call + calculations
- `calculateBorrowApr()` - interest rate interpolation

All using `Decimal.js` which is slower than native operations.

### 4. Sequential Execution in Promise.all
**Location:** `src/models/lendingProtocol.ts:72`

```typescript
return await Promise.all(markets.map((market) => market.getMarketData()));
```

While `Promise.all` runs in parallel, the stSUI HTTP call blocks progress since JavaScript promises don't truly parallelize CPU-bound work.

## Optimization Recommendations

### Priority 1: Optimize stSUI APR Fetching

**Option A: Fetch Once Before Processing Markets**
```typescript
// In lendingProtocol.ts
async getAllMarketsData(): Promise<MarketData[]> {
  const markets = await this.getAllMarkets();

  // Fetch stSUI APR once upfront
  let stsuiApr: number | null = null;
  const hasStSuiMarket = markets.some(m =>
    m.market.coinType === "0xd1b72982e40348d069bb1ff701e634c117bb5f741f44dff91e472d3b01461e55::stsui::STSUI"
  );

  if (hasStSuiMarket) {
    try {
      const data = await httpCache.fetchWithCache<{ APR: number }>(
        "https://ws.stsui.com/api/variables",
      );
      stsuiApr = data.APR;
    } catch (error) {
      console.error("Error fetching stSUI APR:", error);
    }
  }

  // Pass stsuiApr to each market
  return await Promise.all(
    markets.map((market) => market.getMarketData(stsuiApr))
  );
}
```

Then modify `Market.getMarketData()` to accept optional `stsuiApr`:
```typescript
async getMarketData(stsuiApr?: number | null): Promise<MarketData> {
  this.refresh();
  // ... existing code ...
  const supplyApr = await this.calculateSupplyApr(stsuiApr);
  // ...
}

async calculateSupplyApr(stsuiApr?: number | null): Promise<{...}> {
  // ... existing code ...

  let stakingApr = new Decimal(0);
  if (this.market.coinType === "0xd1b72982e40348d069bb1ff701e634c117bb5f741f44dff91e472d3b01461e55::stsui::STSUI") {
    if (stsuiApr !== null && stsuiApr !== undefined) {
      stakingApr = new Decimal(stsuiApr);
    } else {
      try {
        const data = await httpCache.fetchWithCache<{ APR: number }>(
          "https://ws.stsui.com/api/variables",
        );
        stakingApr = new Decimal(data.APR);
      } catch (error) {
        console.error("Error fetching stSUI APR:", error);
      }
    }
  }
  // ...
}
```

**Expected Impact:** Eliminates 17+ unnecessary HTTP calls/cache checks. Reduces latency by 50-200ms depending on cache state.

**Option B: Make stSUI APR Fetch Non-Blocking**
Make the HTTP call not block other market calculations:
```typescript
async getMarketData(): Promise<MarketData> {
  this.refresh();

  // Start stSUI fetch early but don't await yet
  const stsuiAprPromise = this.market.coinType === STSUI_COIN_TYPE
    ? httpCache.fetchWithCache<{ APR: number }>("https://ws.stsui.com/api/variables")
    : Promise.resolve(null);

  // Do other calculations
  const borrowApr = this.calculateBorrowApr();
  borrowApr.rewards = this.calculateBorrowRewardApr();

  // Now await stSUI if needed
  const stsuiData = await stsuiAprPromise;
  const supplyApr = await this.calculateSupplyApr(stsuiData?.APR);
  // ...
}
```

### Priority 2: Optimize refresh() Calculations

**Option A: Lazy Refresh (Only When Needed)**
```typescript
async getMarketData(options?: { skipRefresh?: boolean }): Promise<MarketData> {
  if (!options?.skipRefresh) {
    this.refresh();
  }
  // ...
}
```

For display purposes, you might not need real-time interest accrual. The frontend could refresh less frequently.

**Option B: Optimize refreshCompoundInterest() Algorithm**
The current implementation uses exponentiation by squaring for every market. Consider:
- Caching results for short time periods
- Using approximations for display purposes
- Only doing full calculations when precision is critical (e.g., transactions)

**Option C: Move Heavy Calculations to Web Workers (Advanced)**
For browser environments, offload CPU-intensive work to Web Workers.

### Priority 3: Optimize Decimal.js Usage

**Consider using native numbers where precision isn't critical:**
```typescript
// Instead of:
const result = new Decimal(value).mul(price).div(1000);

// Use:
const result = (value * price) / 1000;
```

Reserve `Decimal.js` for:
- Final user-facing calculations
- Financial computations requiring exact precision

For intermediate calculations and display APRs, native numbers are sufficient.

### Priority 4: Add Caching Layer for Market Data

**Implement time-based caching at the client level:**
```typescript
// In client.ts
async getAllMarkets(options?: {
  useCache?: boolean;
  cacheTTL?: number;
}): Promise<MarketData[] | undefined> {
  const useCache = options?.useCache ?? true; // Enable by default
  const cacheTTL = options?.cacheTTL ?? 30000; // 30 seconds default

  return await blockchainCache.getOrFetch(
    "markets:all",
    async () => {
      const markets = await this.lendingProtocol.getAllMarketsData();
      return markets;
    },
    {
      skipCache: !useCache,
      ttl: cacheTTL,
    },
  );
}
```

**Expected Impact:** Eliminates repeated calculations when data doesn't change frequently. Reduces API calls.

## Implementation Priority

1. **IMMEDIATE (Priority 1):** Fix stSUI APR fetching - Biggest impact, easiest fix
2. **SHORT-TERM (Priority 2 & 4):** Add caching, optimize refresh logic
3. **LONG-TERM (Priority 3):** Refactor Decimal.js usage, consider worker threads

## Expected Performance Improvements

| Optimization | Expected Time Savings | Difficulty |
|--------------|----------------------|------------|
| stSUI APR fix | 50-200ms | Low |
| Market data caching | 80-95% (on cache hits) | Low |
| Optimize refresh() | 100-300ms | Medium |
| Optimize Decimal.js | 50-150ms | Medium |
| **Total** | **200-650ms per call** | - |

## Testing Recommendations

1. Run `scripts/detailedProfile.ts` before and after each optimization
2. Monitor RPC time vs SDK processing time ratio
3. Test with different market counts
4. Profile with and without cache hits
5. Measure end-to-end latency in production scenarios

## Next Steps

1. Implement Priority 1 fix (stSUI APR)
2. Run profiling script to measure improvement
3. Add market data caching with configurable TTL
4. Profile again and iterate
