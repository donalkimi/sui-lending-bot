import { SuiClient } from "@mysten/sui/client";
import { AlphalendClient } from "../src/core/client.js";
import { performance } from "perf_hooks";

/**
 * Deep profiling script that hooks into fetch to track GraphQL API calls
 */

// Store original fetch
const originalFetch = global.fetch;

interface FetchCall {
  url: string;
  method: string;
  duration: number;
  timestamp: number;
}

const fetchCalls: FetchCall[] = [];

// Monkey-patch fetch to track all network calls
global.fetch = async function (input: RequestInfo | URL, init?: RequestInit): Promise<Response> {
  const url = typeof input === "string" ? input : input instanceof URL ? input.toString() : input.url;
  const method = init?.method || "GET";
  const start = performance.now();

  console.log(`  üåê [FETCH] ${method} ${url} - START`);

  try {
    const response = await originalFetch(input, init);
    const duration = performance.now() - start;

    fetchCalls.push({
      url,
      method,
      duration,
      timestamp: start,
    });

    console.log(`  ‚úÖ [FETCH] ${method} ${url} - ${duration.toFixed(2)}ms`);

    return response;
  } catch (error) {
    const duration = performance.now() - start;
    console.log(`  ‚ùå [FETCH] ${method} ${url} - FAILED after ${duration.toFixed(2)}ms`);
    throw error;
  }
} as typeof fetch;

class DetailedProfiler {
  private timings: Map<string, number> = new Map();

  start(name: string): number {
    const start = performance.now();
    console.log(`\n‚è±Ô∏è  [START] ${name}`);
    return start;
  }

  end(name: string, start: number) {
    const duration = performance.now() - start;
    this.timings.set(name, duration);
    console.log(`‚è±Ô∏è  [END] ${name} - ${duration.toFixed(2)}ms`);
    return duration;
  }

  printSummary() {
    console.log("\n" + "=".repeat(80));
    console.log("üìä DETAILED TIMING BREAKDOWN");
    console.log("=".repeat(80));

    const entries = Array.from(this.timings.entries()).sort((a, b) => b[1] - a[1]);

    entries.forEach(([name, duration], index) => {
      console.log(`${index + 1}. ${name.padEnd(60)} ${duration.toFixed(2)}ms`);
    });

    console.log("\n" + "=".repeat(80));
    console.log("üåê FETCH/NETWORK CALLS SUMMARY");
    console.log("=".repeat(80));

    if (fetchCalls.length === 0) {
      console.log("No fetch calls detected");
    } else {
      const totalFetchTime = fetchCalls.reduce((sum, call) => sum + call.duration, 0);

      // Group by URL pattern
      const groupedByUrl = new Map<string, { count: number; totalTime: number; calls: FetchCall[] }>();

      fetchCalls.forEach((call) => {
        // Simplify URL for grouping
        let urlKey = call.url;
        if (urlKey.includes("fullnode")) {
          urlKey = "Sui RPC";
        } else if (urlKey.includes("api.alphalend")) {
          urlKey = "AlphaLend GraphQL API";
        } else if (urlKey.includes("hermes.pyth")) {
          urlKey = "Pyth Price Feed";
        }

        const existing = groupedByUrl.get(urlKey) || { count: 0, totalTime: 0, calls: [] };
        existing.count++;
        existing.totalTime += call.duration;
        existing.calls.push(call);
        groupedByUrl.set(urlKey, existing);
      });

      console.log("\nüìä Network Calls by Destination:\n");
      Array.from(groupedByUrl.entries())
        .sort((a, b) => b[1].totalTime - a[1].totalTime)
        .forEach(([url, stats]) => {
          const percentage = (stats.totalTime / totalFetchTime) * 100;
          console.log(`${url}`);
          console.log(`   Count:      ${stats.count}`);
          console.log(`   Total Time: ${stats.totalTime.toFixed(2)}ms (${percentage.toFixed(1)}%)`);
          console.log(`   Avg Time:   ${(stats.totalTime / stats.count).toFixed(2)}ms`);
          console.log();
        });

      console.log(`üìà Total Network Time: ${totalFetchTime.toFixed(2)}ms`);
      console.log(`üìà Total Fetch Calls: ${fetchCalls.length}`);
    }
  }
}

async function deepProfile() {
  const profiler = new DetailedProfiler();

  console.log("üîç Deep Profiling of getAllMarkets() - Tracking ALL network calls\n");
  console.log("=".repeat(80) + "\n");

  const scriptStart = profiler.start("Total Script Execution");

  // Create client
  const network = "mainnet";
  const suiClient = new SuiClient({ url: "https://fullnode.mainnet.sui.io/" });

  const clientStart = profiler.start("AlphalendClient Construction");
  const alphalendClient = new AlphalendClient(network, suiClient);
  profiler.end("AlphalendClient Construction", clientStart);

  const getAllMarketsStart = profiler.start("getAllMarkets() Call");
  const markets = await alphalendClient.getAllMarkets();
  profiler.end("getAllMarkets() Call", getAllMarketsStart);

  profiler.end("Total Script Execution", scriptStart);

  if (!markets || markets.length === 0) {
    console.log("\n‚ùå No markets found");
    return;
  }

  console.log(`\n‚úÖ Successfully fetched ${markets.length} markets`);

  profiler.printSummary();

  // Calculate overhead
  const totalScriptTime = profiler["timings"].get("Total Script Execution") || 0;
  const networkTime = fetchCalls.reduce((sum, call) => sum + call.duration, 0);
  const overhead = totalScriptTime - networkTime;

  console.log("\n" + "=".repeat(80));
  console.log("üí° PERFORMANCE BREAKDOWN");
  console.log("=".repeat(80));
  console.log(`Total Time:        ${totalScriptTime.toFixed(2)}ms`);
  console.log(`Network I/O:       ${networkTime.toFixed(2)}ms (${((networkTime / totalScriptTime) * 100).toFixed(1)}%)`);
  console.log(`CPU/Processing:    ${overhead.toFixed(2)}ms (${((overhead / totalScriptTime) * 100).toFixed(1)}%)`);

  if (networkTime > totalScriptTime * 0.7) {
    console.log("\n‚ö†Ô∏è  BOTTLENECK: Network I/O");
    console.log("üí° Optimization strategies:");
    console.log("   1. Use a faster RPC provider (e.g., dedicated node, commercial provider)");
    console.log("   2. Implement aggressive caching of market data");
    console.log("   3. Use WebSocket subscriptions for real-time updates");
    console.log("   4. Consider running your own Sui full node");
  } else {
    console.log("\n‚ö†Ô∏è  BOTTLENECK: CPU Processing / Parsing");
    console.log("üí° Optimization strategies:");
    console.log("   1. Profile the SDK parsing/transformation code");
    console.log("   2. Look for redundant computations or data transformations");
    console.log("   3. Consider lazy evaluation for expensive operations");
    console.log("   4. Use V8 profiler: node --prof");
  }
}

deepProfile()
  .then(() => {
    console.log("\n‚úÖ Deep profiling completed");
    process.exit(0);
  })
  .catch((error) => {
    console.error("\n‚ùå Deep profiling failed:", error);
    console.error(error.stack);
    process.exit(1);
  });
