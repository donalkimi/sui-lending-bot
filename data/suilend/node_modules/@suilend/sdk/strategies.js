"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.strategyAdjustTx = exports.strategyDepositAdjustWithdrawTx = exports.strategyAdjustRepayTx = exports.strategyMaxWithdrawTx = exports.strategyWithdrawTx = exports.strategyDepositAndLoopToExposureTx = exports.strategyDepositTx = exports.strategyUnloopToExposureTx = exports.strategyLoopToExposureTx = exports.getStrategyLiquidationPrice = exports.getStrategyHealthPercent = exports.getStrategyAprPercent = exports.getStrategyUnclaimedRewardsAmount = exports.fetchStrategyGlobalTvlAmountUsdMap = exports.strategySimulateDepositAndLoopToExposure = exports.strategySimulateDeposit = exports.strategySimulateLoopToExposure = exports.getStrategyStepMaxWithdrawnAmount = exports.getStrategyStepMaxBorrowedAmount = exports.getStrategyExposure = exports.getStrategyTvlAmount = exports.getStrategyBorrowedAmount = exports.getStrategyDepositedAmount = exports.getStrategySimulatedObligation = exports.getStrategyDefaultCurrencyReserve = exports.getStrategyBorrowReserve = exports.getStrategyDepositReserves = exports.STRATEGY_TYPE_EXPOSURE_MAP = exports.getStrategyLstRedeemFee = exports.getStrategyLstMintFee = exports.fetchStrategyLstMap = exports.getStrategySuiReserve = exports.hasStrategyPosition = exports.addOrInsertStrategyDeposit = exports.getReserveSafeDepositLimit = exports.STRATEGY_TYPE_FLASH_LOAN_OBJ_MAP = exports.StrategyFlashLoanProvider = exports.LST_DECIMALS = exports.STRATEGY_E = void 0;
const bcs_1 = require("@mysten/bcs");
const transactions_1 = require("@mysten/sui/transactions");
const utils_1 = require("@mysten/sui/utils");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const bn_js_1 = require("bn.js");
const lodash_1 = require("lodash");
const springsui_sdk_1 = require("@suilend/springsui-sdk");
const sui_fe_1 = require("@suilend/sui-fe");
const lib_1 = require("./lib");
const liquidityMining_1 = require("./lib/liquidityMining");
const strategyOwnerCap_1 = require("./lib/strategyOwnerCap");
const mmt_1 = require("./mmt");
const utils_2 = require("./utils");
exports.STRATEGY_E = 10 ** -7;
exports.LST_DECIMALS = 9;
var StrategyFlashLoanProvider;
(function (StrategyFlashLoanProvider) {
    StrategyFlashLoanProvider["MMT"] = "mmt";
})(StrategyFlashLoanProvider || (exports.StrategyFlashLoanProvider = StrategyFlashLoanProvider = {}));
exports.STRATEGY_TYPE_FLASH_LOAN_OBJ_MAP = {
    [strategyOwnerCap_1.StrategyType.sSUI_SUI_LOOPING]: {
        provider: StrategyFlashLoanProvider.MMT,
        poolId: "0x9c92c5b8e9d83e485fb4c86804ac8b920bb0beaace5e61a5b0239218f627f8e9", // xSUI-SUI 0.01% https://app.mmt.finance/liquidity/0x9c92c5b8e9d83e485fb4c86804ac8b920bb0beaace5e61a5b0239218f627f8e9
        coinTypeA: "0x2b6602099970374cf58a2a1b9d96f005fccceb81e92eb059873baf420eb6c717::x_sui::X_SUI",
        coinTypeB: sui_fe_1.NORMALIZED_SUI_COINTYPE,
        borrowA: false,
        feePercent: 0.01,
    },
    [strategyOwnerCap_1.StrategyType.stratSUI_SUI_LOOPING]: {
        provider: StrategyFlashLoanProvider.MMT,
        poolId: "0x9c92c5b8e9d83e485fb4c86804ac8b920bb0beaace5e61a5b0239218f627f8e9", // xSUI-SUI 0.01% https://app.mmt.finance/liquidity/0x9c92c5b8e9d83e485fb4c86804ac8b920bb0beaace5e61a5b0239218f627f8e9
        coinTypeA: "0x2b6602099970374cf58a2a1b9d96f005fccceb81e92eb059873baf420eb6c717::x_sui::X_SUI",
        coinTypeB: sui_fe_1.NORMALIZED_SUI_COINTYPE,
        borrowA: false,
        feePercent: 0.01,
    },
    [strategyOwnerCap_1.StrategyType.USDC_sSUI_SUI_LOOPING]: {
        provider: StrategyFlashLoanProvider.MMT,
        poolId: "0x737ec6a4d3ed0c7e6cc18d8ba04e7ffd4806b726c97efd89867597368c4d06a9", // suiUSDT-USDC 0.001% https://app.mmt.finance/liquidity/0x737ec6a4d3ed0c7e6cc18d8ba04e7ffd4806b726c97efd89867597368c4d06a9
        coinTypeA: sui_fe_1.NORMALIZED_suiUSDT_COINTYPE,
        coinTypeB: sui_fe_1.NORMALIZED_USDC_COINTYPE,
        borrowA: false,
        feePercent: 0.001,
    },
    [strategyOwnerCap_1.StrategyType.AUSD_sSUI_SUI_LOOPING]: {
        provider: StrategyFlashLoanProvider.MMT,
        poolId: "0x900f25b27d2b1686886277d763223988d802f3b6152d02872c382d4dce05e25b", // AUSD-USDC 0.01% https://app.mmt.finance/liquidity/0x900f25b27d2b1686886277d763223988d802f3b6152d02872c382d4dce05e25b
        coinTypeA: sui_fe_1.NORMALIZED_AUSD_COINTYPE,
        coinTypeB: sui_fe_1.NORMALIZED_USDC_COINTYPE,
        borrowA: true,
        feePercent: 0.01,
    },
    [strategyOwnerCap_1.StrategyType.xBTC_sSUI_SUI_LOOPING]: {
        provider: StrategyFlashLoanProvider.MMT,
        poolId: "0x57a662791cea065610455797dfd2751a3c10d929455d3ea88154a2b40cf6614e", // xBTC-suiWBTC 0.01% https://app.mmt.finance/liquidity/0x57a662791cea065610455797dfd2751a3c10d929455d3ea88154a2b40cf6614e
        coinTypeA: sui_fe_1.NORMALIZED_xBTC_COINTYPE,
        coinTypeB: sui_fe_1.NORMALIZED_suiWBTC_COINTYPE,
        borrowA: true,
        feePercent: 0.01,
    },
    [strategyOwnerCap_1.StrategyType.xBTC_suiWBTC_LOOPING]: {
        provider: StrategyFlashLoanProvider.MMT,
        poolId: "0x57a662791cea065610455797dfd2751a3c10d929455d3ea88154a2b40cf6614e", // xBTC-suiWBTC 0.01% https://app.mmt.finance/liquidity/0x57a662791cea065610455797dfd2751a3c10d929455d3ea88154a2b40cf6614e
        coinTypeA: sui_fe_1.NORMALIZED_xBTC_COINTYPE,
        coinTypeB: sui_fe_1.NORMALIZED_suiWBTC_COINTYPE,
        borrowA: true,
        feePercent: 0.01,
    },
    [strategyOwnerCap_1.StrategyType.suiUSDT_sSUI_SUI_LOOPING]: {
        provider: StrategyFlashLoanProvider.MMT,
        poolId: "0x737ec6a4d3ed0c7e6cc18d8ba04e7ffd4806b726c97efd89867597368c4d06a9", // suiUSDT-USDC 0.001% https://app.mmt.finance/liquidity/0x737ec6a4d3ed0c7e6cc18d8ba04e7ffd4806b726c97efd89867597368c4d06a9
        coinTypeA: sui_fe_1.NORMALIZED_suiUSDT_COINTYPE,
        coinTypeB: sui_fe_1.NORMALIZED_USDC_COINTYPE,
        borrowA: true,
        feePercent: 0.001,
    },
    [strategyOwnerCap_1.StrategyType.AUSD_USDC_LOOPING]: {
        provider: StrategyFlashLoanProvider.MMT,
        poolId: "0x900f25b27d2b1686886277d763223988d802f3b6152d02872c382d4dce05e25b", // AUSD-USDC 0.01% https://app.mmt.finance/liquidity/0x900f25b27d2b1686886277d763223988d802f3b6152d02872c382d4dce05e25b
        coinTypeA: sui_fe_1.NORMALIZED_AUSD_COINTYPE,
        coinTypeB: sui_fe_1.NORMALIZED_USDC_COINTYPE,
        borrowA: true,
        feePercent: 0.01,
    },
    [strategyOwnerCap_1.StrategyType.AUSD_suiUSDT_LOOPING]: {
        provider: StrategyFlashLoanProvider.MMT,
        poolId: "0x900f25b27d2b1686886277d763223988d802f3b6152d02872c382d4dce05e25b", // AUSD-USDC 0.01% https://app.mmt.finance/liquidity/0x900f25b27d2b1686886277d763223988d802f3b6152d02872c382d4dce05e25b
        coinTypeA: sui_fe_1.NORMALIZED_AUSD_COINTYPE,
        coinTypeB: sui_fe_1.NORMALIZED_USDC_COINTYPE,
        borrowA: true,
        feePercent: 0.01,
    },
    [strategyOwnerCap_1.StrategyType.USDC_suiUSDT_LOOPING]: {
        provider: StrategyFlashLoanProvider.MMT,
        poolId: "0x737ec6a4d3ed0c7e6cc18d8ba04e7ffd4806b726c97efd89867597368c4d06a9", // suiUSDT-USDC 0.001% https://app.mmt.finance/liquidity/0x737ec6a4d3ed0c7e6cc18d8ba04e7ffd4806b726c97efd89867597368c4d06a9
        coinTypeA: sui_fe_1.NORMALIZED_suiUSDT_COINTYPE,
        coinTypeB: sui_fe_1.NORMALIZED_USDC_COINTYPE,
        borrowA: false,
        feePercent: 0.001,
    },
};
const getReserveSafeDepositLimit = (reserve) => {
    // Calculate safe deposit limit (subtract 10 mins of deposit APR from cap)
    const tenMinsDepositAprPercent = reserve.depositAprPercent
        .div(sui_fe_1.MS_PER_YEAR)
        .times(10 * 60 * 1000);
    const safeDepositLimit = reserve.config.depositLimit.minus(reserve.depositedAmount.times(tenMinsDepositAprPercent.div(100)));
    const safeDepositLimitUsd = reserve.config.depositLimitUsd.minus(reserve.depositedAmount
        .times(reserve.maxPrice)
        .times(tenMinsDepositAprPercent.div(100)));
    return { safeDepositLimit, safeDepositLimitUsd };
};
exports.getReserveSafeDepositLimit = getReserveSafeDepositLimit;
const addOrInsertStrategyDeposit = (_deposits, deposit) => {
    const deposits = (0, lodash_1.cloneDeep)(_deposits);
    const existingDeposit = deposits.find((d) => d.coinType === deposit.coinType);
    if (existingDeposit)
        existingDeposit.depositedAmount = existingDeposit.depositedAmount.plus(deposit.depositedAmount);
    else
        deposits.push(deposit);
    return deposits;
};
exports.addOrInsertStrategyDeposit = addOrInsertStrategyDeposit;
// Obligations
const hasStrategyPosition = (obligation) => obligation.deposits.length > 0;
exports.hasStrategyPosition = hasStrategyPosition;
// SUI
const getStrategySuiReserve = (
// AppContext
reserveMap) => reserveMap[sui_fe_1.NORMALIZED_SUI_COINTYPE];
exports.getStrategySuiReserve = getStrategySuiReserve;
const fetchStrategyLstMap = (suiClient) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const lstCoinTypes = Array.from(new Set([
            ...Object.values(strategyOwnerCap_1.STRATEGY_TYPE_INFO_MAP)
                .map(({ depositLstCoinType }) => depositLstCoinType)
                .filter(Boolean),
            // LSTs that will be/are/have been used as rewards
            sui_fe_1.NORMALIZED_sSUI_COINTYPE,
        ]));
        const publishedAt = yield (0, springsui_sdk_1.getLatestPackageId)(suiClient, springsui_sdk_1.SPRING_SUI_UPGRADE_CAP_ID);
        const lstInfoUrl = `${sui_fe_1.API_URL}/springsui/lst-info?${new URLSearchParams({
            coinTypes: lstCoinTypes.join(","),
        })}`;
        const lstInfoRes = yield fetch(lstInfoUrl);
        const lstInfoJson = yield lstInfoRes.json();
        if ((lstInfoRes === null || lstInfoRes === void 0 ? void 0 : lstInfoRes.statusCode) === 500)
            throw new Error("Failed to fetch LST info");
        const lstInfoMap = Object.fromEntries(Object.entries(lstInfoJson).map(([lstCoinType, lstInfo]) => {
            return [lstCoinType, lstInfo];
        }));
        const result = Object.fromEntries(yield Promise.all(lstCoinTypes.map((lstCoinType) => __awaiter(void 0, void 0, void 0, function* () {
            var _a, _b, _c, _d;
            const lstInfo = lstInfoMap[lstCoinType];
            const lstClient = yield springsui_sdk_1.LstClient.initialize(suiClient, lstInfo.LIQUID_STAKING_INFO, publishedAt);
            const mintFeePercent = new bignumber_js_1.default((_b = (_a = lstInfo.liquidStakingInfo.feeConfig.element) === null || _a === void 0 ? void 0 : _a.suiMintFeeBps.toString()) !== null && _b !== void 0 ? _b : 0).div(100);
            const redeemFeePercent = new bignumber_js_1.default((_d = (_c = lstInfo.liquidStakingInfo.feeConfig.element) === null || _c === void 0 ? void 0 : _c.redeemFeeBps.toString()) !== null && _d !== void 0 ? _d : 0).div(100);
            const res = yield fetch(`${sui_fe_1.API_URL}/springsui/historical-rates?coinType=${lstCoinType}&timestamps=${Math.floor(Date.now() / 1000)}`);
            const json = yield res.json();
            if ((json === null || json === void 0 ? void 0 : json.statusCode) === 500)
                throw new Error(`Failed to fetch historical LST to SUI exchange rates for ${lstCoinType}`);
            const suiToLstExchangeRate = !new bignumber_js_1.default(json[0].value).eq(0)
                ? new bignumber_js_1.default(1).div(new bignumber_js_1.default(json[0].value))
                : new bignumber_js_1.default(1);
            const lstToSuiExchangeRate = new bignumber_js_1.default(json[0].value);
            return [
                lstCoinType,
                {
                    client: lstClient,
                    liquidStakingInfo: lstInfo.liquidStakingInfo,
                    mintFeePercent,
                    redeemFeePercent,
                    suiToLstExchangeRate,
                    lstToSuiExchangeRate,
                },
            ];
        }))));
        return result;
    }
    catch (err) {
        console.error(err);
    }
});
exports.fetchStrategyLstMap = fetchStrategyLstMap;
const getStrategyLstMintFee = (
// Strategy
lstMap, lstCoinType, suiAmount) => {
    var _a, _b;
    const mintFeePercent = (_b = (_a = lstMap === null || lstMap === void 0 ? void 0 : lstMap[lstCoinType]) === null || _a === void 0 ? void 0 : _a.mintFeePercent) !== null && _b !== void 0 ? _b : new bignumber_js_1.default(0);
    return suiAmount
        .times(mintFeePercent.div(100))
        .decimalPlaces(utils_1.SUI_DECIMALS, bignumber_js_1.default.ROUND_UP);
};
exports.getStrategyLstMintFee = getStrategyLstMintFee;
const getStrategyLstRedeemFee = (
// Strategy
lstMap, lstCoinType, lstAmount) => {
    var _a, _b, _c, _d;
    const lstToSuiExchangeRate = (_b = (_a = lstMap === null || lstMap === void 0 ? void 0 : lstMap[lstCoinType]) === null || _a === void 0 ? void 0 : _a.lstToSuiExchangeRate) !== null && _b !== void 0 ? _b : new bignumber_js_1.default(1);
    const redeemFeePercent = (_d = (_c = lstMap === null || lstMap === void 0 ? void 0 : lstMap[lstCoinType]) === null || _c === void 0 ? void 0 : _c.redeemFeePercent) !== null && _d !== void 0 ? _d : new bignumber_js_1.default(0);
    const suiAmount = lstAmount.times(lstToSuiExchangeRate);
    return suiAmount
        .times(redeemFeePercent.div(100))
        .decimalPlaces(utils_1.SUI_DECIMALS, bignumber_js_1.default.ROUND_UP);
};
exports.getStrategyLstRedeemFee = getStrategyLstRedeemFee;
// Exposure map
exports.STRATEGY_TYPE_EXPOSURE_MAP = {
    [strategyOwnerCap_1.StrategyType.sSUI_SUI_LOOPING]: {
        min: new bignumber_js_1.default(1),
        max: new bignumber_js_1.default(3), // Actual max: 1 / (1 - (sSUI Open LTV %)) = 3.333x, where sSUI Open LTV % = 70%
        default: new bignumber_js_1.default(3),
    },
    [strategyOwnerCap_1.StrategyType.stratSUI_SUI_LOOPING]: {
        min: new bignumber_js_1.default(1),
        max: new bignumber_js_1.default(3), // Actual max: 1 / (1 - (sSUI Open LTV %)) = 3.333x, where sSUI Open LTV % = 70%
        default: new bignumber_js_1.default(3),
    },
    [strategyOwnerCap_1.StrategyType.USDC_sSUI_SUI_LOOPING]: {
        min: new bignumber_js_1.default(1),
        max: new bignumber_js_1.default(3), // Actual max: 1 + (USDC Open LTV %) * (1 / (1 - (sSUI Open LTV %))) = 3.5666x, where USDC Open LTV % = 77% and sSUI Open LTV % = 70%
        default: new bignumber_js_1.default(3),
    },
    [strategyOwnerCap_1.StrategyType.AUSD_sSUI_SUI_LOOPING]: {
        min: new bignumber_js_1.default(1),
        max: new bignumber_js_1.default(3), // Actual max: 1 + (AUSD Open LTV %) * (1 / (1 - (sSUI Open LTV %))) = 3.5666x, where AUSD Open LTV % = 77% and sSUI Open LTV % = 70%
        default: new bignumber_js_1.default(3),
    },
    [strategyOwnerCap_1.StrategyType.xBTC_sSUI_SUI_LOOPING]: {
        min: new bignumber_js_1.default(1),
        max: new bignumber_js_1.default(2.5), // Actual max: 1 + (xBTC Open LTV %) * (1 / (1 - (sSUI Open LTV %))) = 3x, where xBTC Open LTV % = 60% and sSUI Open LTV % = 70%
        default: new bignumber_js_1.default(2.5),
    },
    [strategyOwnerCap_1.StrategyType.xBTC_suiWBTC_LOOPING]: {
        min: new bignumber_js_1.default(1),
        max: new bignumber_js_1.default(2.2), // Actual max: 1 / (1 - (xBTC Open LTV %)) = 2.5x, where xBTC Open LTV % = 60%
        default: new bignumber_js_1.default(2.2),
    },
    [strategyOwnerCap_1.StrategyType.suiUSDT_sSUI_SUI_LOOPING]: {
        min: new bignumber_js_1.default(1),
        max: new bignumber_js_1.default(3), // Actual max: 1 + (suiUSDT Open LTV %) * (1 / (1 - (sSUI Open LTV %))) = 3.5666x, where suiUSDT Open LTV % = 77% and sSUI Open LTV % = 70%
        default: new bignumber_js_1.default(3),
    },
    [strategyOwnerCap_1.StrategyType.AUSD_USDC_LOOPING]: {
        min: new bignumber_js_1.default(1),
        max: new bignumber_js_1.default(4), // Actual max: 1 / (1 - (AUSD Open LTV %)) = 4.347x, where AUSD Open LTV % = 77%
        default: new bignumber_js_1.default(4),
    },
    [strategyOwnerCap_1.StrategyType.AUSD_suiUSDT_LOOPING]: {
        min: new bignumber_js_1.default(1),
        max: new bignumber_js_1.default(4), // Actual max: 1 / (1 - (AUSD Open LTV %)) = 4.347x, where AUSD Open LTV % = 77%
        default: new bignumber_js_1.default(4),
    },
    [strategyOwnerCap_1.StrategyType.USDC_suiUSDT_LOOPING]: {
        min: new bignumber_js_1.default(1),
        max: new bignumber_js_1.default(4), // Actual max: 1 / (1 - (USDC Open LTV %)) = 4.347x, where USDC Open LTV % = 77%
        default: new bignumber_js_1.default(4),
    },
};
// Reserves
const getStrategyDepositReserves = (
// AppContext
reserveMap, 
// Strategy
strategyType) => {
    const strategyTypeInfo = strategyOwnerCap_1.STRATEGY_TYPE_INFO_MAP[strategyType];
    return {
        base: strategyTypeInfo.depositBaseCoinType
            ? reserveMap[strategyTypeInfo.depositBaseCoinType]
            : undefined,
        lst: strategyTypeInfo.depositLstCoinType
            ? reserveMap[strategyTypeInfo.depositLstCoinType]
            : undefined,
    };
};
exports.getStrategyDepositReserves = getStrategyDepositReserves;
const getStrategyBorrowReserve = (
// AppContext
reserveMap, 
// Strategy
strategyType) => {
    const strategyTypeInfo = strategyOwnerCap_1.STRATEGY_TYPE_INFO_MAP[strategyType];
    return reserveMap[strategyTypeInfo.borrowCoinType];
};
exports.getStrategyBorrowReserve = getStrategyBorrowReserve;
const getStrategyDefaultCurrencyReserve = (
// AppContext
reserveMap, 
// Strategy
strategyType) => {
    const defaultCurrencyCoinType = strategyOwnerCap_1.STRATEGY_TYPE_INFO_MAP[strategyType].defaultCurrencyCoinType;
    return reserveMap[defaultCurrencyCoinType];
};
exports.getStrategyDefaultCurrencyReserve = getStrategyDefaultCurrencyReserve;
// Calculations
const getStrategySimulatedObligation = (
// AppContext
reserveMap, 
// Strategy
lstMap, strategyType, deposits, _borrowedAmount) => {
    const depositReserves = (0, exports.getStrategyDepositReserves)(reserveMap, strategyType);
    const borrowReserve = (0, exports.getStrategyBorrowReserve)(reserveMap, strategyType);
    const defaultCurrencyReserve = (0, exports.getStrategyDefaultCurrencyReserve)(reserveMap, strategyType);
    //
    const borrowedAmount = bignumber_js_1.default.max(new bignumber_js_1.default(0), _borrowedAmount); // Can't be negative
    const obligation = {
        deposits: deposits.reduce((acc, deposit) => {
            const depositReserve = reserveMap[deposit.coinType];
            return [
                ...acc,
                {
                    depositedAmount: deposit.depositedAmount,
                    depositedAmountUsd: deposit.depositedAmount.times(depositReserve.price),
                    reserve: depositReserve,
                    coinType: depositReserve.coinType,
                },
            ];
        }, []),
        borrows: [
            {
                borrowedAmount: borrowedAmount,
                borrowedAmountUsd: borrowedAmount.times(borrowReserve.price),
                reserve: borrowReserve,
                coinType: borrowReserve.coinType,
            },
        ],
        netValueUsd: deposits
            .reduce((acc, deposit) => {
            const depositReserve = reserveMap[deposit.coinType];
            return acc.plus(deposit.depositedAmount.times(depositReserve.price));
        }, new bignumber_js_1.default(0))
            .minus(borrowedAmount.times(borrowReserve.price)),
        weightedBorrowsUsd: new bignumber_js_1.default(borrowedAmount.times(borrowReserve.price)).times(borrowReserve.config.borrowWeightBps.div(10000)),
        maxPriceWeightedBorrowsUsd: new bignumber_js_1.default(borrowedAmount.times(borrowReserve.maxPrice)).times(borrowReserve.config.borrowWeightBps.div(10000)),
        minPriceBorrowLimitUsd: deposits.reduce((acc, deposit) => {
            const depositReserve = reserveMap[deposit.coinType];
            return acc.plus(deposit.depositedAmount
                .times(depositReserve.minPrice)
                .times(depositReserve.config.openLtvPct / 100));
        }, new bignumber_js_1.default(0)), // Not capped to $30m
        unhealthyBorrowValueUsd: deposits.reduce((acc, deposit) => {
            const depositReserve = reserveMap[deposit.coinType];
            return acc.plus(deposit.depositedAmount
                .times(depositReserve.price)
                .times(depositReserve.config.closeLtvPct / 100));
        }, new bignumber_js_1.default(0)),
    };
    return obligation;
};
exports.getStrategySimulatedObligation = getStrategySimulatedObligation;
const getStrategyDepositedAmount = (
// AppContext
reserveMap, 
// Strategy
lstMap, strategyType, obligation) => {
    var _a, _b;
    const depositReserves = (0, exports.getStrategyDepositReserves)(reserveMap, strategyType);
    const borrowReserve = (0, exports.getStrategyBorrowReserve)(reserveMap, strategyType);
    const defaultCurrencyReserve = (0, exports.getStrategyDefaultCurrencyReserve)(reserveMap, strategyType);
    //
    if (!obligation || !(0, exports.hasStrategyPosition)(obligation))
        return new bignumber_js_1.default(0);
    let resultSui = new bignumber_js_1.default(0);
    for (const deposit of obligation.deposits) {
        if ((0, sui_fe_1.isSui)(deposit.coinType)) {
            resultSui = resultSui.plus(deposit.depositedAmount);
        }
        else if (Object.keys(lstMap).includes(deposit.coinType)) {
            const lstToSuiExchangeRate = (_b = (_a = lstMap === null || lstMap === void 0 ? void 0 : lstMap[deposit.coinType]) === null || _a === void 0 ? void 0 : _a.lstToSuiExchangeRate) !== null && _b !== void 0 ? _b : new bignumber_js_1.default(1);
            // const redeemFeePercent =
            //   lstMap?.[deposit.coinType]?.redeemFeePercent ?? new BigNumber(0);
            resultSui = resultSui.plus(deposit.depositedAmount.times(lstToSuiExchangeRate));
        }
        else {
            const depositReserve = reserveMap[deposit.coinType];
            const priceSui = depositReserve.price.div((0, exports.getStrategySuiReserve)(reserveMap).price);
            resultSui = resultSui.plus(deposit.depositedAmount.times(priceSui));
        }
    }
    const resultUsd = resultSui.times((0, exports.getStrategySuiReserve)(reserveMap).price);
    const resultDefaultCurrency = new bignumber_js_1.default(resultUsd.div(defaultCurrencyReserve.price)).decimalPlaces(defaultCurrencyReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
    return resultDefaultCurrency;
};
exports.getStrategyDepositedAmount = getStrategyDepositedAmount;
const getStrategyBorrowedAmount = (
// AppContext
reserveMap, 
// Strategy
lstMap, strategyType, obligation) => {
    const depositReserves = (0, exports.getStrategyDepositReserves)(reserveMap, strategyType);
    const borrowReserve = (0, exports.getStrategyBorrowReserve)(reserveMap, strategyType);
    const defaultCurrencyReserve = (0, exports.getStrategyDefaultCurrencyReserve)(reserveMap, strategyType);
    //
    if (!obligation || !(0, exports.hasStrategyPosition)(obligation))
        return new bignumber_js_1.default(0);
    let resultSui = new bignumber_js_1.default(0);
    for (const borrow of obligation.borrows) {
        if ((0, sui_fe_1.isSui)(borrow.coinType)) {
            resultSui = resultSui.plus(borrow.borrowedAmount);
        }
        else if (Object.keys(lstMap).includes(borrow.coinType)) {
            // Can't borrow LSTs
            continue;
        }
        else {
            const priceSui = borrowReserve.price.div((0, exports.getStrategySuiReserve)(reserveMap).price);
            resultSui = resultSui.plus(borrow.borrowedAmount.times(priceSui));
        }
    }
    const resultUsd = resultSui.times((0, exports.getStrategySuiReserve)(reserveMap).price);
    const resultDefaultCurrency = new bignumber_js_1.default(resultUsd.div(defaultCurrencyReserve.price)).decimalPlaces(defaultCurrencyReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
    return resultDefaultCurrency;
};
exports.getStrategyBorrowedAmount = getStrategyBorrowedAmount;
const getStrategyTvlAmount = (
// AppContext
reserveMap, 
// Strategy
lstMap, strategyType, obligation) => {
    if (!obligation || !(0, exports.hasStrategyPosition)(obligation))
        return new bignumber_js_1.default(0);
    return (0, exports.getStrategyDepositedAmount)(reserveMap, lstMap, strategyType, obligation).minus((0, exports.getStrategyBorrowedAmount)(reserveMap, lstMap, strategyType, obligation));
};
exports.getStrategyTvlAmount = getStrategyTvlAmount;
const getStrategyExposure = (
// AppContext
reserveMap, 
// StrategyContext
lstMap, strategyType, obligation) => {
    const depositReserves = (0, exports.getStrategyDepositReserves)(reserveMap, strategyType);
    const borrowReserve = (0, exports.getStrategyBorrowReserve)(reserveMap, strategyType);
    const defaultCurrencyReserve = (0, exports.getStrategyDefaultCurrencyReserve)(reserveMap, strategyType);
    //
    if (!obligation || !(0, exports.hasStrategyPosition)(obligation))
        return new bignumber_js_1.default(0);
    const depositedAmountUsd = (0, exports.getStrategyDepositedAmount)(reserveMap, lstMap, strategyType, obligation).times(defaultCurrencyReserve.price);
    const borrowedAmountUsd = (0, exports.getStrategyBorrowedAmount)(reserveMap, lstMap, strategyType, obligation).times(defaultCurrencyReserve.price);
    return depositedAmountUsd.eq(0)
        ? new bignumber_js_1.default(0)
        : depositedAmountUsd.div(depositedAmountUsd.minus(borrowedAmountUsd));
};
exports.getStrategyExposure = getStrategyExposure;
const getStrategyStepMaxBorrowedAmount = (
// AppContext
reserveMap, 
// Strategy
lstMap, strategyType, deposits, borrowedAmount) => {
    const depositReserves = (0, exports.getStrategyDepositReserves)(reserveMap, strategyType);
    const borrowReserve = (0, exports.getStrategyBorrowReserve)(reserveMap, strategyType);
    const defaultCurrencyReserve = (0, exports.getStrategyDefaultCurrencyReserve)(reserveMap, strategyType);
    //
    const obligation = (0, exports.getStrategySimulatedObligation)(reserveMap, lstMap, strategyType, deposits, borrowedAmount);
    const borrowFeePercent = borrowReserve.config.borrowFeeBps / 100;
    // "Borrows cannot exceed borrow limit"
    return !obligation ||
        obligation.maxPriceWeightedBorrowsUsd.gt(obligation.minPriceBorrowLimitUsd)
        ? new bignumber_js_1.default(0)
        : obligation.minPriceBorrowLimitUsd
            .minus(obligation.maxPriceWeightedBorrowsUsd)
            .div(borrowReserve.maxPrice.times(borrowReserve.config.borrowWeightBps.div(10000)))
            .div(1 + borrowFeePercent / 100);
};
exports.getStrategyStepMaxBorrowedAmount = getStrategyStepMaxBorrowedAmount;
const getStrategyStepMaxWithdrawnAmount = (
// AppContext
reserveMap, 
// Strategy
lstMap, strategyType, deposits, borrowedAmount, withdrawCoinType) => {
    var _a, _b;
    const depositReserves = (0, exports.getStrategyDepositReserves)(reserveMap, strategyType);
    const borrowReserve = (0, exports.getStrategyBorrowReserve)(reserveMap, strategyType);
    const defaultCurrencyReserve = (0, exports.getStrategyDefaultCurrencyReserve)(reserveMap, strategyType);
    const withdrawReserve = reserveMap[withdrawCoinType];
    //
    const obligation = (0, exports.getStrategySimulatedObligation)(reserveMap, lstMap, strategyType, deposits, borrowedAmount);
    return bignumber_js_1.default.min(
    // "Withdraw is unhealthy"
    !obligation ||
        obligation.maxPriceWeightedBorrowsUsd.gt(obligation.minPriceBorrowLimitUsd)
        ? new bignumber_js_1.default(0)
        : withdrawReserve.config.openLtvPct > 0
            ? obligation.minPriceBorrowLimitUsd
                .minus(obligation.maxPriceWeightedBorrowsUsd)
                .div(withdrawReserve.minPrice)
                .div(withdrawReserve.config.openLtvPct / 100)
            : sui_fe_1.MAX_U64, // Infinity
    (_b = (_a = deposits.find((deposit) => deposit.coinType === withdrawReserve.coinType)) === null || _a === void 0 ? void 0 : _a.depositedAmount) !== null && _b !== void 0 ? _b : new bignumber_js_1.default(0)).decimalPlaces(withdrawReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
};
exports.getStrategyStepMaxWithdrawnAmount = getStrategyStepMaxWithdrawnAmount;
// Simulate
const strategySimulateLoopToExposure = (
// AppContext
reserveMap, 
// Strategy
lstMap, strategyType, _deposits, _borrowedAmount, _targetBorrowedAmount, _targetExposure) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const depositReserves = (0, exports.getStrategyDepositReserves)(reserveMap, strategyType);
    const borrowReserve = (0, exports.getStrategyBorrowReserve)(reserveMap, strategyType);
    const defaultCurrencyReserve = (0, exports.getStrategyDefaultCurrencyReserve)(reserveMap, strategyType);
    const loopingDepositReserve = ((_a = depositReserves.lst) !== null && _a !== void 0 ? _a : depositReserves.base); // Must have base if no LST
    //
    let deposits = (0, lodash_1.cloneDeep)(_deposits);
    let borrowedAmount = _borrowedAmount;
    const tvlAmountUsd = (0, exports.getStrategyTvlAmount)(reserveMap, lstMap, strategyType, (0, exports.getStrategySimulatedObligation)(reserveMap, lstMap, strategyType, deposits, borrowedAmount)).times(defaultCurrencyReserve.price);
    const targetBorrowedAmount = _targetBorrowedAmount !== null && _targetBorrowedAmount !== void 0 ? _targetBorrowedAmount : tvlAmountUsd
        .times(_targetExposure.minus(1))
        .div(borrowReserve.price)
        .decimalPlaces(borrowReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
    // Base+LST or LST only
    if (loopingDepositReserve.coinType === ((_b = depositReserves.lst) === null || _b === void 0 ? void 0 : _b.coinType)) {
        for (let i = 0; i < 30; i++) {
            const exposure = (0, exports.getStrategyExposure)(reserveMap, lstMap, strategyType, (0, exports.getStrategySimulatedObligation)(reserveMap, lstMap, strategyType, deposits, borrowedAmount));
            const pendingBorrowedAmount = targetBorrowedAmount.minus(borrowedAmount);
            if (pendingBorrowedAmount.lte(exports.STRATEGY_E))
                break;
            // 1) Borrow SUI
            // 1.1) Max
            const stepMaxBorrowedAmount = (0, exports.getStrategyStepMaxBorrowedAmount)(reserveMap, lstMap, strategyType, deposits, borrowedAmount)
                .times(0.9) // 10% buffer
                .decimalPlaces(borrowReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
            const stepMaxDepositedAmount = new bignumber_js_1.default(stepMaxBorrowedAmount.minus((0, exports.getStrategyLstMintFee)(lstMap, loopingDepositReserve.coinType, stepMaxBorrowedAmount)))
                .times((_d = (_c = lstMap === null || lstMap === void 0 ? void 0 : lstMap[depositReserves.lst.coinType]) === null || _c === void 0 ? void 0 : _c.suiToLstExchangeRate) !== null && _d !== void 0 ? _d : new bignumber_js_1.default(1))
                .decimalPlaces(exports.LST_DECIMALS, bignumber_js_1.default.ROUND_DOWN);
            // 1.2) Borrow
            const stepBorrowedAmount = bignumber_js_1.default.min(pendingBorrowedAmount, stepMaxBorrowedAmount).decimalPlaces(borrowReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
            const isMaxBorrow = stepBorrowedAmount.eq(stepMaxBorrowedAmount);
            // 1.3) Update state
            borrowedAmount = borrowedAmount.plus(stepBorrowedAmount);
            // 2) Deposit LST
            // 2.1) Stake SUI for LST
            // 2.2) Deposit
            const stepDepositedAmount = new bignumber_js_1.default(stepBorrowedAmount.minus((0, exports.getStrategyLstMintFee)(lstMap, loopingDepositReserve.coinType, stepBorrowedAmount)))
                .times((_f = (_e = lstMap === null || lstMap === void 0 ? void 0 : lstMap[depositReserves.lst.coinType]) === null || _e === void 0 ? void 0 : _e.suiToLstExchangeRate) !== null && _f !== void 0 ? _f : new bignumber_js_1.default(1))
                .decimalPlaces(exports.LST_DECIMALS, bignumber_js_1.default.ROUND_DOWN);
            const isMaxDeposit = stepDepositedAmount.eq(stepMaxDepositedAmount);
            // 2.3) Update state
            deposits = (0, exports.addOrInsertStrategyDeposit)(deposits, {
                coinType: loopingDepositReserve.coinType,
                depositedAmount: stepDepositedAmount,
            });
        }
    }
    // Base only
    else if (loopingDepositReserve.coinType === ((_g = depositReserves.base) === null || _g === void 0 ? void 0 : _g.coinType)) {
        const borrowToBaseExchangeRate = new bignumber_js_1.default(1); // Assume 1:1 exchange rate
        for (let i = 0; i < 30; i++) {
            const exposure = (0, exports.getStrategyExposure)(reserveMap, lstMap, strategyType, (0, exports.getStrategySimulatedObligation)(reserveMap, lstMap, strategyType, deposits, borrowedAmount));
            const pendingBorrowedAmount = targetBorrowedAmount.minus(borrowedAmount);
            if (pendingBorrowedAmount.lte(exports.STRATEGY_E))
                break;
            // 1) Borrow
            // 1.1) Max
            const stepMaxBorrowedAmount = (0, exports.getStrategyStepMaxBorrowedAmount)(reserveMap, lstMap, strategyType, deposits, borrowedAmount)
                .times(0.9) // 10% buffer
                .decimalPlaces(borrowReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
            const stepMaxDepositedAmount = stepMaxBorrowedAmount
                .times(borrowToBaseExchangeRate)
                .decimalPlaces(loopingDepositReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
            // 1.2) Borrow
            const stepBorrowedAmount = bignumber_js_1.default.min(pendingBorrowedAmount, stepMaxBorrowedAmount).decimalPlaces(borrowReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
            const isMaxBorrow = stepBorrowedAmount.eq(stepMaxBorrowedAmount);
            // 1.3) Update state
            borrowedAmount = borrowedAmount.plus(stepBorrowedAmount);
            // 2) Deposit base
            // 2.1) Swap borrows for base
            // 2.2) Deposit
            const stepDepositedAmount = stepBorrowedAmount
                .times(borrowToBaseExchangeRate)
                .decimalPlaces(loopingDepositReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
            const isMaxDeposit = stepDepositedAmount.eq(stepMaxDepositedAmount);
            // 2.3) Update state
            deposits = (0, exports.addOrInsertStrategyDeposit)(deposits, {
                coinType: loopingDepositReserve.coinType,
                depositedAmount: stepDepositedAmount,
            });
        }
    }
    else {
        throw new Error("No LST or base reserve found"); // Should not happen
    }
    return {
        deposits,
        borrowedAmount,
        obligation: (0, exports.getStrategySimulatedObligation)(reserveMap, lstMap, strategyType, deposits, borrowedAmount),
    };
};
exports.strategySimulateLoopToExposure = strategySimulateLoopToExposure;
const strategySimulateDeposit = (
// AppContext
reserveMap, 
// Strategy
lstMap, strategyType, _deposits, _borrowedAmount, deposit) => {
    var _a, _b, _c, _d;
    const depositReserves = (0, exports.getStrategyDepositReserves)(reserveMap, strategyType);
    const borrowReserve = (0, exports.getStrategyBorrowReserve)(reserveMap, strategyType);
    const defaultCurrencyReserve = (0, exports.getStrategyDefaultCurrencyReserve)(reserveMap, strategyType);
    const depositReserve = ((_a = depositReserves.base) !== null && _a !== void 0 ? _a : depositReserves.lst); // Must have LST if no base
    //
    let deposits = (0, lodash_1.cloneDeep)(_deposits);
    const borrowedAmount = _borrowedAmount;
    // 1) Deposit
    // 1.1) SUI
    if ((0, sui_fe_1.isSui)(deposit.coinType)) {
        if (depositReserves.lst === undefined)
            throw new Error("LST reserve not found");
        const suiToLstExchangeRate = (_c = (_b = lstMap === null || lstMap === void 0 ? void 0 : lstMap[depositReserves.lst.coinType]) === null || _b === void 0 ? void 0 : _b.suiToLstExchangeRate) !== null && _c !== void 0 ? _c : new bignumber_js_1.default(1);
        const suiAmount = deposit.depositedAmount;
        const lstAmount = new bignumber_js_1.default(suiAmount
            .minus((0, exports.getStrategyLstMintFee)(lstMap, depositReserves.lst.coinType, suiAmount))
            .times(suiToLstExchangeRate)).decimalPlaces(exports.LST_DECIMALS, bignumber_js_1.default.ROUND_DOWN);
        // 1.1.1) Split coins
        // 1.1.2) Stake SUI for LST
        // 1.1.3) Deposit LST (1x exposure)
        // 1.1.4) Update state
        deposits = (0, exports.addOrInsertStrategyDeposit)(deposits, {
            coinType: depositReserves.lst.coinType,
            depositedAmount: lstAmount,
        });
    }
    // 1.2) LST
    else if (deposit.coinType === ((_d = depositReserves.lst) === null || _d === void 0 ? void 0 : _d.coinType)) {
        // 1.2.1) Split coins
        // 1.2.2) Deposit LST (1x exposure)
        // 1.2.3) Update state
        deposits = (0, exports.addOrInsertStrategyDeposit)(deposits, deposit);
    }
    // 1.3) Other
    else {
        // 1.3.1) Split coins
        // 1.3.2) Deposit other (1x exposure)
        // 1.3.3) Update state
        deposits = (0, exports.addOrInsertStrategyDeposit)(deposits, deposit);
    }
    return {
        deposits,
        borrowedAmount,
        obligation: (0, exports.getStrategySimulatedObligation)(reserveMap, lstMap, strategyType, deposits, borrowedAmount),
    };
};
exports.strategySimulateDeposit = strategySimulateDeposit;
const strategySimulateDepositAndLoopToExposure = (
// AppContext
reserveMap, 
// Strategy
lstMap, strategyType, _deposits, _borrowedAmount, deposit, targetExposure) => {
    const depositReserves = (0, exports.getStrategyDepositReserves)(reserveMap, strategyType);
    const borrowReserve = (0, exports.getStrategyBorrowReserve)(reserveMap, strategyType);
    const defaultCurrencyReserve = (0, exports.getStrategyDefaultCurrencyReserve)(reserveMap, strategyType);
    //
    let deposits = (0, lodash_1.cloneDeep)(_deposits);
    let borrowedAmount = _borrowedAmount;
    let obligation = (0, exports.getStrategySimulatedObligation)(reserveMap, lstMap, strategyType, deposits, borrowedAmount);
    // 1) Deposit (1x exposure)
    // 1.1) Deposit
    const { deposits: newDeposits, borrowedAmount: newBorrowedAmount, obligation: newObligation, } = (0, exports.strategySimulateDeposit)(reserveMap, lstMap, strategyType, deposits, borrowedAmount, deposit);
    // 1.2) Update state
    deposits = newDeposits;
    borrowedAmount = newBorrowedAmount;
    obligation = newObligation;
    if (targetExposure.gt(1)) {
        // 2) Loop to target exposure
        // 2.1) Loop
        const { deposits: newDeposits2, borrowedAmount: newBorrowedAmount2, obligation: newObligation2, } = (0, exports.strategySimulateLoopToExposure)(reserveMap, lstMap, strategyType, deposits, borrowedAmount, undefined, // Don't pass targetBorrowedAmount
        targetExposure);
        // 2.2) Update state
        deposits = newDeposits2;
        borrowedAmount = newBorrowedAmount2;
        obligation = newObligation2;
    }
    return {
        deposits,
        borrowedAmount,
        obligation,
    };
};
exports.strategySimulateDepositAndLoopToExposure = strategySimulateDepositAndLoopToExposure;
// Stats
// Stats - Global TVL
const fetchStrategyGlobalTvlAmountUsdMap = () => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const url = `${sui_fe_1.API_URL}/strategies/tvl`;
        const res = yield fetch(url);
        const json = yield res.json();
        if ((json === null || json === void 0 ? void 0 : json.statusCode) === 500)
            throw new Error("Failed to fetch Strategies TVL");
        const result = Object.values(strategyOwnerCap_1.StrategyType).reduce((acc, strategyType) => {
            const entry = json.strategies.find((s) => `${s.strategyType}` === strategyType);
            const tvlUsd = entry
                ? new bignumber_js_1.default(entry.tvlUsd)
                : null;
            return Object.assign(Object.assign({}, acc), { [strategyType]: tvlUsd });
        }, {});
        return result;
    }
    catch (err) {
        console.error(err);
    }
});
exports.fetchStrategyGlobalTvlAmountUsdMap = fetchStrategyGlobalTvlAmountUsdMap;
// Stats - Unclaimed rewards
const getStrategyUnclaimedRewardsAmount = (
// AppContext
reserveMap, rewardPriceMap, rewardCoinMetadataMap, 
// UserContext
rewardMap, 
// Strategy
lstMap, strategyType, obligation) => {
    const depositReserves = (0, exports.getStrategyDepositReserves)(reserveMap, strategyType);
    const borrowReserve = (0, exports.getStrategyBorrowReserve)(reserveMap, strategyType);
    const defaultCurrencyReserve = (0, exports.getStrategyDefaultCurrencyReserve)(reserveMap, strategyType);
    //
    if (!obligation || !(0, exports.hasStrategyPosition)(obligation))
        return new bignumber_js_1.default(0);
    const rewardsMap = (0, liquidityMining_1.getRewardsMap)(obligation, rewardMap, rewardCoinMetadataMap);
    const resultSui = Object.entries(rewardsMap).reduce((acc, [coinType, { amount }]) => {
        var _a, _b, _c;
        if ((0, sui_fe_1.isSui)(coinType)) {
            return acc.plus(amount);
        }
        else if (Object.keys(lstMap).includes(coinType)) {
            const lstToSuiExchangeRate = (_b = (_a = lstMap === null || lstMap === void 0 ? void 0 : lstMap[coinType]) === null || _a === void 0 ? void 0 : _a.lstToSuiExchangeRate) !== null && _b !== void 0 ? _b : new bignumber_js_1.default(1);
            return acc.plus(amount.times(lstToSuiExchangeRate));
        }
        else {
            const price = (_c = rewardPriceMap[coinType]) !== null && _c !== void 0 ? _c : new bignumber_js_1.default(0);
            const priceSui = price.div((0, exports.getStrategySuiReserve)(reserveMap).price);
            return acc.plus(amount.times(priceSui));
        }
    }, new bignumber_js_1.default(0));
    const resultUsd = resultSui.times((0, exports.getStrategySuiReserve)(reserveMap).price);
    const resultDefaultCurrency = new bignumber_js_1.default(resultUsd.div(defaultCurrencyReserve.price)).decimalPlaces(defaultCurrencyReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
    return resultDefaultCurrency;
};
exports.getStrategyUnclaimedRewardsAmount = getStrategyUnclaimedRewardsAmount;
// Stats - History
// Stats - Historical TVL
// Stats - APR
const getStrategyAprPercent = (
// AppContext
reserveMap, lstStatsMap, 
// UserContext
rewardMap, 
// Strategy
lstMap, strategyType, obligation, exposure) => {
    const depositReserves = (0, exports.getStrategyDepositReserves)(reserveMap, strategyType);
    const borrowReserve = (0, exports.getStrategyBorrowReserve)(reserveMap, strategyType);
    const defaultCurrencyReserve = (0, exports.getStrategyDefaultCurrencyReserve)(reserveMap, strategyType);
    //
    let _obligation;
    if (!!obligation && (0, exports.hasStrategyPosition)(obligation)) {
        _obligation = obligation;
    }
    else {
        if (exposure === undefined)
            return new bignumber_js_1.default(0); // Not shown in UI
        _obligation = (0, exports.strategySimulateDepositAndLoopToExposure)(reserveMap, lstMap, strategyType, [], new bignumber_js_1.default(0), {
            coinType: defaultCurrencyReserve.coinType,
            depositedAmount: new bignumber_js_1.default(1), // Any number will do
        }, exposure).obligation;
    }
    return (0, lib_1.getNetAprPercent)(_obligation, rewardMap, lstStatsMap, undefined, // elixirSdeUsdAprPercent
    !obligation ||
        !(0, exports.hasStrategyPosition)(obligation) ||
        obligation.deposits.some((d) => !d.userRewardManager));
};
exports.getStrategyAprPercent = getStrategyAprPercent;
// Stats - Health
const getStrategyHealthPercent = (
// AppContext
reserveMap, 
// Strategy
lstMap, strategyType, obligation, exposure) => {
    const depositReserves = (0, exports.getStrategyDepositReserves)(reserveMap, strategyType);
    const borrowReserve = (0, exports.getStrategyBorrowReserve)(reserveMap, strategyType);
    const defaultCurrencyReserve = (0, exports.getStrategyDefaultCurrencyReserve)(reserveMap, strategyType);
    //
    let _obligation;
    if (!!obligation && (0, exports.hasStrategyPosition)(obligation)) {
        _obligation = obligation;
    }
    else {
        if (exposure === undefined)
            return new bignumber_js_1.default(0); // Not shown in UI
        _obligation = (0, exports.strategySimulateDepositAndLoopToExposure)(reserveMap, lstMap, strategyType, [], new bignumber_js_1.default(0), {
            coinType: defaultCurrencyReserve.coinType,
            depositedAmount: new bignumber_js_1.default(1), // Any number will do
        }, exposure).obligation;
    }
    const weightedBorrowsUsd = (0, utils_2.getWeightedBorrowsUsd)(_obligation);
    const borrowLimitUsd = _obligation.minPriceBorrowLimitUsd.times(depositReserves.base !== undefined
        ? 0.99 // 1% buffer
        : 1);
    const liquidationThresholdUsd = _obligation.unhealthyBorrowValueUsd;
    if (weightedBorrowsUsd.lte(borrowLimitUsd))
        return new bignumber_js_1.default(100);
    return new bignumber_js_1.default(100).minus(new bignumber_js_1.default(weightedBorrowsUsd.minus(borrowLimitUsd))
        .div(liquidationThresholdUsd.minus(borrowLimitUsd))
        .times(100));
};
exports.getStrategyHealthPercent = getStrategyHealthPercent;
// Stats - Liquidation price
const getStrategyLiquidationPrice = (
// AppContext
reserveMap, 
// Strategy
lstMap, strategyType, obligation, exposure) => {
    var _a;
    const depositReserves = (0, exports.getStrategyDepositReserves)(reserveMap, strategyType);
    const borrowReserve = (0, exports.getStrategyBorrowReserve)(reserveMap, strategyType);
    const defaultCurrencyReserve = (0, exports.getStrategyDefaultCurrencyReserve)(reserveMap, strategyType);
    //
    if (![
        strategyOwnerCap_1.StrategyType.USDC_sSUI_SUI_LOOPING,
        strategyOwnerCap_1.StrategyType.AUSD_sSUI_SUI_LOOPING,
        strategyOwnerCap_1.StrategyType.xBTC_sSUI_SUI_LOOPING,
        strategyOwnerCap_1.StrategyType.suiUSDT_sSUI_SUI_LOOPING,
    ].includes(strategyType))
        return new bignumber_js_1.default(0); // Not shown in UI
    let _obligation;
    if (!!obligation && (0, exports.hasStrategyPosition)(obligation)) {
        _obligation = obligation;
    }
    else {
        if (exposure === undefined)
            return new bignumber_js_1.default(0); // Not shown in UI
        _obligation = (0, exports.strategySimulateDepositAndLoopToExposure)(reserveMap, lstMap, strategyType, [], new bignumber_js_1.default(0), {
            coinType: defaultCurrencyReserve.coinType,
            depositedAmount: new bignumber_js_1.default(1), // Any number will do
        }, exposure).obligation;
    }
    const baseDeposit = _obligation.deposits.find((d) => d.coinType === depositReserves.base.coinType);
    const lstDeposit = _obligation.deposits.find((d) => d.coinType === depositReserves.lst.coinType);
    if (!baseDeposit || baseDeposit.depositedAmount.eq(0))
        return null;
    const borrow = _obligation.borrows[0];
    if (!borrow || borrow.borrowedAmount.eq(0))
        return null;
    const result = new bignumber_js_1.default(baseDeposit.depositedAmount
        .times(depositReserves.base.price)
        .times(+depositReserves.base.config.closeLtvPct / 100)).div(new bignumber_js_1.default(borrow.borrowedAmount.times(borrowReserve.config.borrowWeightBps.div(10000))).minus(((_a = lstDeposit === null || lstDeposit === void 0 ? void 0 : lstDeposit.depositedAmount) !== null && _a !== void 0 ? _a : new bignumber_js_1.default(0)).times(+depositReserves.lst.config.closeLtvPct / 100)));
    return result;
};
exports.getStrategyLiquidationPrice = getStrategyLiquidationPrice;
// --------------------------------
const strategyLoopToExposureTx = (
// AppContext
reserveMap, 
// Strategy
lstMap, strategyType, suiClient, suilendClient, cetusSdk, cetusPartnerId, _address, strategyOwnerCapId, obligationId, _deposits, _borrowedAmount, _targetBorrowedAmount, _targetExposure, // Must be defined if _targetBorrowedAmount is undefined
transaction) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d, _e;
    const strategyInfo = strategyOwnerCap_1.STRATEGY_TYPE_INFO_MAP[strategyType];
    const lst = strategyInfo.depositLstCoinType !== undefined
        ? lstMap[strategyInfo.depositLstCoinType]
        : undefined;
    const depositReserves = (0, exports.getStrategyDepositReserves)(reserveMap, strategyType);
    const borrowReserve = (0, exports.getStrategyBorrowReserve)(reserveMap, strategyType);
    const defaultCurrencyReserve = (0, exports.getStrategyDefaultCurrencyReserve)(reserveMap, strategyType);
    console.log(`[loopStrategyToExposure] args |`, JSON.stringify({
        _address,
        strategyOwnerCapId,
        obligationId,
        _deposits: _deposits.map((d) => ({
            coinType: d.coinType,
            depositedAmount: d.depositedAmount.toFixed(20),
        })),
        _borrowedAmount: _borrowedAmount.toFixed(20),
        _targetBorrowedAmount: _targetBorrowedAmount === null || _targetBorrowedAmount === void 0 ? void 0 : _targetBorrowedAmount.toFixed(20),
        _targetExposure: _targetExposure === null || _targetExposure === void 0 ? void 0 : _targetExposure.toFixed(20),
    }, null, 2));
    const loopingDepositReserve = ((_a = depositReserves.lst) !== null && _a !== void 0 ? _a : depositReserves.base); // Must have base if no LST
    //
    let deposits = (0, lodash_1.cloneDeep)(_deposits);
    let borrowedAmount = _borrowedAmount;
    const tvlAmountUsd = (0, exports.getStrategyTvlAmount)(reserveMap, lstMap, strategyType, (0, exports.getStrategySimulatedObligation)(reserveMap, lstMap, strategyType, deposits, borrowedAmount)).times(defaultCurrencyReserve.price);
    const targetBorrowedAmount = _targetBorrowedAmount !== null && _targetBorrowedAmount !== void 0 ? _targetBorrowedAmount : tvlAmountUsd
        .times(_targetExposure.minus(1))
        .div(borrowReserve.price)
        .decimalPlaces(borrowReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
    console.log(`[loopStrategyToExposure] processed_args |`, JSON.stringify({
        tvlAmountUsd: tvlAmountUsd.toFixed(20),
        targetBorrowedAmount: targetBorrowedAmount.toFixed(20),
    }));
    // Base+LST or LST only
    if (loopingDepositReserve.coinType === ((_b = depositReserves.lst) === null || _b === void 0 ? void 0 : _b.coinType)) {
        for (let i = 0; i < 30; i++) {
            const exposure = (0, exports.getStrategyExposure)(reserveMap, lstMap, strategyType, (0, exports.getStrategySimulatedObligation)(reserveMap, lstMap, strategyType, deposits, borrowedAmount));
            const pendingBorrowedAmount = targetBorrowedAmount.minus(borrowedAmount);
            console.log(`[loopStrategyToExposure] ${i} start |`, JSON.stringify({
                deposits: deposits.map((d) => ({
                    coinType: d.coinType,
                    depositedAmount: d.depositedAmount.toFixed(20),
                })),
                borrowedAmount: borrowedAmount.toFixed(20),
                exposure: exposure.toFixed(20),
                pendingBorrowedAmount: pendingBorrowedAmount.toFixed(20),
            }, null, 2));
            if (pendingBorrowedAmount.lte(exports.STRATEGY_E))
                break;
            // 1) Borrow SUI
            // 1.1) Max
            const stepMaxBorrowedAmount = (0, exports.getStrategyStepMaxBorrowedAmount)(reserveMap, lstMap, strategyType, deposits, borrowedAmount)
                .times(0.9) // 10% buffer
                .decimalPlaces(borrowReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
            const stepMaxDepositedAmount = new bignumber_js_1.default(stepMaxBorrowedAmount.minus((0, exports.getStrategyLstMintFee)(lstMap, loopingDepositReserve.coinType, stepMaxBorrowedAmount)))
                .times((_c = lst === null || lst === void 0 ? void 0 : lst.suiToLstExchangeRate) !== null && _c !== void 0 ? _c : 1)
                .decimalPlaces(exports.LST_DECIMALS, bignumber_js_1.default.ROUND_DOWN);
            console.log(`[loopStrategyToExposure] ${i} borrow_sui.max |`, JSON.stringify({
                stepMaxBorrowedAmount: stepMaxBorrowedAmount.toFixed(20),
                stepMaxDepositedAmount: stepMaxDepositedAmount.toFixed(20),
            }, null, 2));
            // 1.2) Borrow
            const stepBorrowedAmount = bignumber_js_1.default.min(pendingBorrowedAmount, stepMaxBorrowedAmount).decimalPlaces(borrowReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
            const isMaxBorrow = stepBorrowedAmount.eq(stepMaxBorrowedAmount);
            console.log(`[loopStrategyToExposure] ${i} borrow_sui.borrow |`, JSON.stringify({
                stepBorrowedAmount: stepBorrowedAmount.toFixed(20),
                isMaxBorrow,
            }, null, 2));
            const [borrowedCoin] = (0, strategyOwnerCap_1.strategyBorrow)(borrowReserve.coinType, strategyOwnerCapId, suilendClient.findReserveArrayIndex(borrowReserve.coinType), BigInt(stepBorrowedAmount
                .times(10 ** borrowReserve.token.decimals)
                .integerValue(bignumber_js_1.default.ROUND_DOWN)
                .toString()), transaction);
            // 1.3) Update state
            borrowedAmount = borrowedAmount.plus(stepBorrowedAmount);
            console.log(`[loopStrategyToExposure] ${i} borrow_sui.update_state |`, JSON.stringify({
                deposits: deposits.map((d) => ({
                    coinType: d.coinType,
                    depositedAmount: d.depositedAmount.toFixed(20),
                })),
                borrowedAmount: borrowedAmount.toFixed(20),
            }, null, 2));
            // 2) Deposit LST
            // 2.1) Stake SUI for LST
            const stepLstCoin = lst.client.mint(transaction, borrowedCoin);
            // 2.2) Deposit
            const stepDepositedAmount = new bignumber_js_1.default(stepBorrowedAmount.minus((0, exports.getStrategyLstMintFee)(lstMap, loopingDepositReserve.coinType, stepBorrowedAmount)))
                .times((_d = lst === null || lst === void 0 ? void 0 : lst.suiToLstExchangeRate) !== null && _d !== void 0 ? _d : 1)
                .decimalPlaces(exports.LST_DECIMALS, bignumber_js_1.default.ROUND_DOWN);
            const isMaxDeposit = stepDepositedAmount.eq(stepMaxDepositedAmount);
            console.log(`[loopStrategyToExposure] ${i} deposit_lst.deposit |`, JSON.stringify({
                stepDepositedAmount: stepDepositedAmount.toFixed(20),
                isMaxDeposit,
            }, null, 2));
            (0, strategyOwnerCap_1.strategyDeposit)(stepLstCoin, loopingDepositReserve.coinType, strategyOwnerCapId, suilendClient.findReserveArrayIndex(loopingDepositReserve.coinType), transaction);
            // 2.3) Update state
            deposits = (0, exports.addOrInsertStrategyDeposit)(deposits, {
                coinType: loopingDepositReserve.coinType,
                depositedAmount: stepDepositedAmount,
            });
            console.log(`[loopStrategyToExposure] ${i} deposit_lst.update_state |`, JSON.stringify({
                deposits: deposits.map((d) => ({
                    coinType: d.coinType,
                    depositedAmount: d.depositedAmount.toFixed(20),
                })),
                borrowedAmount: borrowedAmount.toFixed(20),
            }, null, 2));
        }
    }
    // Base only
    else if (loopingDepositReserve.coinType === ((_e = depositReserves.base) === null || _e === void 0 ? void 0 : _e.coinType)) {
        const exchangeRateRouters = yield cetusSdk.findRouters({
            from: borrowReserve.coinType,
            target: loopingDepositReserve.coinType,
            amount: new bn_js_1.BN(new bignumber_js_1.default(0.1)
                .times(10 ** borrowReserve.token.decimals)
                .integerValue(bignumber_js_1.default.ROUND_DOWN)
                .toString()),
            byAmountIn: true,
            splitCount: 0, // Use direct swap to avoid split algo
        });
        if (!exchangeRateRouters)
            throw new Error("No swap quote found");
        const borrowToBaseExchangeRate = new bignumber_js_1.default(new bignumber_js_1.default(exchangeRateRouters.amountOut.toString()).div(10 ** loopingDepositReserve.token.decimals)).div(new bignumber_js_1.default(exchangeRateRouters.amountIn.toString()).div(10 ** borrowReserve.token.decimals));
        for (let i = 0; i < 30; i++) {
            const exposure = (0, exports.getStrategyExposure)(reserveMap, lstMap, strategyType, (0, exports.getStrategySimulatedObligation)(reserveMap, lstMap, strategyType, deposits, borrowedAmount));
            const pendingBorrowedAmount = targetBorrowedAmount.minus(borrowedAmount);
            console.log(`[loopStrategyToExposure] ${i} start |`, JSON.stringify({
                deposits: deposits.map((d) => ({
                    coinType: d.coinType,
                    depositedAmount: d.depositedAmount.toFixed(20),
                })),
                borrowedAmount: borrowedAmount.toFixed(20),
                exposure: exposure.toFixed(20),
                pendingBorrowedAmount: pendingBorrowedAmount.toFixed(20),
            }, null, 2));
            if (pendingBorrowedAmount.lte(exports.STRATEGY_E))
                break;
            // 1) Borrow
            // 1.1) Max
            const stepMaxBorrowedAmount = (0, exports.getStrategyStepMaxBorrowedAmount)(reserveMap, lstMap, strategyType, deposits, borrowedAmount)
                .times(0.9) // 10% buffer
                .decimalPlaces(borrowReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
            const stepMaxDepositedAmount = new bignumber_js_1.default(stepMaxBorrowedAmount.times(borrowToBaseExchangeRate)).decimalPlaces(loopingDepositReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
            console.log(`[loopStrategyToExposure] ${i} borrow.max |`, JSON.stringify({
                stepMaxBorrowedAmount: stepMaxBorrowedAmount.toFixed(20),
                stepMaxDepositedAmount: stepMaxDepositedAmount.toFixed(20),
            }, null, 2));
            // 1.2) Borrow
            const stepBorrowedAmount = bignumber_js_1.default.min(pendingBorrowedAmount, stepMaxBorrowedAmount).decimalPlaces(borrowReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
            const isMaxBorrow = stepBorrowedAmount.eq(stepMaxBorrowedAmount);
            console.log(`[loopStrategyToExposure] ${i} borrow.borrow |`, JSON.stringify({
                stepBorrowedAmount: stepBorrowedAmount.toFixed(20),
                isMaxBorrow,
            }, null, 2));
            const [stepBorrowedCoin] = (0, strategyOwnerCap_1.strategyBorrow)(borrowReserve.coinType, strategyOwnerCapId, suilendClient.findReserveArrayIndex(borrowReserve.coinType), BigInt(stepBorrowedAmount
                .times(10 ** borrowReserve.token.decimals)
                .integerValue(bignumber_js_1.default.ROUND_DOWN)
                .toString()), transaction);
            // 1.3) Update state
            borrowedAmount = borrowedAmount.plus(stepBorrowedAmount);
            console.log(`[loopStrategyToExposure] ${i} borrow.update_state |`, JSON.stringify({
                deposits: deposits.map((d) => ({
                    coinType: d.coinType,
                    depositedAmount: d.depositedAmount.toFixed(20),
                })),
                borrowedAmount: borrowedAmount.toFixed(20),
            }, null, 2));
            // 2) Deposit base
            // 2.1) Swap borrows for base
            const routers = yield cetusSdk.findRouters({
                from: borrowReserve.coinType,
                target: loopingDepositReserve.coinType,
                amount: new bn_js_1.BN(stepBorrowedAmount
                    .times(10 ** borrowReserve.token.decimals)
                    .integerValue(bignumber_js_1.default.ROUND_DOWN)
                    .toString()), // Estimate for loop 2 onwards (don't know exact out amount, we are not accounting for swap fees, etc)
                byAmountIn: true,
                splitCount: 0, // Use direct swap to avoid split algo
            });
            if (!routers)
                throw new Error("No swap quote found");
            const slippagePercent = 1;
            let stepBaseCoin;
            try {
                stepBaseCoin = yield cetusSdk.fixableRouterSwapV3({
                    router: routers,
                    inputCoin: stepBorrowedCoin,
                    slippage: slippagePercent / 100,
                    txb: transaction,
                    partner: cetusPartnerId,
                });
            }
            catch (err) {
                throw new Error("No swap quote found");
            }
            console.log(`[loopStrategyToExposure] ${i} swap_borrows_for_base.swap |`, JSON.stringify({
                inCoinType: borrowReserve.coinType,
                outCoinType: loopingDepositReserve.coinType,
                amountIn: stepBorrowedAmount.toFixed(20),
                amountOut: new bignumber_js_1.default(routers.amountOut.toString())
                    .div(10 ** loopingDepositReserve.token.decimals)
                    .decimalPlaces(loopingDepositReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN)
                    .toFixed(20),
            }, null, 2), routers);
            // 2.2) Deposit
            const stepDepositedAmount = new bignumber_js_1.default(new bignumber_js_1.default(routers.amountOut.toString()).div(10 ** loopingDepositReserve.token.decimals)).decimalPlaces(loopingDepositReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
            const isMaxDeposit = stepDepositedAmount.eq(stepMaxDepositedAmount);
            console.log(`[loopStrategyToExposure] ${i} deposit.deposit |`, JSON.stringify({
                stepDepositedAmount: stepDepositedAmount.toFixed(20),
                isMaxDeposit,
            }, null, 2));
            (0, strategyOwnerCap_1.strategyDeposit)(stepBaseCoin, loopingDepositReserve.coinType, strategyOwnerCapId, suilendClient.findReserveArrayIndex(loopingDepositReserve.coinType), transaction);
            // 2.3) Update state
            deposits = (0, exports.addOrInsertStrategyDeposit)(deposits, {
                coinType: loopingDepositReserve.coinType,
                depositedAmount: stepDepositedAmount,
            });
            console.log(`[loopStrategyToExposure] ${i} deposit.update_state |`, JSON.stringify({
                deposits: deposits.map((d) => ({
                    coinType: d.coinType,
                    depositedAmount: d.depositedAmount.toFixed(20),
                })),
                borrowedAmount: borrowedAmount.toFixed(20),
            }, null, 2));
        }
    }
    else {
        throw new Error("No LST or base reserve found"); // Should not happen
    }
    return { deposits, borrowedAmount, transaction };
});
exports.strategyLoopToExposureTx = strategyLoopToExposureTx;
const strategyUnloopToExposureTx = (
// AppContext
reserveMap, 
// Strategy
lstMap, strategyType, suiClient, suilendClient, cetusSdk, cetusPartnerId, _address, strategyOwnerCapId, obligationId, _deposits, _borrowedAmount, _targetBorrowedAmount, _targetExposure, // Must be defined if _targetBorrowedAmount is undefined
transaction, dryRunTransaction) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const strategyInfo = strategyOwnerCap_1.STRATEGY_TYPE_INFO_MAP[strategyType];
    const lst = strategyInfo.depositLstCoinType !== undefined
        ? lstMap[strategyInfo.depositLstCoinType]
        : undefined;
    const depositReserves = (0, exports.getStrategyDepositReserves)(reserveMap, strategyType);
    const borrowReserve = (0, exports.getStrategyBorrowReserve)(reserveMap, strategyType);
    const defaultCurrencyReserve = (0, exports.getStrategyDefaultCurrencyReserve)(reserveMap, strategyType);
    console.log(`[unloopStrategyToExposure] args |`, JSON.stringify({
        _address,
        strategyOwnerCapId,
        obligationId,
        _deposits: _deposits.map((d) => ({
            coinType: d.coinType,
            depositedAmount: d.depositedAmount.toFixed(20),
        })),
        _borrowedAmount: _borrowedAmount.toFixed(20),
        _targetBorrowedAmount: _targetBorrowedAmount === null || _targetBorrowedAmount === void 0 ? void 0 : _targetBorrowedAmount.toFixed(20),
        _targetExposure: _targetExposure === null || _targetExposure === void 0 ? void 0 : _targetExposure.toFixed(20),
    }, null, 2));
    const depositReserve = ((_a = depositReserves.base) !== null && _a !== void 0 ? _a : depositReserves.lst); // Must have LST if no base
    const loopingDepositReserve = ((_b = depositReserves.lst) !== null && _b !== void 0 ? _b : depositReserves.base); // Must have base if no LST
    //
    let deposits = (0, lodash_1.cloneDeep)(_deposits);
    let borrowedAmount = _borrowedAmount;
    const tvlAmountUsd = (0, exports.getStrategyTvlAmount)(reserveMap, lstMap, strategyType, (0, exports.getStrategySimulatedObligation)(reserveMap, lstMap, strategyType, deposits, borrowedAmount)).times(defaultCurrencyReserve.price);
    const targetBorrowedAmount = _targetBorrowedAmount !== null && _targetBorrowedAmount !== void 0 ? _targetBorrowedAmount : tvlAmountUsd
        .times(_targetExposure.minus(1))
        .div(borrowReserve.price)
        .decimalPlaces(borrowReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
    console.log(`[unloopStrategyToExposure] processed_args |`, JSON.stringify({
        tvlAmountUsd: tvlAmountUsd.toFixed(20),
        targetBorrowedAmount: targetBorrowedAmount.toFixed(20),
    }));
    if (borrowedAmount.eq(targetBorrowedAmount))
        return { deposits, borrowedAmount, transaction };
    const fullyRepayBorrowsUsingLst = (maxWithdrawRemainingLstAndRedepositAsBase) => __awaiter(void 0, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g;
        if (depositReserves.lst === undefined)
            throw new Error("LST reserve not found");
        const borrowedAmountUsd = borrowedAmount.times(borrowReserve.price);
        const fullRepaymentAmount = (borrowedAmountUsd.lt(0.1)
            ? new bignumber_js_1.default(0.1).div(borrowReserve.price) // $0.1 in borrow coinType
            : borrowedAmountUsd.lt(1)
                ? borrowedAmount.times(1.1) // 10% buffer
                : borrowedAmountUsd.lt(10)
                    ? borrowedAmount.times(1.01) // 1% buffer
                    : borrowedAmount.times(1.001)) // 0.1% buffer
            .decimalPlaces(borrowReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
        console.log(`[unloopStrategyToExposure.fullyRepayBorrowsUsingLst] |`, JSON.stringify({
            borrowedAmount: borrowedAmount.toFixed(20),
            fullRepaymentAmount: fullRepaymentAmount.toFixed(20),
        }));
        // 1) Withdraw LST
        const lstWithdrawnAmount = fullRepaymentAmount
            .div(1 - +((_a = lst === null || lst === void 0 ? void 0 : lst.redeemFeePercent) !== null && _a !== void 0 ? _a : 0) / 100) // Potential rounding issue (max 1 MIST)
            .div((_b = lst === null || lst === void 0 ? void 0 : lst.lstToSuiExchangeRate) !== null && _b !== void 0 ? _b : 1)
            .decimalPlaces(depositReserves.lst.token.decimals, bignumber_js_1.default.ROUND_DOWN);
        if (((_d = (_c = deposits.find((d) => d.coinType === depositReserves.lst.coinType)) === null || _c === void 0 ? void 0 : _c.depositedAmount) !== null && _d !== void 0 ? _d : new bignumber_js_1.default(0)).lt(lstWithdrawnAmount))
            throw new Error("Not enough LST deposited");
        console.log(`[unloopStrategyToExposure.fullyRepayBorrowsUsingLst] withdraw_lst |`, JSON.stringify({
            lstWithdrawnAmount: lstWithdrawnAmount.toFixed(20),
        }));
        // 1.1) Withdraw
        const [withdrawnLstCoin] = (0, strategyOwnerCap_1.strategyWithdraw)(depositReserves.lst.coinType, strategyOwnerCapId, suilendClient.findReserveArrayIndex(depositReserves.lst.coinType), BigInt(new bignumber_js_1.default(lstWithdrawnAmount
            .times(10 ** exports.LST_DECIMALS)
            .integerValue(bignumber_js_1.default.ROUND_DOWN)
            .toString())
            .div(depositReserves.lst.cTokenExchangeRate)
            .integerValue(bignumber_js_1.default.ROUND_UP)
            .toString()), transaction);
        // 1.2) Update state
        deposits = (0, exports.addOrInsertStrategyDeposit)(deposits, {
            coinType: depositReserves.lst.coinType,
            depositedAmount: lstWithdrawnAmount.times(-1),
        });
        console.log(`[unloopStrategyToExposure.fullyRepayBorrowsUsingLst] withdraw_lst.update_state |`, JSON.stringify({
            deposits: deposits.map((d) => ({
                coinType: d.coinType,
                depositedAmount: d.depositedAmount.toFixed(20),
            })),
            borrowedAmount: borrowedAmount.toFixed(20),
        }, null, 2));
        // 2) Unstake LST for SUI
        const fullRepaymentCoin = lst.client.redeem(transaction, withdrawnLstCoin);
        // 3) Repay borrows
        // 3.1) Repay
        const repaidAmount = new bignumber_js_1.default(new bignumber_js_1.default(lstWithdrawnAmount.times((_e = lst === null || lst === void 0 ? void 0 : lst.lstToSuiExchangeRate) !== null && _e !== void 0 ? _e : 1)).minus((0, exports.getStrategyLstRedeemFee)(lstMap, depositReserves.lst.coinType, lstWithdrawnAmount))).decimalPlaces(borrowReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
        console.log(`[unloopStrategyToExposure.fullyRepayBorrowsUsingLst] repay_borrows.repay |`, JSON.stringify({
            repaidAmount: repaidAmount.toFixed(20),
        }, null, 2));
        try {
            const txCopy = transactions_1.Transaction.from(transaction);
            suilendClient.repay(obligationId, borrowReserve.coinType, fullRepaymentCoin, txCopy);
            txCopy.transferObjects([fullRepaymentCoin], _address); // Transfer remaining SUI to user
            yield dryRunTransaction(txCopy); // Throws error if fails
            transaction = txCopy;
        }
        catch (err) {
            // Don't block user if fails
            console.error(err);
            transaction.transferObjects([fullRepaymentCoin], _address); // Transfer SUI to user
        }
        // 2.3) Update state
        borrowedAmount = bignumber_js_1.default.max(borrowedAmount.minus(repaidAmount), new bignumber_js_1.default(0));
        console.log(`[unloopStrategyToExposure.fullyRepayBorrowsUsingLst] repay_borrows.update_state |`, JSON.stringify({
            deposits: deposits.map((d) => ({
                coinType: d.coinType,
                depositedAmount: d.depositedAmount.toFixed(20),
            })),
            borrowedAmount: borrowedAmount.toFixed(20),
        }, null, 2));
        // 3) Swap remaining borrow to LST and redeposit (not possible because coin is a mutable reference (?))
        // Max withdraw remaining LST and redeposit as base:
        if (maxWithdrawRemainingLstAndRedepositAsBase) {
            if (depositReserves.base === undefined)
                throw new Error("Base reserve not found");
            // 1) MAX withdraw LST
            const remainingLstWithdrawnAmount = ((_g = (_f = deposits.find((d) => d.coinType === depositReserves.lst.coinType)) === null || _f === void 0 ? void 0 : _f.depositedAmount) !== null && _g !== void 0 ? _g : new bignumber_js_1.default(0)).decimalPlaces(depositReserves.lst.token.decimals, bignumber_js_1.default.ROUND_DOWN);
            console.log(`[unloopStrategyToExposure.fullyRepayBorrowsUsingLst] max_withdraw_lst |`, JSON.stringify({
                remainingLstWithdrawnAmount: remainingLstWithdrawnAmount.toFixed(20),
            }));
            // 1.1) MAX Withdraw
            const [withdrawnRemainingLstCoin] = (0, strategyOwnerCap_1.strategyWithdraw)(depositReserves.lst.coinType, strategyOwnerCapId, suilendClient.findReserveArrayIndex(depositReserves.lst.coinType), BigInt(sui_fe_1.MAX_U64.toString()), transaction);
            // 1.2) Update state
            deposits = (0, exports.addOrInsertStrategyDeposit)(deposits, {
                coinType: depositReserves.lst.coinType,
                depositedAmount: remainingLstWithdrawnAmount.times(-1), // Should be 0 after this
            });
            console.log(`[unloopStrategyToExposure.fullyRepayBorrowsUsingLst] max_withdraw_lst.update_state |`, JSON.stringify({
                deposits: deposits.map((d) => ({
                    coinType: d.coinType,
                    depositedAmount: d.depositedAmount.toFixed(20),
                })),
                borrowedAmount: borrowedAmount.toFixed(20),
            }, null, 2));
            // 2) Swap LST for base and redeposit
            // 2.1) Get routers
            const routers = yield cetusSdk.findRouters({
                from: depositReserves.lst.coinType,
                target: depositReserves.base.coinType,
                amount: new bn_js_1.BN(remainingLstWithdrawnAmount
                    .times(10 ** depositReserves.lst.token.decimals)
                    .integerValue(bignumber_js_1.default.ROUND_DOWN)
                    .toString()),
                byAmountIn: true,
            });
            if (!routers)
                throw new Error("No swap quote found");
            console.log(`[unloopStrategyToExposure.fullyRepayBorrowsUsingLst] swap_lst_for_base.get_routers`, {
                routers,
                amountIn: new bignumber_js_1.default(routers.amountIn.toString())
                    .div(10 ** depositReserves.lst.token.decimals)
                    .decimalPlaces(depositReserves.lst.token.decimals, bignumber_js_1.default.ROUND_DOWN)
                    .toFixed(20),
                amountOut: new bignumber_js_1.default(routers.amountOut.toString())
                    .div(10 ** depositReserves.base.token.decimals)
                    .decimalPlaces(depositReserves.base.token.decimals, bignumber_js_1.default.ROUND_DOWN)
                    .toFixed(20),
            });
            // 2.2) Swap
            let swapCoin;
            try {
                swapCoin = yield cetusSdk.fixableRouterSwapV3({
                    router: routers,
                    inputCoin: withdrawnRemainingLstCoin,
                    slippage: 100 / 100,
                    txb: transaction,
                    partner: cetusPartnerId,
                });
            }
            catch (err) {
                throw new Error("No swap quote found");
            }
            // 3) Deposit base
            (0, strategyOwnerCap_1.strategyDeposit)(swapCoin, depositReserves.base.coinType, strategyOwnerCapId, suilendClient.findReserveArrayIndex(depositReserves.base.coinType), transaction);
        }
    });
    const fullyRepayBorrowsUsingBase = () => __awaiter(void 0, void 0, void 0, function* () {
        var _a, _b;
        if (depositReserves.base === undefined)
            throw new Error("Base reserve not found");
        const borrowedAmountUsd = borrowedAmount.times(borrowReserve.price);
        const fullRepaymentAmount = (borrowedAmountUsd.lt(0.1)
            ? new bignumber_js_1.default(0.1).div(borrowReserve.price) // $0.1 in borrow coinType
            : borrowedAmountUsd.lt(1)
                ? borrowedAmount.times(1.1) // 10% buffer
                : borrowedAmountUsd.lt(10)
                    ? borrowedAmount.times(1.01) // 1% buffer
                    : borrowedAmount.times(1.001)) // 0.1% buffer
            .decimalPlaces(borrowReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
        console.log(`[unloopStrategyToExposure.fullyRepayBorrowsUsingBase] |`, JSON.stringify({
            borrowedAmount: borrowedAmount.toFixed(20),
            fullRepaymentAmount: fullRepaymentAmount.toFixed(20),
        }));
        // 1) MAX withdraw LST
        if (depositReserves.lst !== undefined) {
            // 1.1) MAX withdraw
            const [withdrawnMaxLstCoin] = (0, strategyOwnerCap_1.strategyWithdraw)(depositReserves.lst.coinType, strategyOwnerCapId, suilendClient.findReserveArrayIndex(depositReserves.lst.coinType), BigInt(sui_fe_1.MAX_U64.toString()), transaction);
            // 1.2) Update state
            deposits = (0, exports.addOrInsertStrategyDeposit)(deposits, {
                coinType: depositReserves.lst.coinType,
                depositedAmount: ((_b = (_a = deposits.find((d) => d.coinType === depositReserves.lst.coinType)) === null || _a === void 0 ? void 0 : _a.depositedAmount) !== null && _b !== void 0 ? _b : new bignumber_js_1.default(0)).times(-1),
            });
            console.log(`[unloopStrategyToExposure.fullyRepayBorrowsUsingBase] max_withdraw_lst.update_state |`, JSON.stringify({
                deposits: deposits.map((d) => ({
                    coinType: d.coinType,
                    depositedAmount: d.depositedAmount.toFixed(20),
                })),
                borrowedAmount: borrowedAmount.toFixed(20),
            }, null, 2));
            // 1.3) Unstake LST for SUI
            const suiCoin = lst.client.redeem(transaction, withdrawnMaxLstCoin);
            // 1.4) Transfer SUI to user
            transaction.transferObjects([suiCoin], _address);
        }
        // 2) Withdraw base
        const baseWithdrawnAmount = new bignumber_js_1.default(fullRepaymentAmount.times(borrowReserve.price))
            .div(depositReserves.base.price)
            .times(1.03) // 3% buffer
            .decimalPlaces(depositReserves.base.token.decimals, bignumber_js_1.default.ROUND_UP);
        console.log(`[unloopStrategyToExposure.fullyRepayBorrowsUsingBase] withdraw_base |`, JSON.stringify({
            baseWithdrawnAmount: baseWithdrawnAmount.toFixed(20),
        }, null, 2));
        // 2.1) Withdraw
        const [withdrawnBaseCoin] = (0, strategyOwnerCap_1.strategyWithdraw)(depositReserves.base.coinType, strategyOwnerCapId, suilendClient.findReserveArrayIndex(depositReserves.base.coinType), BigInt(new bignumber_js_1.default(baseWithdrawnAmount
            .times(10 ** depositReserves.base.token.decimals)
            .integerValue(bignumber_js_1.default.ROUND_DOWN)
            .toString())
            .div(depositReserves.base.cTokenExchangeRate)
            .integerValue(bignumber_js_1.default.ROUND_UP)
            .toString()), transaction);
        // 2.2) Update state
        deposits = (0, exports.addOrInsertStrategyDeposit)(deposits, {
            coinType: depositReserves.base.coinType,
            depositedAmount: baseWithdrawnAmount.times(-1),
        });
        console.log(`[unloopStrategyToExposure.fullyRepayBorrowsUsingBase] withdraw_base.update_state |`, JSON.stringify({
            deposits: deposits.map((d) => ({
                coinType: d.coinType,
                depositedAmount: d.depositedAmount.toFixed(20),
            })),
            borrowedAmount: borrowedAmount.toFixed(20),
        }, null, 2));
        // 3) Swap base for borrow
        // 3.1) Get routers
        const routers = yield cetusSdk.findRouters({
            from: depositReserves.base.coinType,
            target: borrowReserve.coinType,
            amount: new bn_js_1.BN(baseWithdrawnAmount
                .times(10 ** depositReserves.base.token.decimals)
                .integerValue(bignumber_js_1.default.ROUND_DOWN)
                .toString()),
            byAmountIn: true,
        });
        if (!routers)
            throw new Error("No swap quote found");
        console.log(`[unloopStrategyToExposure.fullyRepayBorrowsUsingBase] swap_base_for_borrows.get_routers`, {
            routers,
            amountIn: new bignumber_js_1.default(routers.amountIn.toString())
                .div(10 ** depositReserves.base.token.decimals)
                .decimalPlaces(depositReserves.base.token.decimals, bignumber_js_1.default.ROUND_DOWN)
                .toFixed(20),
            amountOut: new bignumber_js_1.default(routers.amountOut.toString())
                .div(10 ** borrowReserve.token.decimals)
                .decimalPlaces(borrowReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN)
                .toFixed(20),
        });
        // 3.2) Swap
        let swapCoin;
        try {
            swapCoin = yield cetusSdk.fixableRouterSwapV3({
                router: routers,
                inputCoin: withdrawnBaseCoin,
                slippage: 1 / 100,
                txb: transaction,
                partner: cetusPartnerId,
            });
        }
        catch (err) {
            throw new Error("No swap quote found");
        }
        // 4) Repay borrows
        // 4.1) Repay
        const repaidAmount = fullRepaymentAmount;
        console.log(`[unloopStrategyToExposure.fullyRepayBorrowsUsingBase] repay_borrows.repay |`, JSON.stringify({
            repaidAmount: repaidAmount.toFixed(20),
        }, null, 2));
        try {
            const txCopy = transactions_1.Transaction.from(transaction);
            suilendClient.repay(obligationId, borrowReserve.coinType, swapCoin, txCopy);
            txCopy.transferObjects([swapCoin], _address); // Transfer remaining to user
            yield dryRunTransaction(txCopy); // Throws error if fails
            transaction = txCopy;
        }
        catch (err) {
            // Don't block user if fails
            console.error(err);
            transaction.transferObjects([swapCoin], _address); // Transfer to user
        }
        // 4.2) Update state
        borrowedAmount = bignumber_js_1.default.max(borrowedAmount.minus(repaidAmount), new bignumber_js_1.default(0));
        console.log(`[unloopStrategyToExposure.fullyRepayBorrowsUsingBase] repay_borrows.update_state |`, JSON.stringify({
            deposits: deposits.map((d) => ({
                coinType: d.coinType,
                depositedAmount: d.depositedAmount.toFixed(20),
            })),
            borrowedAmount: borrowedAmount.toFixed(20),
        }, null, 2));
        // 5) Swap remaining to base and redeposit (not possible because coin is a mutable reference (?))
    });
    for (let i = 0; i < 30; i++) {
        const exposure = (0, exports.getStrategyExposure)(reserveMap, lstMap, strategyType, (0, exports.getStrategySimulatedObligation)(reserveMap, lstMap, strategyType, deposits, borrowedAmount));
        const pendingBorrowedAmount = borrowedAmount.minus(targetBorrowedAmount);
        console.log(`[unloopStrategyToExposure] ${i} start |`, JSON.stringify({
            deposits: deposits.map((d) => ({
                coinType: d.coinType,
                depositedAmount: d.depositedAmount.toFixed(20),
            })),
            borrowedAmount: borrowedAmount.toFixed(20),
            exposure: exposure.toFixed(20),
            pendingBorrowedAmount: pendingBorrowedAmount.toFixed(20),
        }, null, 2));
        // Base+LST or LST only
        if (loopingDepositReserve.coinType === ((_c = depositReserves.lst) === null || _c === void 0 ? void 0 : _c.coinType)) {
            // Target: 1x leverage
            if (targetBorrowedAmount.eq(0)) {
                if (pendingBorrowedAmount.lt(0))
                    break; // Fully repaid already
                if (depositReserve.coinType === ((_d = depositReserves.base) === null || _d === void 0 ? void 0 : _d.coinType)) {
                    const lstDeposit = deposits.find((d) => d.coinType === depositReserves.lst.coinType);
                    // Ran out of LST
                    if (lstDeposit.depositedAmount.lte(exports.STRATEGY_E)) {
                        // 1. MAX withdraws LST (transferred to user as SUI)
                        // 2. Withdraws base to cover borrows
                        // - Leftover transferred to user as borrow coinType, e.g. SUI or suiWBTC
                        yield fullyRepayBorrowsUsingBase();
                        break;
                    }
                    // Borrows almost fully repaid
                    if (pendingBorrowedAmount.lte(exports.STRATEGY_E)) {
                        try {
                            // 1. Withdraws LST to cover borrows
                            // - Leftover transferred to user as borrow coinType, e.g. SUI or suiWBTC
                            // 2. MAX withdraws remaining LST and redeposits as base
                            yield fullyRepayBorrowsUsingLst(true);
                            break;
                        }
                        catch (err) {
                            console.error(err);
                        }
                        // 1. MAX withdraws LST (transferred to user as SUI)
                        // 2. Withdraws base to cover borrows
                        // - Leftover transferred to user as borrow coinType, e.g. SUI or suiWBTC
                        yield fullyRepayBorrowsUsingBase();
                        break;
                    }
                }
                else {
                    // Borrows almost fully repaid
                    if (pendingBorrowedAmount.lte(exports.STRATEGY_E)) {
                        // 1. Withdraws LST to cover borrows
                        // - Leftover transferred to user as borrow coinType, e.g. SUI or suiWBTC
                        yield fullyRepayBorrowsUsingLst(false);
                        break;
                    }
                }
            }
            else {
                if (pendingBorrowedAmount.lte(exports.STRATEGY_E))
                    break;
            }
            // 1) Withdraw LST
            // 1.1) Max
            const stepMaxWithdrawnAmount = (0, exports.getStrategyStepMaxWithdrawnAmount)(reserveMap, lstMap, strategyType, deposits, borrowedAmount, loopingDepositReserve.coinType)
                .times(0.9) // 10% buffer
                .decimalPlaces(loopingDepositReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
            const stepMaxRepaidAmount = new bignumber_js_1.default(new bignumber_js_1.default(stepMaxWithdrawnAmount.times((_e = lst === null || lst === void 0 ? void 0 : lst.lstToSuiExchangeRate) !== null && _e !== void 0 ? _e : 1)).minus((0, exports.getStrategyLstRedeemFee)(lstMap, loopingDepositReserve.coinType, stepMaxWithdrawnAmount))).decimalPlaces(borrowReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
            console.log(`[unloopStrategyToExposure] ${i} withdraw_lst.max |`, JSON.stringify({
                stepMaxWithdrawnAmount: stepMaxWithdrawnAmount.toFixed(20),
                stepMaxRepaidAmount: stepMaxRepaidAmount.toFixed(20),
            }, null, 2));
            // 1.2) Withdraw
            const stepWithdrawnAmount = bignumber_js_1.default.min(pendingBorrowedAmount, stepMaxRepaidAmount)
                .times(1 - +((_f = lst === null || lst === void 0 ? void 0 : lst.redeemFeePercent) !== null && _f !== void 0 ? _f : 0) / 100) // Potential rounding issue (max 1 MIST)
                .div((_g = lst === null || lst === void 0 ? void 0 : lst.lstToSuiExchangeRate) !== null && _g !== void 0 ? _g : 1)
                .decimalPlaces(loopingDepositReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
            const isMaxWithdraw = stepWithdrawnAmount.eq(stepMaxWithdrawnAmount);
            console.log(`[unloopStrategyToExposure] ${i} withdraw_lst.withdraw |`, JSON.stringify({
                stepWithdrawnAmount: stepWithdrawnAmount.toFixed(20),
                isMaxWithdraw,
            }, null, 2));
            const [stepWithdrawnCoin] = (0, strategyOwnerCap_1.strategyWithdraw)(loopingDepositReserve.coinType, strategyOwnerCapId, suilendClient.findReserveArrayIndex(loopingDepositReserve.coinType), BigInt(new bignumber_js_1.default(stepWithdrawnAmount
                .times(10 ** loopingDepositReserve.token.decimals)
                .integerValue(bignumber_js_1.default.ROUND_DOWN)
                .toString())
                .div(loopingDepositReserve.cTokenExchangeRate)
                .integerValue(bignumber_js_1.default.ROUND_UP)
                .toString()), transaction);
            // 1.3) Update state
            deposits = (0, exports.addOrInsertStrategyDeposit)(deposits, {
                coinType: loopingDepositReserve.coinType,
                depositedAmount: stepWithdrawnAmount.times(-1),
            });
            console.log(`[unloopStrategyToExposure] ${i} withdraw_lst.update_state |`, JSON.stringify({
                deposits: deposits.map((d) => ({
                    coinType: d.coinType,
                    depositedAmount: d.depositedAmount.toFixed(20),
                })),
                borrowedAmount: borrowedAmount.toFixed(20),
            }, null, 2));
            // 2) Unstake LST for SUI
            const stepSuiCoin = lst.client.redeem(transaction, stepWithdrawnCoin);
            // 3) Repay SUI
            // 3.1) Repay
            const stepRepaidAmount = new bignumber_js_1.default(new bignumber_js_1.default(stepWithdrawnAmount.times((_h = lst === null || lst === void 0 ? void 0 : lst.lstToSuiExchangeRate) !== null && _h !== void 0 ? _h : 1)).minus((0, exports.getStrategyLstRedeemFee)(lstMap, loopingDepositReserve.coinType, stepWithdrawnAmount))).decimalPlaces(borrowReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
            const isMaxRepay = stepRepaidAmount.eq(stepMaxRepaidAmount);
            console.log(`[unloopStrategyToExposure] ${i} repay_sui.repay |`, JSON.stringify({
                stepRepaidAmount: stepRepaidAmount.toFixed(20),
                isMaxRepay,
            }, null, 2));
            try {
                const txCopy = transactions_1.Transaction.from(transaction);
                suilendClient.repay(obligationId, borrowReserve.coinType, stepSuiCoin, txCopy);
                txCopy.transferObjects([stepSuiCoin], _address);
                yield dryRunTransaction(txCopy); // Throws error if fails
                transaction = txCopy;
            }
            catch (err) {
                // Don't block user if fails
                console.error(err);
                transaction.transferObjects([stepSuiCoin], _address);
            }
            // 3.2) Update state
            borrowedAmount = borrowedAmount.minus(stepRepaidAmount);
            console.log(`[unloopStrategyToExposure] ${i} repay_sui.update_state |`, JSON.stringify({
                deposits: deposits.map((d) => ({
                    coinType: d.coinType,
                    depositedAmount: d.depositedAmount.toFixed(20),
                })),
                borrowedAmount: borrowedAmount.toFixed(20),
            }, null, 2));
        }
        // Base only
        else if (loopingDepositReserve.coinType === ((_j = depositReserves.base) === null || _j === void 0 ? void 0 : _j.coinType)) {
            const exchangeRateRouters = yield cetusSdk.findRouters({
                from: loopingDepositReserve.coinType,
                target: borrowReserve.coinType,
                amount: new bn_js_1.BN(new bignumber_js_1.default(0.1)
                    .times(10 ** loopingDepositReserve.token.decimals)
                    .integerValue(bignumber_js_1.default.ROUND_DOWN)
                    .toString()),
                byAmountIn: true,
                splitCount: 0, // Use direct swap to avoid split algo
            });
            if (!exchangeRateRouters)
                throw new Error("No swap quote found");
            const baseToBorrowExchangeRate = new bignumber_js_1.default(new bignumber_js_1.default(exchangeRateRouters.amountOut.toString()).div(10 ** borrowReserve.token.decimals)).div(new bignumber_js_1.default(exchangeRateRouters.amountIn.toString()).div(10 ** loopingDepositReserve.token.decimals));
            // Target: 1x leverage
            if (targetBorrowedAmount.eq(0)) {
                if (pendingBorrowedAmount.lt(0))
                    break; // Fully repaid already
                // Borrows almost fully repaid
                if (pendingBorrowedAmount.lte(exports.STRATEGY_E)) {
                    // 1. Withdraws base to cover borrows
                    // - Leftover transferred to user as borrow coinType, e.g. SUI or suiWBTC
                    yield fullyRepayBorrowsUsingBase();
                    break;
                }
            }
            else {
                if (pendingBorrowedAmount.lte(exports.STRATEGY_E))
                    break;
            }
            // 1) Withdraw base
            // 1.1) Max
            const stepMaxWithdrawnAmount = (0, exports.getStrategyStepMaxWithdrawnAmount)(reserveMap, lstMap, strategyType, deposits, borrowedAmount, loopingDepositReserve.coinType)
                .times(0.9) // 10% buffer
                .decimalPlaces(loopingDepositReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
            const stepMaxRepaidAmount = new bignumber_js_1.default(stepMaxWithdrawnAmount.times(baseToBorrowExchangeRate)).decimalPlaces(borrowReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
            console.log(`[unloopStrategyToExposure] ${i} withdraw_base.max |`, JSON.stringify({
                stepMaxWithdrawnAmount: stepMaxWithdrawnAmount.toFixed(20),
                stepMaxRepaidAmount: stepMaxRepaidAmount.toFixed(20),
            }, null, 2));
            // 1.2) Withdraw
            const stepWithdrawnAmount = bignumber_js_1.default.min(pendingBorrowedAmount, stepMaxRepaidAmount)
                .div(baseToBorrowExchangeRate)
                .decimalPlaces(loopingDepositReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
            const isMaxWithdraw = stepWithdrawnAmount.eq(stepMaxWithdrawnAmount);
            console.log(`[unloopStrategyToExposure] ${i} withdraw_base.withdraw |`, JSON.stringify({
                stepWithdrawnAmount: stepWithdrawnAmount.toFixed(20),
                isMaxWithdraw,
            }, null, 2));
            const [stepWithdrawnCoin] = (0, strategyOwnerCap_1.strategyWithdraw)(loopingDepositReserve.coinType, strategyOwnerCapId, suilendClient.findReserveArrayIndex(loopingDepositReserve.coinType), BigInt(new bignumber_js_1.default(stepWithdrawnAmount
                .times(10 ** loopingDepositReserve.token.decimals)
                .integerValue(bignumber_js_1.default.ROUND_DOWN)
                .toString())
                .div(loopingDepositReserve.cTokenExchangeRate)
                .integerValue(bignumber_js_1.default.ROUND_UP)
                .toString()), transaction);
            // 1.3) Update state
            deposits = (0, exports.addOrInsertStrategyDeposit)(deposits, {
                coinType: loopingDepositReserve.coinType,
                depositedAmount: stepWithdrawnAmount.times(-1),
            });
            console.log(`[unloopStrategyToExposure] ${i} withdraw_base.update_state |`, JSON.stringify({
                deposits: deposits.map((d) => ({
                    coinType: d.coinType,
                    depositedAmount: d.depositedAmount.toFixed(20),
                })),
                borrowedAmount: borrowedAmount.toFixed(20),
            }, null, 2));
            // 2) Swap base for borrows
            const routers = yield cetusSdk.findRouters({
                from: loopingDepositReserve.coinType,
                target: borrowReserve.coinType,
                amount: new bn_js_1.BN(stepWithdrawnAmount
                    .times(10 ** loopingDepositReserve.token.decimals)
                    .integerValue(bignumber_js_1.default.ROUND_DOWN)
                    .toString()), // Estimate for loop 2 onwards (don't know exact out amount, we are not accounting for swap fees, etc)
                byAmountIn: true,
                splitCount: 0, // Use direct swap to avoid split algo
            });
            if (!routers)
                throw new Error("No swap quote found");
            const slippagePercent = 1;
            let stepBorrowCoin;
            try {
                stepBorrowCoin = yield cetusSdk.fixableRouterSwapV3({
                    router: routers,
                    inputCoin: stepWithdrawnCoin,
                    slippage: slippagePercent / 100,
                    txb: transaction,
                    partner: cetusPartnerId,
                });
            }
            catch (err) {
                throw new Error("No swap quote found");
            }
            console.log(`[unloopStrategyToExposure] ${i} swap_base_for_borrows |`, JSON.stringify({
                inCoinType: loopingDepositReserve.coinType,
                outCoinType: borrowReserve.coinType,
                amountIn: stepWithdrawnAmount.toFixed(20),
                amountOut: new bignumber_js_1.default(routers.amountOut.toString())
                    .div(10 ** borrowReserve.token.decimals)
                    .decimalPlaces(borrowReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN)
                    .toFixed(20),
            }, null, 2), routers);
            // 3) Repay borrows
            // 3.1) Repay
            const stepRepaidAmount = new bignumber_js_1.default(new bignumber_js_1.default(routers.amountOut.toString()).div(10 ** borrowReserve.token.decimals)).decimalPlaces(borrowReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
            const isMaxRepay = stepRepaidAmount.eq(stepMaxRepaidAmount);
            console.log(`[unloopStrategyToExposure] ${i} repay_borrows.repay |`, JSON.stringify({
                stepRepaidAmount: stepRepaidAmount.toFixed(20),
                isMaxRepay,
            }, null, 2));
            try {
                const txCopy = transactions_1.Transaction.from(transaction);
                suilendClient.repay(obligationId, borrowReserve.coinType, stepBorrowCoin, txCopy);
                txCopy.transferObjects([stepBorrowCoin], _address);
                yield dryRunTransaction(txCopy); // Throws error if fails
                transaction = txCopy;
            }
            catch (err) {
                // Don't block user if fails
                console.error(err);
                transaction.transferObjects([stepBorrowCoin], _address);
            }
            // 3.2) Update state
            borrowedAmount = borrowedAmount.minus(stepRepaidAmount);
            console.log(`[unloopStrategyToExposure] ${i} repay_borrows.update_state |`, JSON.stringify({
                deposits: deposits.map((d) => ({
                    coinType: d.coinType,
                    depositedAmount: d.depositedAmount.toFixed(20),
                })),
                borrowedAmount: borrowedAmount.toFixed(20),
            }, null, 2));
        }
        else {
            throw new Error("No LST or base reserve found"); // Should not happen
        }
    }
    return { deposits, borrowedAmount, transaction };
});
exports.strategyUnloopToExposureTx = strategyUnloopToExposureTx;
const strategyDepositTx = (
// AppContext
reserveMap, 
// Strategy
lstMap, strategyType, suiClient, suilendClient, cetusSdk, cetusPartnerId, _address, strategyOwnerCapId, obligationId, _deposits, _borrowedAmount, deposit, transaction, dryRunTransaction) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c;
    const strategyInfo = strategyOwnerCap_1.STRATEGY_TYPE_INFO_MAP[strategyType];
    const lst = strategyInfo.depositLstCoinType !== undefined
        ? lstMap[strategyInfo.depositLstCoinType]
        : undefined;
    const depositReserves = (0, exports.getStrategyDepositReserves)(reserveMap, strategyType);
    const borrowReserve = (0, exports.getStrategyBorrowReserve)(reserveMap, strategyType);
    const defaultCurrencyReserve = (0, exports.getStrategyDefaultCurrencyReserve)(reserveMap, strategyType);
    console.log(`[strategyDepositTx] args |`, JSON.stringify({
        _address,
        strategyOwnerCapId,
        obligationId,
        _deposits: _deposits.map((d) => ({
            coinType: d.coinType,
            depositedAmount: d.depositedAmount.toFixed(20),
        })),
        _borrowedAmount: _borrowedAmount.toFixed(20),
        deposit: {
            coinType: deposit.coinType,
            depositedAmount: deposit.depositedAmount.toFixed(20),
        },
    }, null, 2));
    const depositReserve = ((_a = depositReserves.base) !== null && _a !== void 0 ? _a : depositReserves.lst); // Must have LST if no base
    //
    let deposits = (0, lodash_1.cloneDeep)(_deposits);
    const borrowedAmount = _borrowedAmount;
    // 1) Deposit
    // 1.1) SUI
    if ((0, sui_fe_1.isSui)(deposit.coinType)) {
        if (depositReserves.lst === undefined)
            throw new Error("LST reserve not found");
        const suiAmount = deposit.depositedAmount;
        const lstAmount = new bignumber_js_1.default(suiAmount
            .minus((0, exports.getStrategyLstMintFee)(lstMap, depositReserves.lst.coinType, suiAmount))
            .times((_b = lst === null || lst === void 0 ? void 0 : lst.suiToLstExchangeRate) !== null && _b !== void 0 ? _b : 1)).decimalPlaces(exports.LST_DECIMALS, bignumber_js_1.default.ROUND_DOWN);
        // 1.1.1) Split coins
        const suiCoin = transaction.splitCoins(transaction.gas, [
            suiAmount
                .times(10 ** utils_1.SUI_DECIMALS)
                .integerValue(bignumber_js_1.default.ROUND_DOWN)
                .toString(),
        ]);
        // 1.1.2) Stake SUI for LST
        const lstCoin = lst.client.mint(transaction, suiCoin);
        // 1.1.3) Deposit LST (1x exposure)
        (0, strategyOwnerCap_1.strategyDeposit)(lstCoin, depositReserves.lst.coinType, strategyOwnerCapId, suilendClient.findReserveArrayIndex(depositReserves.lst.coinType), transaction);
        // 1.1.4) Update state
        deposits = (0, exports.addOrInsertStrategyDeposit)(deposits, {
            coinType: depositReserves.lst.coinType,
            depositedAmount: lstAmount,
        });
    }
    // 1.2) LST
    else if (deposit.coinType === ((_c = depositReserves.lst) === null || _c === void 0 ? void 0 : _c.coinType)) {
        // 1.2.1) Split coins
        const allCoinsLst = yield (0, sui_fe_1.getAllCoins)(suiClient, _address, depositReserves.lst.coinType);
        const mergeCoinLst = (0, sui_fe_1.mergeAllCoins)(depositReserves.lst.coinType, transaction, allCoinsLst);
        const lstCoin = transaction.splitCoins(transaction.object(mergeCoinLst.coinObjectId), [
            BigInt(deposit.depositedAmount
                .times(10 ** exports.LST_DECIMALS)
                .integerValue(bignumber_js_1.default.ROUND_DOWN)
                .toString()),
        ]);
        // 1.2.2) Deposit LST (1x exposure)
        (0, strategyOwnerCap_1.strategyDeposit)(lstCoin, depositReserves.lst.coinType, strategyOwnerCapId, suilendClient.findReserveArrayIndex(depositReserves.lst.coinType), transaction);
        // 1.2.3) Update state
        deposits = (0, exports.addOrInsertStrategyDeposit)(deposits, deposit);
        // 1.3) Other
    }
    else {
        const otherReserve = reserveMap[deposit.coinType];
        // 1.3.1) Split coins
        const allCoinsOther = yield (0, sui_fe_1.getAllCoins)(suiClient, _address, otherReserve.coinType);
        const mergeCoinOther = (0, sui_fe_1.mergeAllCoins)(otherReserve.coinType, transaction, allCoinsOther);
        const otherCoin = transaction.splitCoins(transaction.object(mergeCoinOther.coinObjectId), [
            BigInt(deposit.depositedAmount
                .times(10 ** otherReserve.token.decimals)
                .integerValue(bignumber_js_1.default.ROUND_DOWN)
                .toString()),
        ]);
        // 1.3.2) Deposit other (1x exposure)
        (0, strategyOwnerCap_1.strategyDeposit)(otherCoin, otherReserve.coinType, strategyOwnerCapId, suilendClient.findReserveArrayIndex(otherReserve.coinType), transaction);
        // 1.3.3) Update state
        deposits = (0, exports.addOrInsertStrategyDeposit)(deposits, deposit);
    }
    console.log(`[deposit] deposit |`, JSON.stringify({
        deposits: deposits.map((d) => ({
            coinType: d.coinType,
            depositedAmount: d.depositedAmount.toFixed(20),
        })),
        borrowedAmount: borrowedAmount.toFixed(20),
    }, null, 2));
    return { deposits, borrowedAmount, transaction };
});
exports.strategyDepositTx = strategyDepositTx;
const strategyDepositAndLoopToExposureTx = (
// AppContext
reserveMap, 
// Strategy
lstMap, strategyType, suiClient, suilendClient, cetusSdk, cetusPartnerId, _address, strategyOwnerCapId, obligationId, _deposits, _borrowedAmount, deposit, targetExposure, transaction, dryRunTransaction) => __awaiter(void 0, void 0, void 0, function* () {
    const strategyInfo = strategyOwnerCap_1.STRATEGY_TYPE_INFO_MAP[strategyType];
    const lst = strategyInfo.depositLstCoinType !== undefined
        ? lstMap[strategyInfo.depositLstCoinType]
        : undefined;
    const depositReserves = (0, exports.getStrategyDepositReserves)(reserveMap, strategyType);
    const borrowReserve = (0, exports.getStrategyBorrowReserve)(reserveMap, strategyType);
    const defaultCurrencyReserve = (0, exports.getStrategyDefaultCurrencyReserve)(reserveMap, strategyType);
    console.log(`[depositAndLoopToExposure] args |`, JSON.stringify({
        _address,
        strategyOwnerCapId,
        obligationId,
        _deposits: _deposits.map((d) => ({
            coinType: d.coinType,
            depositedAmount: d.depositedAmount.toFixed(20),
        })),
        _borrowedAmount: _borrowedAmount.toFixed(20),
        deposit: {
            coinType: deposit.coinType,
            depositedAmount: deposit.depositedAmount.toFixed(20),
        },
        targetExposure: targetExposure.toFixed(20),
    }, null, 2));
    //
    let deposits = (0, lodash_1.cloneDeep)(_deposits);
    let borrowedAmount = _borrowedAmount;
    // 1) Deposit (1x exposure)
    // 1.1) Deposit
    const { deposits: newDeposits, borrowedAmount: newBorrowedAmount, transaction: newTransaction, } = yield (0, exports.strategyDepositTx)(reserveMap, lstMap, strategyType, suiClient, suilendClient, cetusSdk, cetusPartnerId, _address, strategyOwnerCapId, obligationId, deposits, borrowedAmount, deposit, transaction, dryRunTransaction);
    // 1.2) Update state
    deposits = newDeposits;
    borrowedAmount = newBorrowedAmount;
    transaction = newTransaction;
    if (targetExposure.gt(1)) {
        // 2) Loop to target exposure
        // 2.1) Loop
        const { deposits: newDeposits2, borrowedAmount: newBorrowedAmount2, transaction: newTransaction2, } = yield (0, exports.strategyLoopToExposureTx)(reserveMap, lstMap, strategyType, suiClient, suilendClient, cetusSdk, cetusPartnerId, _address, strategyOwnerCapId, obligationId, deposits, borrowedAmount, undefined, // Don't pass targetBorrowedAmount
        targetExposure, // Pass targetExposure
        transaction);
        // 2.2) Update state
        deposits = newDeposits2;
        borrowedAmount = newBorrowedAmount2;
        transaction = newTransaction2;
    }
    return { deposits, borrowedAmount, transaction };
});
exports.strategyDepositAndLoopToExposureTx = strategyDepositAndLoopToExposureTx;
const strategyWithdrawTx = (
// AppContext
reserveMap, 
// Strategy
lstMap, strategyType, suiClient, suilendClient, cetusSdk, cetusPartnerId, _address, strategyOwnerCapId, obligationId, _deposits, _borrowedAmount, withdraw, transaction, dryRunTransaction, returnWithdrawnCoin) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const strategyInfo = strategyOwnerCap_1.STRATEGY_TYPE_INFO_MAP[strategyType];
    const lst = strategyInfo.depositLstCoinType !== undefined
        ? lstMap[strategyInfo.depositLstCoinType]
        : undefined;
    const depositReserves = (0, exports.getStrategyDepositReserves)(reserveMap, strategyType);
    const borrowReserve = (0, exports.getStrategyBorrowReserve)(reserveMap, strategyType);
    const defaultCurrencyReserve = (0, exports.getStrategyDefaultCurrencyReserve)(reserveMap, strategyType);
    console.log(`[strategyWithdraw] args |`, JSON.stringify({
        _address,
        strategyOwnerCapId,
        obligationId,
        _deposits: _deposits.map((d) => ({
            coinType: d.coinType,
            depositedAmount: d.depositedAmount.toFixed(20),
        })),
        _borrowedAmount: _borrowedAmount.toFixed(20),
        withdraw: {
            coinType: withdraw.coinType,
            withdrawnAmount: withdraw.withdrawnAmount.toFixed(20),
        },
        returnWithdrawnCoin,
    }, null, 2));
    const depositReserve = ((_a = depositReserves.base) !== null && _a !== void 0 ? _a : depositReserves.lst); // Must have LST if no base
    //
    let deposits = (0, lodash_1.cloneDeep)(_deposits);
    let borrowedAmount = _borrowedAmount;
    const withdrawnAmount = (depositReserve.coinType === ((_b = depositReserves.base) === null || _b === void 0 ? void 0 : _b.coinType)
        ? withdraw.withdrawnAmount
        : (0, sui_fe_1.isSui)(withdraw.coinType)
            ? withdraw.withdrawnAmount
                .div(1 - +((_c = lst === null || lst === void 0 ? void 0 : lst.redeemFeePercent) !== null && _c !== void 0 ? _c : 0) / 100) // Potential rounding issue (max 1 MIST)
                .div((_d = lst === null || lst === void 0 ? void 0 : lst.lstToSuiExchangeRate) !== null && _d !== void 0 ? _d : 1)
            : withdraw.withdrawnAmount).decimalPlaces(depositReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
    const withdrawnAmountUsd = withdrawnAmount
        .times(depositReserve.price)
        .times(depositReserve.coinType === ((_e = depositReserves.base) === null || _e === void 0 ? void 0 : _e.coinType)
        ? 1
        : new bignumber_js_1.default((_f = lst === null || lst === void 0 ? void 0 : lst.lstToSuiExchangeRate) !== null && _f !== void 0 ? _f : 1).times(1 - +((_g = lst === null || lst === void 0 ? void 0 : lst.redeemFeePercent) !== null && _g !== void 0 ? _g : 0) / 100));
    const exposure = (0, exports.getStrategyExposure)(reserveMap, lstMap, strategyType, (0, exports.getStrategySimulatedObligation)(reserveMap, lstMap, strategyType, deposits, borrowedAmount));
    const tvlAmountUsd = (0, exports.getStrategyTvlAmount)(reserveMap, lstMap, strategyType, (0, exports.getStrategySimulatedObligation)(reserveMap, lstMap, strategyType, deposits, borrowedAmount)).times(defaultCurrencyReserve.price);
    const targetTvlAmountUsd = tvlAmountUsd.minus(withdrawnAmountUsd);
    const targetBorrowedAmount = targetTvlAmountUsd
        .times(exposure.minus(1))
        .div(borrowReserve.price)
        .decimalPlaces(borrowReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
    console.log(`[withdraw] processed_args |`, JSON.stringify({
        depositReserve_coinType: depositReserve.coinType,
        withdrawnAmount: withdrawnAmount.toFixed(20),
        withdrawnAmountUsd: withdrawnAmountUsd.toFixed(20),
        exposure: exposure.toFixed(20),
        tvlAmountUsd: tvlAmountUsd.toFixed(20),
        targetTvlAmountUsd: targetTvlAmountUsd.toFixed(20),
        targetBorrowedAmount: targetBorrowedAmount.toFixed(20),
    }, null, 2));
    // 1) Unloop to targetBorrowedAmount borrows
    // 1.1) Unloop
    if (borrowedAmount.gt(targetBorrowedAmount)) {
        const { deposits: newDeposits, borrowedAmount: newBorrowedAmount, transaction: newTransaction, } = yield (0, exports.strategyUnloopToExposureTx)(reserveMap, lstMap, strategyType, suiClient, suilendClient, cetusSdk, cetusPartnerId, _address, strategyOwnerCapId, obligationId, deposits, borrowedAmount, targetBorrowedAmount, // Pass targetBorrowedAmount
        undefined, // Don't pass targetExposure
        transaction, dryRunTransaction);
        // 1.2) Update state
        deposits = newDeposits;
        borrowedAmount = newBorrowedAmount;
        transaction = newTransaction;
        console.log(`[withdraw] unloop.update_state |`, JSON.stringify({
            deposits: deposits.map((d) => ({
                coinType: d.coinType,
                depositedAmount: d.depositedAmount.toFixed(20),
            })),
            borrowedAmount: borrowedAmount.toFixed(20),
            targetBorrowedAmount: targetBorrowedAmount.toFixed(20),
        }, null, 2));
    }
    // 2) Withdraw base or LST
    // 2.1) Withdraw
    const [withdrawnCoin] = (0, strategyOwnerCap_1.strategyWithdraw)(depositReserve.coinType, strategyOwnerCapId, suilendClient.findReserveArrayIndex(depositReserve.coinType), BigInt(new bignumber_js_1.default(withdrawnAmount
        .times(10 ** depositReserve.token.decimals)
        .integerValue(bignumber_js_1.default.ROUND_DOWN)
        .toString())
        .div(depositReserve.cTokenExchangeRate)
        .integerValue(bignumber_js_1.default.ROUND_UP)
        .toString()), transaction);
    // 2.2) Update state
    deposits = (0, exports.addOrInsertStrategyDeposit)(deposits, {
        coinType: depositReserve.coinType,
        depositedAmount: withdrawnAmount.times(-1),
    });
    const newExposure = (0, exports.getStrategyExposure)(reserveMap, lstMap, strategyType, (0, exports.getStrategySimulatedObligation)(reserveMap, lstMap, strategyType, deposits, borrowedAmount));
    const newTvlAmountUsd = (0, exports.getStrategyTvlAmount)(reserveMap, lstMap, strategyType, (0, exports.getStrategySimulatedObligation)(reserveMap, lstMap, strategyType, deposits, borrowedAmount)).times(defaultCurrencyReserve.price);
    console.log(`[withdraw] withdraw.update_state |`, JSON.stringify({
        deposits: deposits.map((d) => ({
            coinType: d.coinType,
            depositedAmount: d.depositedAmount.toFixed(20),
        })),
        borrowedAmount: borrowedAmount.toFixed(20),
        exposure: exposure.toFixed(20),
        newExposure: newExposure.toFixed(20),
        tvlAmountUsd: tvlAmountUsd.toFixed(20),
        targetTvlAmountUsd: targetTvlAmountUsd.toFixed(20),
        newTvlAmountUsd: newTvlAmountUsd.toFixed(20),
    }, null, 2));
    // 3) Transfer coin to user, or return coin
    if (returnWithdrawnCoin)
        return { deposits, borrowedAmount, transaction, withdrawnCoin };
    else {
        if (depositReserve.coinType === ((_h = depositReserves.base) === null || _h === void 0 ? void 0 : _h.coinType)) {
            // 3.1) Transfer base to user
            transaction.transferObjects([withdrawnCoin], _address);
        }
        else {
            if ((0, sui_fe_1.isSui)(withdraw.coinType)) {
                // 3.1) Unstake LST for SUI
                const suiWithdrawnCoin = lst.client.redeem(transaction, withdrawnCoin);
                // 3.2) Transfer SUI to user
                transaction.transferObjects([suiWithdrawnCoin], _address);
            }
            else {
                // 3.1) Transfer LST to user
                transaction.transferObjects([withdrawnCoin], _address);
            }
        }
    }
    return { deposits, borrowedAmount, transaction };
});
exports.strategyWithdrawTx = strategyWithdrawTx;
const strategyMaxWithdrawTx = (
// AppContext
reserveMap, rewardPriceMap, rewardsMap, 
// Strategy
lstMap, strategyType, suiClient, suilendClient, cetusSdk, cetusPartnerId, _address, strategyOwnerCapId, obligationId, _deposits, _borrowedAmount, withdrawCoinType, transaction, dryRunTransaction) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    const strategyInfo = strategyOwnerCap_1.STRATEGY_TYPE_INFO_MAP[strategyType];
    const lst = strategyInfo.depositLstCoinType !== undefined
        ? lstMap[strategyInfo.depositLstCoinType]
        : undefined;
    const depositReserves = (0, exports.getStrategyDepositReserves)(reserveMap, strategyType);
    const borrowReserve = (0, exports.getStrategyBorrowReserve)(reserveMap, strategyType);
    const defaultCurrencyReserve = (0, exports.getStrategyDefaultCurrencyReserve)(reserveMap, strategyType);
    const hasClaimableRewards = Object.values(rewardsMap).some(({ amount }) => amount.gt(0));
    console.log(`[strategyMaxWithdraw] args |`, JSON.stringify({
        _address,
        strategyOwnerCapId,
        obligationId,
        _deposits: _deposits.map((d) => ({
            coinType: d.coinType,
            depositedAmount: d.depositedAmount.toFixed(20),
        })),
        _borrowedAmount: _borrowedAmount.toFixed(20),
        withdrawCoinType,
    }, null, 2));
    const depositReserve = ((_a = depositReserves.base) !== null && _a !== void 0 ? _a : depositReserves.lst); // Must have LST if no base
    //
    let deposits = (0, lodash_1.cloneDeep)(_deposits);
    let borrowedAmount = _borrowedAmount;
    // 1) Unloop to 1x (base+LST: no LST and no borrows, LST: no borrows)
    if (borrowedAmount.gt(0)) {
        // 1.1) Unloop
        const { deposits: newDeposits, borrowedAmount: newBorrowedAmount, transaction: newTransaction, } = yield (0, exports.strategyUnloopToExposureTx)(reserveMap, lstMap, strategyType, suiClient, suilendClient, cetusSdk, cetusPartnerId, _address, strategyOwnerCapId, obligationId, deposits, borrowedAmount, undefined, // Don't pass targetBorrowedAmount
        new bignumber_js_1.default(1), // Pass targetExposure
        transaction, dryRunTransaction);
        // 1.2) Update state
        deposits = newDeposits;
        borrowedAmount = newBorrowedAmount;
        transaction = newTransaction;
        console.log(`[strategyMaxWithdraw] unloop.update_state |`, JSON.stringify({
            deposits: deposits.map((d) => ({
                coinType: d.coinType,
                depositedAmount: d.depositedAmount.toFixed(20),
            })),
            borrowedAmount: borrowedAmount.toFixed(20),
        }, null, 2));
    }
    // 2) MAX withdraw base or LST
    const [withdrawnCoin] = (0, strategyOwnerCap_1.strategyWithdraw)(depositReserve.coinType, strategyOwnerCapId, suilendClient.findReserveArrayIndex(depositReserve.coinType), BigInt(sui_fe_1.MAX_U64.toString()), transaction);
    // 2.2) Update state
    deposits = [];
    console.log(`[strategyMaxWithdraw] max_withdraw.update_state |`, JSON.stringify({
        deposits: deposits.map((d) => ({
            coinType: d.coinType,
            depositedAmount: d.depositedAmount.toFixed(20),
        })),
        borrowedAmount: borrowedAmount.toFixed(20),
    }, null, 2));
    // 3) Transfer coin to user
    if (depositReserve.coinType === ((_b = depositReserves.base) === null || _b === void 0 ? void 0 : _b.coinType)) {
        // 3.1) Transfer base to user
        transaction.transferObjects([withdrawnCoin], _address);
    }
    else {
        if ((0, sui_fe_1.isSui)(withdrawCoinType)) {
            // 3.1) Unstake LST for SUI
            const suiWithdrawnCoin = lst.client.redeem(transaction, withdrawnCoin);
            // 3.2) Transfer SUI to user
            transaction.transferObjects([suiWithdrawnCoin], _address);
        }
        else {
            // 3.1) Transfer LST to user
            transaction.transferObjects([withdrawnCoin], _address);
        }
    }
    // 4) Claim rewards, swap for withdrawCoinType, and transfer to user
    if (hasClaimableRewards) {
        try {
            const txCopy = transactions_1.Transaction.from(transaction);
            yield (0, strategyOwnerCap_1.strategyClaimRewardsAndSwapForCoinType)(_address, cetusSdk, cetusPartnerId, rewardsMap, rewardPriceMap, reserveMap[withdrawCoinType], strategyOwnerCapId, false, // isDepositing (false = transfer to user)
            txCopy);
            yield dryRunTransaction(txCopy); // Throws error if fails
            transaction = txCopy;
        }
        catch (err) {
            // Don't block user if fails
            console.error(err);
        }
    }
    return { deposits, borrowedAmount, transaction };
});
exports.strategyMaxWithdrawTx = strategyMaxWithdrawTx;
const strategyAdjustRepayTx = (
// AppContext
reserveMap, 
// Strategy
lstMap, strategyType, suiClient, suilendClient, cetusSdk, cetusPartnerId, _address, strategyOwnerCapId, obligationId, _deposits, _borrowedAmount, flashLoanBorrowedAmount, transaction, dryRunTransaction) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d;
    const strategyInfo = strategyOwnerCap_1.STRATEGY_TYPE_INFO_MAP[strategyType];
    const lst = strategyInfo.depositLstCoinType !== undefined
        ? lstMap[strategyInfo.depositLstCoinType]
        : undefined;
    const depositReserves = (0, exports.getStrategyDepositReserves)(reserveMap, strategyType);
    const borrowReserve = (0, exports.getStrategyBorrowReserve)(reserveMap, strategyType);
    const defaultCurrencyReserve = (0, exports.getStrategyDefaultCurrencyReserve)(reserveMap, strategyType);
    const adjustRepayExposure = exports.STRATEGY_TYPE_EXPOSURE_MAP[strategyType].min;
    console.log(`[strategyAdjustRepay] args |`, JSON.stringify({
        _address,
        strategyOwnerCapId,
        obligationId,
        _deposits: _deposits.map((d) => ({
            coinType: d.coinType,
            depositedAmount: d.depositedAmount.toFixed(20),
        })),
        _borrowedAmount: _borrowedAmount.toFixed(20),
        flashLoanBorrowedAmount: flashLoanBorrowedAmount.toFixed(20),
    }, null, 2));
    // const depositReserve = (depositReserves.base ?? depositReserves.lst)!; // Must have LST if no base
    if (!depositReserves.base)
        throw new Error("Base reserve not found");
    //
    let deposits = (0, lodash_1.cloneDeep)(_deposits);
    let borrowedAmount = _borrowedAmount;
    // 1) Flash loan base
    const flashLoanObj = exports.STRATEGY_TYPE_FLASH_LOAN_OBJ_MAP[strategyType];
    let borrowedBalanceA, borrowedBalanceB, receipt;
    if (flashLoanObj.provider === StrategyFlashLoanProvider.MMT) {
        [borrowedBalanceA, borrowedBalanceB, receipt] = transaction.moveCall({
            target: `${mmt_1.MMT_CONTRACT_PACKAGE_ID}::trade::flash_loan`,
            typeArguments: [flashLoanObj.coinTypeA, flashLoanObj.coinTypeB],
            arguments: [
                transaction.object(flashLoanObj.poolId),
                transaction.pure.u64(flashLoanObj.borrowA
                    ? flashLoanBorrowedAmount
                        .times(10 ** depositReserves.base.token.decimals)
                        .integerValue(bignumber_js_1.default.ROUND_DOWN)
                        .toString()
                    : 0),
                transaction.pure.u64(flashLoanObj.borrowA
                    ? 0
                    : flashLoanBorrowedAmount
                        .times(10 ** depositReserves.base.token.decimals)
                        .integerValue(bignumber_js_1.default.ROUND_DOWN)
                        .toString()),
                transaction.object(mmt_1.MMT_VERSION_OBJECT_ID),
            ],
        });
    }
    else {
        throw new Error("Invalid flash loan provider");
    }
    const flashLoanBorrowedCoin = transaction.moveCall({
        target: "0x2::coin::from_balance",
        typeArguments: [
            flashLoanObj.borrowA ? flashLoanObj.coinTypeA : flashLoanObj.coinTypeB,
        ],
        arguments: [flashLoanObj.borrowA ? borrowedBalanceA : borrowedBalanceB],
    });
    // 2) Swap flash loaned base for borrow
    // 2.1) Get routers
    const routers = yield cetusSdk.findRouters({
        from: depositReserves.base.coinType,
        target: borrowReserve.coinType,
        amount: new bn_js_1.BN(flashLoanBorrowedAmount
            .times(10 ** depositReserves.base.token.decimals)
            .integerValue(bignumber_js_1.default.ROUND_DOWN)
            .toString()),
        byAmountIn: true,
    });
    if (!routers)
        throw new Error("No swap quote found");
    console.log(`[strategyAdjustRepay] swap_flash_loan_base_for_borrows.get_routers`, {
        routers,
        amountIn: new bignumber_js_1.default(routers.amountIn.toString())
            .div(10 ** depositReserves.base.token.decimals)
            .decimalPlaces(depositReserves.base.token.decimals, bignumber_js_1.default.ROUND_DOWN)
            .toFixed(20),
        amountOut: new bignumber_js_1.default(routers.amountOut.toString())
            .div(10 ** borrowReserve.token.decimals)
            .decimalPlaces(borrowReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN)
            .toFixed(20),
    });
    // 2.2) Swap
    let swapCoin;
    try {
        swapCoin = yield cetusSdk.fixableRouterSwapV3({
            router: routers,
            inputCoin: flashLoanBorrowedCoin,
            slippage: 1 / 100,
            txb: transaction,
            partner: cetusPartnerId,
        });
    }
    catch (err) {
        throw new Error("No swap quote found");
    }
    // 3) Fully repay borrows
    // 3.1) Repay
    suilendClient.repay(obligationId, borrowReserve.coinType, swapCoin, transaction);
    transaction.transferObjects([swapCoin], _address); // Transfer remaining to user
    // 3.2) Update state
    borrowedAmount = new bignumber_js_1.default(0);
    console.log(`[strategyAdjustRepay] repay_borrows.update_state |`, JSON.stringify({
        deposits: deposits.map((d) => ({
            coinType: d.coinType,
            depositedAmount: d.depositedAmount.toFixed(20),
        })),
        borrowedAmount: borrowedAmount.toFixed(20),
    }, null, 2));
    // 4) Swap remaining to base and redeposit (not possible because coin is a mutable reference (?))
    // 5) Repay flash loan + fee
    const receiptDebts = transaction.moveCall({
        target: `${mmt_1.MMT_CONTRACT_PACKAGE_ID}::trade::flash_receipt_debts`,
        typeArguments: [],
        arguments: [receipt],
    });
    const dryRunResults = yield dryRunTransaction(transaction);
    const flashLoanRepayAmount = new bignumber_js_1.default(bcs_1.bcs
        .u64()
        .parse(new Uint8Array((_d = (_c = (_b = (_a = dryRunResults.results) === null || _a === void 0 ? void 0 : _a.find((r, index) => index === receiptDebts.Result)) === null || _b === void 0 ? void 0 : _b.returnValues) === null || _c === void 0 ? void 0 : _c[flashLoanObj.borrowA ? 0 : 1][0]) !== null && _d !== void 0 ? _d : [0])))
        .div(10 ** depositReserves.base.token.decimals)
        .decimalPlaces(depositReserves.base.token.decimals, bignumber_js_1.default.ROUND_UP);
    // 5.1) Withdraw base + fee
    const withdrawnAmount = flashLoanRepayAmount;
    const { deposits: newDeposits2, borrowedAmount: newBorrowedAmount2, transaction: newTransaction2, withdrawnCoin, } = yield (0, exports.strategyWithdrawTx)(reserveMap, lstMap, strategyType, suiClient, suilendClient, cetusSdk, cetusPartnerId, _address, strategyOwnerCapId, obligationId, deposits, borrowedAmount, {
        coinType: depositReserves.base.coinType,
        withdrawnAmount,
    }, transaction, dryRunTransaction, true);
    if (!withdrawnCoin)
        throw new Error("Withdrawn coin not found");
    // 5.2) Update state
    deposits = newDeposits2;
    borrowedAmount = newBorrowedAmount2;
    transaction = newTransaction2;
    // 5.3) Repay flash loan
    const flashLoanRepayCoin = withdrawnCoin;
    const flashLoanRepayBalance = transaction.moveCall({
        target: "0x2::coin::into_balance",
        typeArguments: [
            flashLoanObj.borrowA ? flashLoanObj.coinTypeA : flashLoanObj.coinTypeB,
        ],
        arguments: [flashLoanRepayCoin],
    });
    if (flashLoanObj.provider === StrategyFlashLoanProvider.MMT) {
        transaction.moveCall({
            target: `${mmt_1.MMT_CONTRACT_PACKAGE_ID}::trade::repay_flash_loan`,
            typeArguments: [flashLoanObj.coinTypeA, flashLoanObj.coinTypeB],
            arguments: [
                transaction.object(flashLoanObj.poolId),
                receipt,
                flashLoanObj.borrowA ? flashLoanRepayBalance : borrowedBalanceA,
                flashLoanObj.borrowA ? borrowedBalanceB : flashLoanRepayBalance,
                transaction.object(mmt_1.MMT_VERSION_OBJECT_ID),
            ],
        });
    }
    else {
        throw new Error("Invalid flash loan provider");
    }
    return { deposits, borrowedAmount, transaction };
});
exports.strategyAdjustRepayTx = strategyAdjustRepayTx;
const strategyDepositAdjustWithdrawTx = (
// AppContext
reserveMap, 
// Strategy
lstMap, strategyType, suiClient, suilendClient, cetusSdk, cetusPartnerId, _address, strategyOwnerCapId, obligationId, _deposits, _borrowedAmount, flashLoanBorrowedAmount, transaction, dryRunTransaction) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
    const strategyInfo = strategyOwnerCap_1.STRATEGY_TYPE_INFO_MAP[strategyType];
    const lst = strategyInfo.depositLstCoinType !== undefined
        ? lstMap[strategyInfo.depositLstCoinType]
        : undefined;
    const depositReserves = (0, exports.getStrategyDepositReserves)(reserveMap, strategyType);
    const borrowReserve = (0, exports.getStrategyBorrowReserve)(reserveMap, strategyType);
    const defaultCurrencyReserve = (0, exports.getStrategyDefaultCurrencyReserve)(reserveMap, strategyType);
    const depositAdjustWithdrawExposure = exports.STRATEGY_TYPE_EXPOSURE_MAP[strategyType].max;
    console.log(`[strategyDepositAdjustWithdraw] args |`, JSON.stringify({
        _address,
        strategyOwnerCapId,
        obligationId,
        _deposits: _deposits.map((d) => ({
            coinType: d.coinType,
            depositedAmount: d.depositedAmount.toFixed(20),
        })),
        _borrowedAmount: _borrowedAmount.toFixed(20),
        flashLoanBorrowedAmount: flashLoanBorrowedAmount.toFixed(20),
    }, null, 2));
    const depositReserve = ((_a = depositReserves.base) !== null && _a !== void 0 ? _a : depositReserves.lst); // Must have LST if no base
    //
    let deposits = (0, lodash_1.cloneDeep)(_deposits);
    let borrowedAmount = _borrowedAmount;
    // 1) Flash loan base/LST
    const flashLoanObj = exports.STRATEGY_TYPE_FLASH_LOAN_OBJ_MAP[strategyType];
    if (depositReserve.coinType === ((_b = depositReserves.lst) === null || _b === void 0 ? void 0 : _b.coinType)) {
        // TODO: Account for LST mint fees
        flashLoanBorrowedAmount = flashLoanBorrowedAmount
            .times((_c = lst === null || lst === void 0 ? void 0 : lst.lstToSuiExchangeRate) !== null && _c !== void 0 ? _c : 1)
            .decimalPlaces(utils_1.SUI_DECIMALS, bignumber_js_1.default.ROUND_UP);
    }
    let borrowedBalanceA, borrowedBalanceB, receipt;
    if (flashLoanObj.provider === StrategyFlashLoanProvider.MMT) {
        [borrowedBalanceA, borrowedBalanceB, receipt] = transaction.moveCall({
            target: `${mmt_1.MMT_CONTRACT_PACKAGE_ID}::trade::flash_loan`,
            typeArguments: [flashLoanObj.coinTypeA, flashLoanObj.coinTypeB],
            arguments: [
                transaction.object(flashLoanObj.poolId),
                transaction.pure.u64(flashLoanObj.borrowA
                    ? flashLoanBorrowedAmount
                        .times(10 **
                        (depositReserve.coinType === ((_d = depositReserves.lst) === null || _d === void 0 ? void 0 : _d.coinType)
                            ? utils_1.SUI_DECIMALS
                            : depositReserve.token.decimals))
                        .integerValue(bignumber_js_1.default.ROUND_DOWN)
                        .toString()
                    : 0),
                transaction.pure.u64(flashLoanObj.borrowA
                    ? 0
                    : flashLoanBorrowedAmount
                        .times(10 **
                        (depositReserve.coinType === ((_e = depositReserves.lst) === null || _e === void 0 ? void 0 : _e.coinType)
                            ? utils_1.SUI_DECIMALS
                            : depositReserve.token.decimals))
                        .integerValue(bignumber_js_1.default.ROUND_DOWN)
                        .toString()),
                transaction.object(mmt_1.MMT_VERSION_OBJECT_ID),
            ],
        });
    }
    else {
        throw new Error("Invalid flash loan provider");
    }
    // 2) Deposit additional (to get back up to 100% health, so the user can then unloop back down to the max leverage shown in the UI)
    // 2.1) Deposit
    let depositedAmount = flashLoanBorrowedAmount;
    if (depositReserve.coinType === ((_f = depositReserves.lst) === null || _f === void 0 ? void 0 : _f.coinType))
        depositedAmount = new bignumber_js_1.default(depositedAmount.minus((0, exports.getStrategyLstMintFee)(lstMap, depositReserve.coinType, depositedAmount)))
            .times((_g = lst === null || lst === void 0 ? void 0 : lst.suiToLstExchangeRate) !== null && _g !== void 0 ? _g : 1)
            .decimalPlaces(depositReserve.token.decimals, bignumber_js_1.default.ROUND_DOWN);
    let flashLoanBorrowedCoin = transaction.moveCall({
        target: "0x2::coin::from_balance",
        typeArguments: [
            flashLoanObj.borrowA ? flashLoanObj.coinTypeA : flashLoanObj.coinTypeB,
        ],
        arguments: [flashLoanObj.borrowA ? borrowedBalanceA : borrowedBalanceB],
    });
    if (depositReserve.coinType === ((_h = depositReserves.lst) === null || _h === void 0 ? void 0 : _h.coinType))
        flashLoanBorrowedCoin = lst.client.mint(transaction, flashLoanBorrowedCoin);
    (0, strategyOwnerCap_1.strategyDeposit)(flashLoanBorrowedCoin, depositReserve.coinType, strategyOwnerCapId, suilendClient.findReserveArrayIndex(depositReserve.coinType), transaction);
    // 2.2) Update state
    deposits = (0, exports.addOrInsertStrategyDeposit)(deposits, {
        coinType: depositReserve.coinType,
        depositedAmount,
    });
    // 3) Unloop to max exposure
    // 3.1) Unloop
    const { deposits: newDeposits, borrowedAmount: newBorrowedAmount, transaction: newTransaction, } = yield (0, exports.strategyUnloopToExposureTx)(reserveMap, lstMap, strategyType, suiClient, suilendClient, cetusSdk, cetusPartnerId, _address, strategyOwnerCapId, obligationId, deposits, borrowedAmount, undefined, // Don't pass targetBorrowedAmount
    depositAdjustWithdrawExposure, // Pass targetExposure
    transaction, dryRunTransaction);
    // 3.2) Update state
    deposits = newDeposits;
    borrowedAmount = newBorrowedAmount;
    transaction = newTransaction;
    // 4) Repay flash loan + fee
    const receiptDebts = transaction.moveCall({
        target: `${mmt_1.MMT_CONTRACT_PACKAGE_ID}::trade::flash_receipt_debts`,
        typeArguments: [],
        arguments: [receipt],
    });
    const dryRunResults = yield dryRunTransaction(transaction);
    const flashLoanRepayAmount = new bignumber_js_1.default(bcs_1.bcs
        .u64()
        .parse(new Uint8Array((_m = (_l = (_k = (_j = dryRunResults.results) === null || _j === void 0 ? void 0 : _j.find((r, index) => index === receiptDebts.Result)) === null || _k === void 0 ? void 0 : _k.returnValues) === null || _l === void 0 ? void 0 : _l[flashLoanObj.borrowA ? 0 : 1][0]) !== null && _m !== void 0 ? _m : [0])))
        .div(10 ** depositReserve.token.decimals)
        .decimalPlaces(depositReserve.token.decimals, bignumber_js_1.default.ROUND_UP);
    // 4.1) Withdraw additional + fee
    let withdrawnAmount = flashLoanRepayAmount;
    if (depositReserve.coinType === ((_o = depositReserves.lst) === null || _o === void 0 ? void 0 : _o.coinType))
        withdrawnAmount = withdrawnAmount
            .div(1 - +((_p = lst === null || lst === void 0 ? void 0 : lst.redeemFeePercent) !== null && _p !== void 0 ? _p : 0) / 100) // Potential rounding issue (max 1 MIST)
            .decimalPlaces(depositReserve.token.decimals, bignumber_js_1.default.ROUND_UP);
    const { deposits: newDeposits2, borrowedAmount: newBorrowedAmount2, transaction: newTransaction2, withdrawnCoin, } = yield (0, exports.strategyWithdrawTx)(reserveMap, lstMap, strategyType, suiClient, suilendClient, cetusSdk, cetusPartnerId, _address, strategyOwnerCapId, obligationId, deposits, borrowedAmount, {
        coinType: depositReserve.coinType,
        withdrawnAmount,
    }, transaction, dryRunTransaction, true);
    if (!withdrawnCoin)
        throw new Error("Withdrawn coin not found");
    // 4.2) Update state
    deposits = newDeposits2;
    borrowedAmount = newBorrowedAmount2;
    transaction = newTransaction2;
    // 4.3) Repay flash loan
    let flashLoanRepayCoin = withdrawnCoin;
    if (depositReserve.coinType === ((_q = depositReserves.lst) === null || _q === void 0 ? void 0 : _q.coinType))
        flashLoanRepayCoin = lst.client.redeem(transaction, flashLoanRepayCoin);
    const flashLoanRepayBalance = transaction.moveCall({
        target: "0x2::coin::into_balance",
        typeArguments: [
            flashLoanObj.borrowA ? flashLoanObj.coinTypeA : flashLoanObj.coinTypeB,
        ],
        arguments: [flashLoanRepayCoin],
    });
    if (flashLoanObj.provider === StrategyFlashLoanProvider.MMT) {
        transaction.moveCall({
            target: `${mmt_1.MMT_CONTRACT_PACKAGE_ID}::trade::repay_flash_loan`,
            typeArguments: [flashLoanObj.coinTypeA, flashLoanObj.coinTypeB],
            arguments: [
                transaction.object(flashLoanObj.poolId),
                receipt,
                flashLoanObj.borrowA ? flashLoanRepayBalance : borrowedBalanceA,
                flashLoanObj.borrowA ? borrowedBalanceB : flashLoanRepayBalance,
                transaction.object(mmt_1.MMT_VERSION_OBJECT_ID),
            ],
        });
    }
    else {
        throw new Error("Invalid flash loan provider");
    }
    return { deposits, borrowedAmount, transaction };
});
exports.strategyDepositAdjustWithdrawTx = strategyDepositAdjustWithdrawTx;
const strategyAdjustTx = (
// AppContext
reserveMap, 
// Strategy
lstMap, strategyType, suiClient, suilendClient, cetusSdk, cetusPartnerId, _address, strategyOwnerCapId, obligation, _deposits, _borrowedAmount, targetExposure, transaction, dryRunTransaction) => __awaiter(void 0, void 0, void 0, function* () {
    const strategyInfo = strategyOwnerCap_1.STRATEGY_TYPE_INFO_MAP[strategyType];
    const lst = strategyInfo.depositLstCoinType !== undefined
        ? lstMap[strategyInfo.depositLstCoinType]
        : undefined;
    const depositReserves = (0, exports.getStrategyDepositReserves)(reserveMap, strategyType);
    const borrowReserve = (0, exports.getStrategyBorrowReserve)(reserveMap, strategyType);
    const defaultCurrencyReserve = (0, exports.getStrategyDefaultCurrencyReserve)(reserveMap, strategyType);
    const exposure = (0, exports.getStrategyExposure)(reserveMap, lstMap, strategyType, obligation);
    console.log(`[strategyAdjust] args |`, JSON.stringify({
        _address,
        strategyOwnerCapId,
        obligationId: obligation.id,
        _deposits: _deposits.map((d) => ({
            coinType: d.coinType,
            depositedAmount: d.depositedAmount.toFixed(20),
        })),
        _borrowedAmount: _borrowedAmount.toFixed(20),
        targetExposure: targetExposure.toFixed(20),
    }, null, 2));
    //
    const deposits = (0, lodash_1.cloneDeep)(_deposits);
    const borrowedAmount = _borrowedAmount;
    // 1) Loop or unloop to target exposure
    if (targetExposure.gt(exposure))
        return (0, exports.strategyLoopToExposureTx)(reserveMap, lstMap, strategyType, suiClient, suilendClient, cetusSdk, cetusPartnerId, _address, strategyOwnerCapId, obligation.id, deposits, borrowedAmount, undefined, // Don't pass targetBorrowedAmount
        targetExposure, // Pass targetExposure
        transaction);
    else if (targetExposure.lt(exposure))
        return (0, exports.strategyUnloopToExposureTx)(reserveMap, lstMap, strategyType, suiClient, suilendClient, cetusSdk, cetusPartnerId, _address, strategyOwnerCapId, obligation.id, deposits, borrowedAmount, undefined, // Don't pass targetBorrowedAmount
        targetExposure, // Pass targetExposure
        transaction, dryRunTransaction);
    else
        return { deposits, borrowedAmount, transaction };
});
exports.strategyAdjustTx = strategyAdjustTx;
