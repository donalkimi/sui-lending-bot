"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSwapTransaction = void 0;
const cjs_1 = require("@bluefin-exchange/bluefin7k-aggregator-sdk/cjs");
const sdk_1 = require("@flowx-finance/sdk");
const sui_fe_1 = require("@suilend/sui-fe");
const quote_1 = require("./quote");
const getSwapTransactionWrapper = (provider, getSwapTransaction) => __awaiter(void 0, void 0, void 0, function* () {
    console.log(`[getSwapTransactionWrapper] fetching transaction for ${provider} quote`);
    try {
        const res = yield getSwapTransaction();
        console.log(`[getSwapTransactionWrapper] fetched transaction for ${provider} quote`);
        return res;
    }
    catch (err) {
        console.error(err);
        throw err;
    }
});
const getSwapTransaction = (suiClient, address, quote, slippagePercent, sdkMap, partnerIdMap, transaction, coinIn) => __awaiter(void 0, void 0, void 0, function* () {
    if (quote.provider === quote_1.QuoteProvider.AFTERMATH) {
        return getSwapTransactionWrapper(quote_1.QuoteProvider.AFTERMATH, () => __awaiter(void 0, void 0, void 0, function* () {
            const { tx: transaction2, coinOutId: coinOut } = yield sdkMap[quote_1.QuoteProvider.AFTERMATH]
                .Router()
                .addTransactionForCompleteTradeRoute({
                tx: transaction,
                walletAddress: address,
                completeRoute: quote.quote,
                slippage: slippagePercent / 100,
                coinInId: coinIn,
            });
            return { transaction: transaction2, coinOut };
        }));
    }
    else if (quote.provider === quote_1.QuoteProvider.CETUS) {
        return getSwapTransactionWrapper(quote_1.QuoteProvider.CETUS, () => __awaiter(void 0, void 0, void 0, function* () {
            if (!coinIn) {
                const allCoinsIn = yield (0, sui_fe_1.getAllCoins)(suiClient, address, quote.in.coinType);
                const mergeCoinIn = (0, sui_fe_1.mergeAllCoins)(quote.in.coinType, transaction, allCoinsIn);
                [coinIn] = transaction.splitCoins((0, sui_fe_1.isSui)(quote.in.coinType)
                    ? transaction.gas
                    : transaction.object(mergeCoinIn.coinObjectId), [BigInt(quote.quote.amountIn.toString())]);
            }
            const coinOut = yield sdkMap[quote_1.QuoteProvider.CETUS].routerSwap({
                router: quote.quote,
                inputCoin: coinIn,
                slippage: slippagePercent / 100,
                txb: transaction,
                partner: partnerIdMap[quote_1.QuoteProvider.CETUS],
            });
            return { transaction, coinOut };
        }));
    }
    else if (quote.provider === quote_1.QuoteProvider.BLUEFIN7K) {
        return getSwapTransactionWrapper(quote_1.QuoteProvider.BLUEFIN7K, () => __awaiter(void 0, void 0, void 0, function* () {
            const { tx: transaction2, coinOut } = yield (0, cjs_1.buildTx)({
                quoteResponse: quote.quote,
                accountAddress: address,
                slippage: slippagePercent / 100,
                commission: {
                    partner: partnerIdMap[quote_1.QuoteProvider.BLUEFIN7K],
                    commissionBps: 0,
                },
                extendTx: {
                    tx: transaction,
                    coinIn,
                },
            });
            if (transaction2 instanceof cjs_1.BluefinXTx) {
                // BluefinXTx
                throw new Error("BluefinXTx not supported");
            }
            else {
                return { transaction: transaction2, coinOut };
            }
        }));
    }
    else if (quote.provider === quote_1.QuoteProvider.FLOWX) {
        return getSwapTransactionWrapper(quote_1.QuoteProvider.FLOWX, () => __awaiter(void 0, void 0, void 0, function* () {
            if (!coinIn) {
                const allCoinsIn = yield (0, sui_fe_1.getAllCoins)(suiClient, address, quote.in.coinType);
                const mergeCoinIn = (0, sui_fe_1.mergeAllCoins)(quote.in.coinType, transaction, allCoinsIn);
                [coinIn] = transaction.splitCoins((0, sui_fe_1.isSui)(quote.in.coinType)
                    ? transaction.gas
                    : transaction.object(mergeCoinIn.coinObjectId), [BigInt(quote.quote.amountIn.toString())]);
            }
            const trade = new sdk_1.TradeBuilder("mainnet", quote.quote.routes)
                .slippage((slippagePercent / 100) * 1e6)
                .commission(new sdk_1.Commission(partnerIdMap[quote_1.QuoteProvider.FLOWX], new sdk_1.Coin(quote.out.coinType), sdk_1.CommissionType.PERCENTAGE, 0, false))
                .build();
            const coinOut = yield trade.swap({
                coinIn: coinIn,
                client: suiClient,
                tx: transaction,
            });
            return { transaction, coinOut: coinOut };
        }));
    }
    else
        throw new Error("Unknown quote type");
});
exports.getSwapTransaction = getSwapTransaction;
