"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAggSortedQuotesAll = exports.getAggQuotes = exports.QUOTE_PROVIDER_NAME_MAP = exports.QuoteProvider = void 0;
const cjs_1 = require("@bluefin-exchange/bluefin7k-aggregator-sdk/cjs");
const utils_1 = require("@mysten/sui/utils");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const bn_js_1 = __importDefault(require("bn.js"));
const uuid_1 = require("uuid");
const lib_1 = require("../lib");
var QuoteProvider;
(function (QuoteProvider) {
    QuoteProvider["AFTERMATH"] = "aftermath";
    QuoteProvider["CETUS"] = "cetus";
    QuoteProvider["BLUEFIN7K"] = "bluefin7k";
    QuoteProvider["FLOWX"] = "flowx";
})(QuoteProvider || (exports.QuoteProvider = QuoteProvider = {}));
exports.QUOTE_PROVIDER_NAME_MAP = {
    [QuoteProvider.AFTERMATH]: "Aftermath",
    [QuoteProvider.CETUS]: "Cetus",
    [QuoteProvider.BLUEFIN7K]: "Bluefin7k",
    [QuoteProvider.FLOWX]: "FlowX",
};
const getPoolProviders = (standardizedQuote) => {
    return Array.from(new Set(standardizedQuote.routes.reduce((acc, route) => [
        ...acc,
        ...route.path.reduce((acc2, p) => [...acc2, p.provider], []),
    ], [])));
};
const getAggQuoteWrapper = (provider, getAggQuote, timeoutMs) => __awaiter(void 0, void 0, void 0, function* () {
    console.log(`[getAggQuoteWrapper] getting ${provider} quote`);
    try {
        const timeoutPromise = new Promise((resolve) => {
            setTimeout(() => resolve(null), timeoutMs);
        });
        const standardizedQuote = yield Promise.race([
            getAggQuote(),
            timeoutPromise,
        ]);
        if (!standardizedQuote)
            throw new Error(`No ${provider} quote returned within ${timeoutMs}ms`);
        console.log(`[getAggQuoteWrapper] got ${provider} quote`, +standardizedQuote.out.amount, "pool providers:", standardizedQuote, "quote:", standardizedQuote.quote);
        return standardizedQuote;
    }
    catch (err) {
        console.error(err);
        return null;
    }
});
const getAftermathQuote = (sdk, tokenIn, tokenOut, amountIn) => __awaiter(void 0, void 0, void 0, function* () {
    const quote = yield sdk.Router().getCompleteTradeRouteGivenAmountIn({
        coinInType: tokenIn.coinType,
        coinOutType: tokenOut.coinType,
        coinInAmount: BigInt(amountIn),
    });
    const standardizedQuote = {
        id: (0, uuid_1.v4)(),
        provider: QuoteProvider.AFTERMATH,
        in: {
            coinType: tokenIn.coinType,
            amount: new bignumber_js_1.default(quote.coinIn.amount.toString()).div(10 ** tokenIn.decimals),
        },
        out: {
            coinType: tokenOut.coinType,
            amount: new bignumber_js_1.default(quote.coinOut.amount.toString()).div(10 ** tokenOut.decimals),
        },
        routes: quote.routes.map((route, routeIndex) => ({
            percent: new bignumber_js_1.default(route.portion.toString()).div(lib_1.WAD).times(100),
            path: route.paths.map((path) => ({
                id: (0, uuid_1.v4)(),
                poolId: path.poolId,
                routeIndex,
                provider: path.protocolName,
                in: {
                    coinType: (0, utils_1.normalizeStructTag)(path.coinIn.type),
                    amount: new bignumber_js_1.default(path.coinIn.amount.toString()),
                },
                out: {
                    coinType: (0, utils_1.normalizeStructTag)(path.coinOut.type),
                    amount: new bignumber_js_1.default(path.coinOut.amount.toString()),
                },
            })),
        })),
        quote,
    };
    return standardizedQuote;
});
const getCetusQuote = (sdk, tokenIn, tokenOut, amountIn) => __awaiter(void 0, void 0, void 0, function* () {
    const quote = yield sdk.findRouters({
        from: tokenIn.coinType,
        target: tokenOut.coinType,
        amount: new bn_js_1.default(amountIn),
        byAmountIn: true,
    });
    if (!quote)
        return null;
    const routes = [];
    // First pass: build initial routes
    for (const path of quote.paths) {
        let addedToExistingRoute = false;
        // Try to add to an existing route
        for (const route of routes) {
            if (route.paths.length > 0 &&
                path.amountIn === route.paths[route.paths.length - 1].amountOut &&
                (0, utils_1.normalizeStructTag)(path.from) ===
                    (0, utils_1.normalizeStructTag)(route.paths[route.paths.length - 1].target)) {
                route.paths.push(path);
                addedToExistingRoute = true;
                break;
            }
        }
        // If couldn't add to existing route, only start a new route if it's from the quote's from field
        if (!addedToExistingRoute &&
            (0, utils_1.normalizeStructTag)(path.from) === (0, utils_1.normalizeStructTag)(tokenIn.coinType)) {
            routes.push({
                amountIn: new bignumber_js_1.default(path.amountIn),
                paths: [path],
            });
        }
    }
    const remainingPaths = quote.paths.filter((path) => !routes.some((route) => route.paths.some((p) => p.id === path.id)));
    // TODO
    const standardizedQuote = {
        id: (0, uuid_1.v4)(),
        provider: QuoteProvider.CETUS,
        in: {
            coinType: tokenIn.coinType,
            amount: new bignumber_js_1.default(quote.amountIn.toString()).div(10 ** tokenIn.decimals),
        },
        out: {
            coinType: tokenOut.coinType,
            amount: new bignumber_js_1.default(quote.amountOut.toString()).div(10 ** tokenOut.decimals),
        },
        routes: routes.map((route, routeIndex) => ({
            percent: new bignumber_js_1.default(route.amountIn.toString())
                .div(quote.amountIn.toString())
                .times(100),
            path: route.paths.map((path) => ({
                id: (0, uuid_1.v4)(),
                poolId: path.id,
                routeIndex,
                provider: path.provider,
                in: {
                    coinType: (0, utils_1.normalizeStructTag)(path.from),
                    amount: new bignumber_js_1.default(path.amountIn.toString()),
                },
                out: {
                    coinType: (0, utils_1.normalizeStructTag)(path.target),
                    amount: new bignumber_js_1.default(path.amountOut.toString()),
                },
            })),
        })),
        quote,
    };
    return standardizedQuote;
});
const getBluefin7kQuote = (tokenIn, tokenOut, amountIn) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const quote = yield (0, cjs_1.getQuote)({
        tokenIn: tokenIn.coinType,
        tokenOut: tokenOut.coinType,
        amountIn,
    });
    const standardizedQuote = {
        id: (0, uuid_1.v4)(),
        provider: QuoteProvider.BLUEFIN7K,
        in: {
            coinType: tokenIn.coinType,
            amount: new bignumber_js_1.default(quote.swapAmountWithDecimal).div(10 ** tokenIn.decimals),
        },
        out: {
            coinType: tokenOut.coinType,
            amount: new bignumber_js_1.default(quote.returnAmountWithDecimal).div(10 ** tokenOut.decimals),
        },
        routes: ((_a = quote.routes) !== null && _a !== void 0 ? _a : []).map((route, routeIndex) => ({
            percent: new bignumber_js_1.default(route.tokenInAmount)
                .div(quote.swapAmount)
                .times(100),
            path: route.hops.map((hop) => ({
                id: (0, uuid_1.v4)(),
                poolId: hop.poolId,
                routeIndex,
                provider: hop.pool.type,
                in: {
                    coinType: (0, utils_1.normalizeStructTag)(hop.tokenIn),
                    amount: new bignumber_js_1.default(hop.tokenInAmount).times(10 **
                        hop.pool.allTokens.find((t) => (0, utils_1.normalizeStructTag)(t.address) ===
                            (0, utils_1.normalizeStructTag)(hop.tokenIn)).decimal),
                },
                out: {
                    coinType: (0, utils_1.normalizeStructTag)(hop.tokenOut),
                    amount: new bignumber_js_1.default(hop.tokenOutAmount).times(10 **
                        hop.pool.allTokens.find((t) => (0, utils_1.normalizeStructTag)(t.address) ===
                            (0, utils_1.normalizeStructTag)(hop.tokenOut)).decimal),
                },
            })),
        })),
        quote,
    };
    return standardizedQuote;
});
const getFlowXQuote = (sdk, tokenIn, tokenOut, amountIn) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const quote = yield sdk.getRoutes({
        tokenIn: tokenIn.coinType,
        tokenOut: tokenOut.coinType,
        amountIn: amountIn,
    });
    const standardizedQuote = {
        id: (0, uuid_1.v4)(),
        provider: QuoteProvider.FLOWX,
        in: {
            coinType: tokenIn.coinType,
            amount: new bignumber_js_1.default(quote.amountIn.toString()).div(10 ** tokenIn.decimals),
        },
        out: {
            coinType: tokenOut.coinType,
            amount: new bignumber_js_1.default(quote.amountOut.toString()).div(10 ** tokenOut.decimals),
        },
        routes: ((_a = quote.routes) !== null && _a !== void 0 ? _a : []).map((route, routeIndex) => ({
            percent: new bignumber_js_1.default(route.amountIn.toString())
                .div(quote.amountIn.toString())
                .times(100),
            path: route.paths.map((hop) => ({
                id: (0, uuid_1.v4)(),
                poolId: hop.pool.id,
                routeIndex,
                provider: hop.protocol(),
                in: {
                    coinType: (0, utils_1.normalizeStructTag)(hop.input.coinType),
                    amount: new bignumber_js_1.default(hop.amountIn.toString()),
                },
                out: {
                    coinType: (0, utils_1.normalizeStructTag)(hop.output.coinType),
                    amount: new bignumber_js_1.default(hop.amountOut.toString()),
                },
            })),
        })),
        quote,
    };
    return standardizedQuote;
});
const getAggQuotes = (sdkMap, activeProviders, onGetAggQuote, tokenIn, tokenOut, amountIn) => __awaiter(void 0, void 0, void 0, function* () {
    const timeoutMs = 15000;
    // Get quotes in parallel
    // Aftermath
    if (activeProviders.includes(QuoteProvider.AFTERMATH)) {
        (() => __awaiter(void 0, void 0, void 0, function* () {
            const standardizedQuote = yield getAggQuoteWrapper(QuoteProvider.AFTERMATH, () => getAftermathQuote(sdkMap[QuoteProvider.AFTERMATH], tokenIn, tokenOut, amountIn), timeoutMs);
            onGetAggQuote(standardizedQuote);
        }))();
    }
    // Cetus
    if (activeProviders.includes(QuoteProvider.CETUS)) {
        (() => __awaiter(void 0, void 0, void 0, function* () {
            const standardizedQuote = yield getAggQuoteWrapper(QuoteProvider.CETUS, () => getCetusQuote(sdkMap[QuoteProvider.CETUS], tokenIn, tokenOut, amountIn), timeoutMs);
            onGetAggQuote(standardizedQuote);
        }))();
    }
    // Bluefin7k
    if (activeProviders.includes(QuoteProvider.BLUEFIN7K)) {
        (() => __awaiter(void 0, void 0, void 0, function* () {
            const standardizedQuote = yield getAggQuoteWrapper(QuoteProvider.BLUEFIN7K, () => getBluefin7kQuote(tokenIn, tokenOut, amountIn), timeoutMs);
            onGetAggQuote(standardizedQuote);
        }))();
    }
    // FlowX
    if (activeProviders.includes(QuoteProvider.FLOWX)) {
        (() => __awaiter(void 0, void 0, void 0, function* () {
            const standardizedQuote = yield getAggQuoteWrapper(QuoteProvider.FLOWX, () => getFlowXQuote(sdkMap[QuoteProvider.FLOWX], tokenIn, tokenOut, amountIn), timeoutMs);
            onGetAggQuote(standardizedQuote);
        }))();
    }
});
exports.getAggQuotes = getAggQuotes;
const getAggSortedQuotesAll = (sdkMap, activeProviders, tokenIn, tokenOut, amountIn) => __awaiter(void 0, void 0, void 0, function* () {
    const timeoutMs = 1500;
    // Get quotes in parallel
    const quotes = yield Promise.all([
        activeProviders.includes(QuoteProvider.AFTERMATH)
            ? getAggQuoteWrapper(QuoteProvider.AFTERMATH, () => getAftermathQuote(sdkMap[QuoteProvider.AFTERMATH], tokenIn, tokenOut, amountIn), timeoutMs)
            : null,
        activeProviders.includes(QuoteProvider.CETUS)
            ? getAggQuoteWrapper(QuoteProvider.CETUS, () => getCetusQuote(sdkMap[QuoteProvider.CETUS], tokenIn, tokenOut, amountIn), timeoutMs)
            : null,
        activeProviders.includes(QuoteProvider.BLUEFIN7K)
            ? getAggQuoteWrapper(QuoteProvider.BLUEFIN7K, () => getBluefin7kQuote(tokenIn, tokenOut, amountIn), timeoutMs)
            : null,
        activeProviders.includes(QuoteProvider.FLOWX)
            ? getAggQuoteWrapper(QuoteProvider.FLOWX, () => getFlowXQuote(sdkMap[QuoteProvider.FLOWX], tokenIn, tokenOut, amountIn), timeoutMs)
            : null,
    ].filter(Boolean));
    const sortedQuotes = quotes.filter(Boolean)
        .slice()
        .sort((a, b) => +b.out.amount.minus(a.out.amount));
    return sortedQuotes;
});
exports.getAggSortedQuotesAll = getAggSortedQuotesAll;
