"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchRegistryLiquidStakingInfoMap = exports.fetchLiquidStakingInfo = exports.LstClient = exports.ADMIN_ADDRESS = exports.SPRING_SUI_UPGRADE_CAP_ID = exports.SUILEND_VALIDATOR_ADDRESS = void 0;
exports.getLatestPackageId = getLatestPackageId;
const utils_1 = require("@mysten/sui/utils");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const reified_1 = require("./_generated/_framework/reified");
const liquid_staking_1 = require("./_generated/liquid_staking");
const functions_1 = require("./_generated/liquid_staking/fees/functions");
const generated = __importStar(require("./_generated/liquid_staking/liquid-staking/functions"));
const structs_1 = require("./_generated/liquid_staking/liquid-staking/structs");
const weightHookGenerated = __importStar(require("./_generated/liquid_staking/weight/functions"));
const structs_2 = require("./_generated/liquid_staking/weight/structs");
const SUI_SYSTEM_STATE_ID = "0x0000000000000000000000000000000000000000000000000000000000000005";
exports.SUILEND_VALIDATOR_ADDRESS = "0xce8e537664ba5d1d5a6a857b17bd142097138706281882be6805e17065ecde89";
exports.SPRING_SUI_UPGRADE_CAP_ID = "0x4dc657b6c0fe896f4b94fee1ceac96312dde0a36b94e799caaec30deb53dcd67";
exports.ADMIN_ADDRESS = "0xb1ffbc2e1915f44b8f271a703becc1bf8aa79bc22431a58900a102892b783c25";
function getLatestPackageId(client, upgradeCapId) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const object = yield client.getObject({
            id: upgradeCapId,
            options: {
                showContent: true,
            },
        });
        return ((_a = object.data) === null || _a === void 0 ? void 0 : _a.content).fields.package;
    });
}
class LstClient {
    static initialize(client, liquidStakingObjectInfo, _publishedAt, logPackageId) {
        return __awaiter(this, void 0, void 0, function* () {
            const publishedAt = _publishedAt !== null && _publishedAt !== void 0 ? _publishedAt : (yield getLatestPackageId(client, exports.SPRING_SUI_UPGRADE_CAP_ID));
            if (logPackageId)
                console.log("@suilend/springsui-sdk | publishedAt:", publishedAt);
            (0, liquid_staking_1.setPublishedAt)(publishedAt);
            return new LstClient(liquidStakingObjectInfo, client);
        });
    }
    static createNewLst(tx, treasuryCap, coinType) {
        const [feeConfigBuilder] = (0, functions_1.newBuilder)(tx);
        const [feeConfig] = (0, functions_1.toFeeConfig)(tx, feeConfigBuilder);
        const [adminCap, liquidStakingInfo] = generated.createLst(tx, coinType, {
            feeConfig,
            lstTreasuryCap: treasuryCap,
        });
        const [weightHook, weightHookAdminCap] = weightHookGenerated.new_(tx, coinType, adminCap);
        weightHookGenerated.addToRegistry(tx, coinType, {
            self: weightHook,
            registry: tx.object("0x577c5a3b474403aec4629a56bab97b95715d3e87867517650651014cbef23e18"),
            liquidStakingInfo,
        });
        tx.moveCall({
            target: `0x2::transfer::public_share_object`,
            typeArguments: [`${structs_1.LiquidStakingInfo.$typeName}<${coinType}>`],
            arguments: [liquidStakingInfo],
        });
        tx.moveCall({
            target: `0x2::transfer::public_share_object`,
            typeArguments: [`${structs_2.WeightHook.$typeName}<${coinType}>`],
            arguments: [weightHook],
        });
        return weightHookAdminCap;
    }
    static getWeightHookAdminCapId(client, address, coinType) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const res = (yield client.getOwnedObjects({
                owner: address,
                filter: {
                    StructType: `${liquid_staking_1.PACKAGE_ID}::weight::WeightHookAdminCap<${coinType}>`,
                },
            })).data;
            if (res.length == 0) {
                return null;
            }
            return (_a = res[0].data) === null || _a === void 0 ? void 0 : _a.objectId;
        });
    }
    constructor(liquidStakingObject, client) {
        this.liquidStakingObject = liquidStakingObject;
        this.client = client;
    }
    getAdminCapId(address) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const res = (yield this.client.getOwnedObjects({
                owner: address,
                filter: {
                    StructType: `${liquid_staking_1.PACKAGE_ID}::liquid_staking::AdminCap<${this.liquidStakingObject.type}>`,
                },
            })).data;
            if (res.length == 0) {
                return null;
            }
            return (_a = res[0].data) === null || _a === void 0 ? void 0 : _a.objectId;
        });
    }
    // returns the lst object
    mint(tx, suiCoinId) {
        const [lst] = generated.mint(tx, this.liquidStakingObject.type, {
            self: this.liquidStakingObject.id,
            sui: suiCoinId,
            systemState: SUI_SYSTEM_STATE_ID,
        });
        return lst;
    }
    mintAmountAndRebalance(tx, address, amount) {
        const [suiCoin] = tx.splitCoins(tx.gas, [BigInt(amount)]);
        const lst = this.mint(tx, suiCoin);
        this.rebalance(tx, this.liquidStakingObject.weightHookId);
        return lst;
    }
    mintAmountAndRebalanceAndSendToUser(tx, address, amount) {
        const lst = this.mintAmountAndRebalance(tx, address, amount);
        tx.transferObjects([lst], address);
    }
    // returns the sui coin
    redeem(tx, lstId) {
        const [suiCoin] = generated.redeem(tx, this.liquidStakingObject.type, {
            self: this.liquidStakingObject.id,
            systemState: SUI_SYSTEM_STATE_ID,
            lst: lstId,
        });
        return suiCoin;
    }
    redeemAmountAndRebalance(tx, address, amount, client) {
        return __awaiter(this, void 0, void 0, function* () {
            const coins = (yield client.getCoins({
                owner: address,
                coinType: this.liquidStakingObject.type,
            })).data;
            const mergeCoin = coins[0];
            if (coins.length > 1) {
                tx.mergeCoins(tx.object(mergeCoin.coinObjectId), coins.map((c) => tx.object(c.coinObjectId)).slice(1));
            }
            const [lstCoin] = tx.splitCoins(tx.object(mergeCoin.coinObjectId), [
                BigInt(amount),
            ]);
            const suiCoin = this.redeem(tx, lstCoin);
            this.rebalance(tx, this.liquidStakingObject.weightHookId);
            return suiCoin;
        });
    }
    redeemAmountAndRebalanceAndSendToUser(tx, address, amount, client) {
        return __awaiter(this, void 0, void 0, function* () {
            const suiCoin = yield this.redeemAmountAndRebalance(tx, address, amount, client);
            tx.transferObjects([suiCoin], address);
        });
    }
    // admin functions
    increaseValidatorStake(tx, adminCapId, validatorAddress, suiAmount) {
        generated.increaseValidatorStake(tx, this.liquidStakingObject.type, {
            self: this.liquidStakingObject.id,
            adminCap: adminCapId,
            systemState: SUI_SYSTEM_STATE_ID,
            validatorAddress,
            suiAmount: BigInt(suiAmount),
        });
    }
    decreaseValidatorStake(tx, adminCapId, validatorAddress, targetUnstakeSuiAmount) {
        generated.decreaseValidatorStake(tx, this.liquidStakingObject.type, {
            self: this.liquidStakingObject.id,
            adminCap: adminCapId,
            systemState: SUI_SYSTEM_STATE_ID,
            validatorAddress,
            targetUnstakeSuiAmount,
        });
    }
    collectFees(tx, weightHookAdminCapId) {
        const [sui] = weightHookGenerated.collectFees(tx, this.liquidStakingObject.type, {
            self: this.liquidStakingObject.weightHookId,
            liquidStakingInfo: this.liquidStakingObject.id,
            systemState: SUI_SYSTEM_STATE_ID,
            weightHookAdminCap: weightHookAdminCapId,
        });
        return sui;
    }
    collectFeesAndSendToUser(tx, weightHookAdminCapId, address) {
        const sui = this.collectFees(tx, weightHookAdminCapId);
        tx.transferObjects([sui], address);
    }
    updateFees(tx, weightHookAdminCapId, feeConfigArgs) {
        let [builder] = (0, functions_1.newBuilder)(tx);
        if (feeConfigArgs.mintFeeBps != null) {
            console.log(`Setting mint fee bps to ${feeConfigArgs.mintFeeBps}`);
            builder = (0, functions_1.setSuiMintFeeBps)(tx, {
                self: builder,
                fee: BigInt(feeConfigArgs.mintFeeBps),
            })[0];
        }
        if (feeConfigArgs.redeemFeeBps != null) {
            console.log(`Setting redeem fee bps to ${feeConfigArgs.redeemFeeBps}`);
            builder = (0, functions_1.setRedeemFeeBps)(tx, {
                self: builder,
                fee: BigInt(feeConfigArgs.redeemFeeBps),
            })[0];
        }
        if (feeConfigArgs.spreadFeeBps != null) {
            console.log(`Setting spread fee bps to ${feeConfigArgs.spreadFeeBps}`);
            builder = (0, functions_1.setSpreadFeeBps)(tx, {
                self: builder,
                fee: BigInt(feeConfigArgs.spreadFeeBps),
            })[0];
        }
        const [feeConfig] = (0, functions_1.toFeeConfig)(tx, builder);
        weightHookGenerated.updateFees(tx, this.liquidStakingObject.type, {
            self: this.liquidStakingObject.weightHookId,
            liquidStakingInfo: this.liquidStakingObject.id,
            weightHookAdminCap: weightHookAdminCapId,
            feeConfig,
        });
    }
    // weight hook functions
    initializeWeightHook(tx, adminCapId) {
        const [weightHook, weightHookAdminCap] = weightHookGenerated.new_(tx, this.liquidStakingObject.type, adminCapId);
        tx.moveCall({
            target: `0x2::transfer::public_share_object`,
            typeArguments: [
                `${structs_2.WeightHook.$typeName}<${this.liquidStakingObject.type}>`,
            ],
            arguments: [weightHook],
        });
        return weightHookAdminCap;
    }
    setValidatorAddressesAndWeights(tx, weightHookId, weightHookAdminCap, validatorAddressesAndWeights) {
        const [vecMap] = tx.moveCall({
            target: `0x2::vec_map::empty`,
            typeArguments: ["address", "u64"],
            arguments: [],
        });
        for (const [validatorAddress, weight] of Object.entries(validatorAddressesAndWeights)) {
            tx.moveCall({
                target: `0x2::vec_map::insert`,
                typeArguments: ["address", "u64"],
                arguments: [
                    vecMap,
                    tx.pure.address(validatorAddress),
                    tx.pure.u64(weight),
                ],
            });
        }
        weightHookGenerated.setValidatorAddressesAndWeights(tx, this.liquidStakingObject.type, {
            self: weightHookId,
            weightHookAdminCap,
            validatorAddressesAndWeights: vecMap,
        });
    }
    rebalance(tx, weightHookId) {
        weightHookGenerated.rebalance(tx, this.liquidStakingObject.type, {
            self: weightHookId,
            systemState: SUI_SYSTEM_STATE_ID,
            liquidStakingInfo: this.liquidStakingObject.id,
        });
    }
    getSpringSuiApy(_validatorApys) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const validatorApys = _validatorApys !== null && _validatorApys !== void 0 ? _validatorApys : (yield this.client.getValidatorsApy()).apys;
            const liquidStakingInfo = yield (0, exports.fetchLiquidStakingInfo)(this.liquidStakingObject, this.client);
            const totalSuiSupply = new bignumber_js_1.default(liquidStakingInfo.storage.totalSuiSupply.toString()).div(10 ** utils_1.SUI_DECIMALS);
            const spreadFeePercent = new bignumber_js_1.default((_b = (_a = liquidStakingInfo.feeConfig.element) === null || _a === void 0 ? void 0 : _a.spreadFeeBps.toString()) !== null && _b !== void 0 ? _b : 0).div(100);
            return new bignumber_js_1.default(totalSuiSupply.gt(0)
                ? liquidStakingInfo.storage.validatorInfos
                    .reduce((acc, validatorInfo) => {
                    var _a, _b;
                    const validatorApy = new bignumber_js_1.default((_b = (_a = validatorApys.find((_apy) => _apy.address === validatorInfo.validatorAddress)) === null || _a === void 0 ? void 0 : _a.apy) !== null && _b !== void 0 ? _b : 0);
                    const validatorTotalSuiAmount = new bignumber_js_1.default(validatorInfo.totalSuiAmount.toString()).div(10 ** utils_1.SUI_DECIMALS);
                    return acc.plus(validatorApy.times(validatorTotalSuiAmount));
                }, new bignumber_js_1.default(0))
                    .div(totalSuiSupply)
                : new bignumber_js_1.default(0)).times(new bignumber_js_1.default(1).minus(spreadFeePercent.div(100)));
        });
    }
}
exports.LstClient = LstClient;
// user functions
const fetchLiquidStakingInfo = (info, client) => structs_1.LiquidStakingInfo.fetch(client, (0, reified_1.phantom)(info.type), info.id);
exports.fetchLiquidStakingInfo = fetchLiquidStakingInfo;
const fetchRegistryLiquidStakingInfoMap = (client) => __awaiter(void 0, void 0, void 0, function* () {
    const REGISTRY_ID = "0x06d6b6881ef14ad1a8cc29d1f97ba3397ecea56af5afa0642093e981b1fda3f4";
    const registryObjectIds = [];
    let cursor = null;
    let hasNextPage = true;
    while (hasNextPage) {
        const page = yield client.getDynamicFields({
            parentId: REGISTRY_ID,
            cursor,
        });
        registryObjectIds.push(...page.data.map((d) => d.objectId));
        cursor = page.nextCursor;
        hasNextPage = page.hasNextPage;
    }
    const registryObjects = yield Promise.all(registryObjectIds.map((objectId) => client.getObject({
        id: objectId,
        options: {
            showContent: true,
        },
    })));
    const LIQUID_STAKING_INFO_MAP = registryObjects.reduce((acc, obj) => {
        var _a;
        const fields = ((_a = obj.data) === null || _a === void 0 ? void 0 : _a.content).fields;
        const id = fields.value.fields.liquid_staking_info_id;
        const coinType = (0, utils_1.normalizeStructTag)(fields.name.fields.name);
        if ([
            "0x460c669acd3f294dc4247a6877ec2532340ffde76162ab201e72fe95355830e7::asui::ASUI",
            "0x752f18582da315f9104bb8b7828188c474e64f23255ed9fd231ed3fa883f27e0::tt_sui::TT_SUI",
            "0x86097c930d227f32dd2cd2ffd03d92b57504abb2b9c9cb83013c3923fa185341::tt_sui::TT_SUI",
            "0x86518340cc15853c76bcb63996c6fb36cd566755a870f46bccd3e95f6a0a4993::test_sui::TEST_SUI",
            "0xbf609bb629a11e7ee7c72bc3d5cf98c1c26cd2e35b2d017be4895d7e0c6be898::temps_sui::TEMPS_SUI",
            "0x4bf0e1d42f731c19066d910ebf7ba12ffe4025258f50b6cc490af38080a15dfb::t0sui::T0SUI",
            "0xbdf600b2f3b5d2b315f0c82ad190d4b40666b823144f5013c02f26045cda98b6::tt_sui::TT_SUI",
            "0xfadc3b0fd8aea6aa485ab48271c957922396ab4984a7045da570cf836ed895cc::root_sui::ROOT_SUI",
            "0xeea0564444d930f77341d7cfed9634b691463988456abcf106f6d6ed02519e43::testy_sui::TESTY_SUI",
            "0xad421271913607cab135184481d65d25f10b3ef4464004fe6333930503404e3d::mjsui2::MJSUI2",
        ].includes(coinType))
            return acc;
        const weightHookId = fields.value.fields.extra_info.fields.weight_hook_id;
        return Object.assign(Object.assign({}, acc), { [coinType]: { id, type: coinType, weightHookId } });
    }, {});
    return LIQUID_STAKING_INFO_MAP;
});
exports.fetchRegistryLiquidStakingInfoMap = fetchRegistryLiquidStakingInfoMap;
